<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vpoet&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-18T17:50:34.044Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>vpoet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>能DDoS的勒索木马FireCrypt进一步分析</title>
    <link href="http://yoursite.com/2017/01/05/%E8%83%BDDDoS%E7%9A%84%E5%8B%92%E7%B4%A2%E6%9C%A8%E9%A9%ACFireCrypt%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/</id>
    <published>2017-01-05T03:37:20.000Z</published>
    <updated>2018-09-18T17:50:34.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：<a href="http://www.freebuf.com/articles/system/124618.html" target="_blank" rel="noopener">流氓会武功：这款勒索软件不仅能勒索，还能DDoS</a>。本文进行后续分析。</p><p>经分析，该类样本通过木马生成器自定义生成，运行该样本会对特定文件类型进行AES加密，同时伴随着持续但微弱的DDoS行为(请求特定网站下载文件)。以下是详细的样本分析结果。</p><h2 id="一．样本运行效果"><a href="#一．样本运行效果" class="headerlink" title="一．样本运行效果"></a>一．样本运行效果</h2><p>该样本运行后会加密系统所有盘符下的特定文件类型的文件，加密后会在文件名后加上firecrypt后缀，如下图所示:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/1.png" alt="病毒分析"></p><p>在加密结束后，样本会在桌面生成两个文件分别为xxxx-READ_ME.html和xxxx-filesencrypted.html，xxxx-READ_ME.html是加密后提示给受害用户的解密提示，xxxx-filesencrypted.html是当前受害者电脑所有被加密文件的路径位置信息，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/2.png" alt="病毒分析"><br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/3.png" alt="病毒分析"></p><p>该解密提示界面警告受害者AES密钥的销毁时间，用户需要在密钥销毁之前向特定比特币地址支付500美元赎金以获得AES密钥和解密程序。木马会在每台被加密的机器上生成一个唯一的USER ID用于识别受害机器。</p><p>此外，在文件加密完成后，该木马会创建数个后台线程去固定的某个网站上下载文件到%Temp%目录下，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/4.png" alt="病毒分析"></p><h2 id="二．样本运行流程"><a href="#二．样本运行流程" class="headerlink" title="二．样本运行流程"></a>二．样本运行流程</h2><p>此木马是基于.NET环境开发，依赖.NET Framework 4.0及以上。通过reflector工具可以对木马进行反编译，从而分析出该木马大致运行流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/5.png" alt="病毒分析"></p><h2 id="三．文件加密分析"><a href="#三．文件加密分析" class="headerlink" title="三．文件加密分析"></a>三．文件加密分析</h2><ol><li>样本首先查找受害电脑的所有盘符:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/6.png" alt="病毒分析"></li></ol><p>然后递归遍历所有系统盘符下的所有文件，查找符合如下后缀名的文件，将这些文件的路径信息加入%AppData%\SysWin32\files.txt，加密文件类型如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/7.png" alt="病毒分析"></p><ol start="2"><li>样本会产生一个32个字符的随机字符串，该随机字符串用于后续AES256密钥的生成:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/8.png" alt="病毒分析"><br>其中随机数产生的算法如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/9.png" alt="病毒分析"></li><li>AES256加密流程如下,Encrypt_Fun方法中调用的AES256_Encrypt为加密的主要函数:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/10.png" alt="病毒分析"><br>AES256_Encrypt方法传入带加密的数据和用于加密的密码，此密码再与一些其它的参数生成真正的密钥，具体流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/11.png" alt="病毒分析"><br>至此，文件完整的加密流程已经完结了。该样本在加密每个文件的时候都会产生一个32个字符的随机字符串，然后通过该随机字符串去生成AES加密密钥。这样每次加密的密钥都是不同的，但是在整个加密流程前后并未发现木马通过网络将密钥发送给远端的服务器，一旦用户的电脑被此类木马感染后，即使向作者给出的比特币地址支付赎金，仍然无法获取需要解密的AES密钥。<h2 id="四．木马的DDoS行为"><a href="#四．木马的DDoS行为" class="headerlink" title="四．木马的DDoS行为"></a>四．木马的DDoS行为</h2>当加密行为完成后，样本将在后台创建多个线程:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/12.png" alt="病毒分析"><br>在DownloadThread函数中会持续对www[.]pta[.]gov[.]pk/index[.]php发出请求，并将该页面下载到%temp%目录并存储:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/13.png" alt="病毒分析"><br>当样本感染的机器足够多的时候，这种正常的Url请求就会变成DDoS攻击。<h2 id="五．结束任务管理器"><a href="#五．结束任务管理器" class="headerlink" title="五．结束任务管理器"></a>五．结束任务管理器</h2>除了以上的文件加密和DDoS行为，样本还会创建一个Timer，每隔500ms将“taskmgr”进程杀掉:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/14.png" alt="病毒分析"><h2 id="六．木马生成器与变种"><a href="#六．木马生成器与变种" class="headerlink" title="六．木马生成器与变种"></a>六．木马生成器与变种</h2>此类通过生成器生成的木马样本，每次生成的样本的哈希值都会发生变化，可以通过不停变种绕过一些仅凭哈希值进行判定的防护措施。不过，此木马并未采取强烈的混淆手段，大多数情况下仍然可以通过静态特征或者动态行为，识别该类生成器产生的木马。</li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：&lt;a href=&quot;http://www.freebuf.com/arti
      
    
    </summary>
    
      <category term="病毒分析" scheme="http://yoursite.com/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
      <category term="病毒分析" scheme="http://yoursite.com/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第二章-寄存器</title>
    <link href="http://yoursite.com/2016/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/14/汇编语言学习第二章-寄存器/</id>
    <published>2016-04-14T01:56:50.000Z</published>
    <updated>2018-09-17T17:19:37.007Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><p>&ensp;&ensp;&ensp;&ensp;在CPU中，有四种主要的部件。运算器，控制器，寄存器，内部总线。这里的内部总线用于CPU内部进行各种信息的传递，与第一章所讲的控制总线，数据总线，地址总线不同，第一章所描述的总线属于外部总线，作为CPU与外部期间进行信息传递的通路。运算器用于各种信息的处理，寄存器用于信息的处理，控制器用于控制信息的处理。对于利用汇编编程来说，寄存器是主要操作的部件，不同的CPU中寄存器的个数和种类是不同的，8086CPU寄存器个数为14个AX,BX,CX,DX,CS,SS,DS,ES,SI,DI,SP,BP,IP,PSW。</p><h2 id="2-1-通用寄存器和字在寄存器中的存储"><a href="#2-1-通用寄存器和字在寄存器中的存储" class="headerlink" title="2.1 通用寄存器和字在寄存器中的存储"></a>2.1 通用寄存器和字在寄存器中的存储</h2><p>&ensp;&ensp;&ensp;&ensp;8086CPU所有的寄存器均为16位，其中AX,BX,CX,DX这四个寄存器一般作为通用的寄存器使用，用于存储一般的数据。16位寄存器能存储的最大值为2^16=65536，在8086CPU寄存器之前有很多8位的寄存器的CPU，为了和以前在8位寄存器下写的程序相兼容，8086CPU将16位寄存器可分为高八位和低八位的寄存器使用。</p><p>&ensp;&ensp;&ensp;&ensp;以AX寄存器为例，其逻辑结构如下图所示，从做到右依次为高位到低位。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/1.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;比如我们存储一个数据2000H(后缀H,hex代表16进制)，其二进制位10000000000000B(B,binary代表二进制),我们将该数据存入AX中为:</p><pre><code>0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0</code></pre> <p>&ensp;&ensp;&ensp;&ensp;当我们将AX分为两个8位寄存器的时候为:AH(AX High 8-BIT),AL(AX Low-BIT)。<br>&ensp;&ensp;&ensp;&ensp;类似的BX,CX,DX分成8位寄存器为:BH和BL，CH和CL，DH和DL<br>&ensp;&ensp;&ensp;&ensp;一个字节代表8位二进制位，一个字代表两个字节即16位二进制位。当存储一个字节的时候可以将其存储在寄存器的高8位或者低8位，当存储一个字的时候需要将该字的高字节存储在寄存器的高8位，将该字的低字节存储在寄存器的低8位。</p><h2 id="2-2-一些汇编指令和物理地址"><a href="#2-2-一些汇编指令和物理地址" class="headerlink" title="2.2 一些汇编指令和物理地址"></a>2.2 一些汇编指令和物理地址</h2><ol><li>mov ax,12h与MOV AX,12H是一样的效果，汇编指令不区分大小写</li><li><p>若ax和bx当前存储的值都是8226H，当执行add ax,bx的时候其结果应该为1044CH，但是存储结果的寄存器ax为16位而1044CH位20位，所以进位的1不能存储(当可以影响进位标识寄存器)，相加后的ax存储的值为044CH</p></li><li><p>指令add al,93h,执行器al中的数据为C5H，相加之后为158H。但是你会以为在al中存储58H，同时将最高位的1存储在ah中，那么这样理解你就错了，因为当汇编指令使用8位寄存器的时候，是作为独立的寄存器使用与其高位寄存器是无关的。所以ax中的值为0058h.</p></li><li>在进行运算和数据传送的时候。寄存器的位数必须一致，不能出现mov ax,bl或者add bh,ax之类的指令。</li><li>在第一章已经介绍过，计算机内的所有存储区都是通过进行统一进行编制的，其寻址是通过地址总线进行寻址，每个存储区单元都有唯一的地址进行寻址，这个地址我们称为物理地址。</li></ol><h2 id="2-3-16位机和8086进行寻址的方法"><a href="#2-3-16位机和8086进行寻址的方法" class="headerlink" title="2.3 16位机和8086进行寻址的方法"></a>2.3 16位机和8086进行寻址的方法</h2><p>&ensp;&ensp;&ensp;&ensp;16位机代表CPU内部进行运算和寄存的位数为16位，即CPU内部的运算器一次性能进行16位数据的运算，CPU内部的寄存器最大能存储16位数据单元。8086CPU有20条地址总线进行寻址，那么问题来了，CPU在进行寻址的时候地址信息会先存储在CPU内部，但是8086CPU内部最大可以存储16位地址信息，那么怎么来对20位地址进行存储呢。</p><p>&ensp;&ensp;&ensp;&ensp;其解决办法是在内部通过一个加法器将两个16位地址合成20位地址来进行存储区寻址。其示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/2.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;8086CPU内部的寄存器提供两个16位的地址，通过地址加法器合成一个20位的地址，进而通过输入输出电路将20位地址经由地址总线传送到外部存储区进行寻址。<br>&ensp;&ensp;&ensp;&ensp;两个16位地址通过地址加法器合成20位地址的示意图如下：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/3.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;地址加法器计算公式:<font color="#0099ff">20位物理地址=16位段地址<em>16+16位偏移地址</em></font>。这里简单解释一下，对于二进制数据来讲当进行移位操作的时候，左移动一位相当于2, 地址1230H*16即向左移位4位，变为12300H。这时候再加上偏移地址00C8H，结果为123C8H，该地址即为我们合成后的20位物理地址。<br>&ensp;&ensp;&ensp;&ensp;举个例子来说明这一问题,学校，体育馆，图书馆位于一条直线上，学校位于这条线的起点。示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/4.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;如果路人问路，图书馆在哪儿，那么可以有如下两种方式回答:</p><ol><li>从学校直走2826m即可达到图书馆</li><li>从学校直走2000m到达体育馆，再直走826m达到图书馆<br>第一种方法是直接给出图书馆的物理地址(直接地址)，第二种方式是通过体育馆作为中介间隔告诉图书馆的位置。</li></ol><p>&ensp;&ensp;&ensp;&ensp;进一步来想，如果只能通过纸条告诉路人图书馆得位置。但是只有两张可以写三位数的纸条，此时怎么办呢，那么我们可以在第一张纸条上写上200作为段地址，第二张纸条写上826作为偏移地址。那么我们可以通过:段地址200*10+偏移地址826=2826来获知图书馆的位置。</p><h2 id="2-4-段的概念和段寄存器"><a href="#2-4-段的概念和段寄存器" class="headerlink" title="2.4 段的概念和段寄存器"></a>2.4 段的概念和段寄存器</h2><p>&ensp;&ensp;&ensp;&ensp;首先要明确一个概念，内存并没有分段，是CPU在寻址的时候进行分段的，如图所示：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/5.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;我们可以认为10000H-100FFH组成一个段，该段的起始地址为10000H，段地址为1000H,大小为100H,我们也可以认为10000H-1007FH和10080H-100FFH位两个段，两个段的起始地址分别为10000H和10080H，段地址为1000H和1008H，段的大小为80H。如果一个段的偏移地址长度为N位，那么这个段的大小为2^N。</p><p>&ensp;&ensp;&ensp;&ensp;前面讲过CPU内部提供两个16位的地址通过加法器合成20位物理地址，那么提供16位段地址的部件是什么呢，显然是CPU内部的寄存器啦，8086CPU内部有四个段寄存器分别为CS,SS,DS,ES</p><h2 id="2-5-CS和IP"><a href="#2-5-CS和IP" class="headerlink" title="2.5 CS和IP"></a>2.5 CS和IP</h2><p>&ensp;&ensp;&ensp;&ensp;CS和IP作为两个非常重要寄存器，其中CS为代码段寄存器，IP为偏移量，通过公式CS<em>16+IP便可合成CPU当前要读取指令的物理地址。比如当前CS中存储为M，IP存储为N，那么CPU将从M</em>16+N的合成地址中取一条指令执行。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/6.png" alt="汇编语言学习第二章-寄存器"><br>通过CS和IP合成当前指令并取指令的逻辑图如上图所示。主要步骤如下:</p><ol><li>将CS和IP送入地址加法器合成20位物理地址为2000H*16+0000H=20000H</li><li>通过输入输出控制电路将20位物理地址送到地址总线进行寻址</li><li>将寻址到的汇编指令mov ax,0123H对应的机器码0123B8H依次通过数据总线传输到CPU中的指令缓冲器中。</li><li>执行指令，此时IP=IP+执行指令的长度，跳转步骤1.<br><strong><table><tr><td bgcolor="BlueViolet">说明一点，8086CPU加点复位后，CS和IP分别被设置为CS=FFFFH，IP=0000H，即开机后的第一条执行指令地址为FFFF0H。</td></tr></table></strong></li></ol><h2 id="2-6-修改CS和IP，代码段的介绍"><a href="#2-6-修改CS和IP，代码段的介绍" class="headerlink" title="2.6 修改CS和IP，代码段的介绍"></a>2.6 修改CS和IP，代码段的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;CS与IP组成CPU当前执行指令的位置，可以通过修改CS与IP改变CPU执行指令的顺序。然而问题来了，如何改变CS与IP 的值呢，这里要注意的是不能使用MOV指令改变CS和IP寄存器的值，因为8086CPU没有提供这样的功能。其实修改CS与IP的值方式有很多种，这里仅介绍jmp。 jmp 段地址:偏移地址 可改变CS与IP寄存器中的值，从而完成CPU执行指令顺序的跳转。比如jmp 12:34 这里CS=0012H IP=0034H 执行jmp 12:34之后将直接跳转到00154H处取指令执行。若仅仅想改变IP的值不改变CS的值，可以使用jmp 某一个合法寄存器  </p><ul><li>代码段为存放代码的一段内存区域，比如如下一段汇编代码：<pre><code>mov ax,0000add ax,123Hmov bx,axjmp bx</code></pre></li></ul><p>以上一段代码段存储在内存为123B0H-123B9H这段内存区域中，共十个字节，那么我们可以成为这段内存区域为代码段，前面已经介绍过要执行这段代码要把CS：IP指向mov ax，0000的内存区域即可。</p><h2 id="本章完结"><a href="#本章完结" class="headerlink" title="本章完结"></a>本章完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第一章-基础知识</title>
    <link href="http://yoursite.com/2016/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/04/13/汇编语言学习第一章-基础知识/</id>
    <published>2016-04-13T08:26:04.000Z</published>
    <updated>2018-09-17T17:19:57.343Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>&ensp;&ensp;&ensp;&ensp;所谓机器语言则是直接能被机器理解和执行的语言。计算机的核心处理部件为CPU，然而CPU往往只能直接识别机器语言，机器语言为一系列用二进制0,1码代表的机器指令。当然指令集合的差别与具体的CPU有关，AMD与Intel的指令集显然是不同的。然而要直接用二进制的机器语言去描述一段程序或者解决一个问题往往是很困难的。<br>比如说，我们要做这样一个运算s=768+12288-1280:<br><br>&ensp;&ensp;&ensp;&ensp;那么在8086cpu中其用机器语言表述的二进制代码为(机器码):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101110000000000000000011</span></span><br><span class="line"><span class="number">000001010000000000110000</span></span><br><span class="line"><span class="number">001011010000000000000101</span></span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;就这样一个简单的算术运算其机器码就让人头晕目眩，可想而知，如果直接用机器语言进行更为复杂程序的编写，其难度和对视力都是一个极大的考验。    </p><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><p>&ensp;&ensp;&ensp;&ensp;所以为了减轻程序员编程的难度，后来又相继发展了很多语言，比如汇编语言，C语言，C++以及java等语言。其中汇编语言属于低级语言，除此之外均为高级语言。汇编语言将机器语言中晦涩难懂的二进制代码用一些指令助记符进行表示，这样大大降低了程序员编写程序的难度。<br><br>&ensp;&ensp;&ensp;&ensp;比如，机器指令1000100111011000表示将寄存器BX的内容送到寄存器AX中，用汇编语言表述即为mov ax,bx 这样的表示方法不仅清晰易懂而且简洁。那么问题来了，计算机是不能识别mov指令的，那么在汇编程序与CPU之间就需要一个转化的工具，将简洁易懂的汇编语言转换为机器可以理解并执行的机器语言。这个转化工具即为汇编编译器。<br><br>&ensp;&ensp;&ensp;&ensp;用汇编语言编写程序的过程如下:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/1.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul><li>汇编指令:对应机器指令的助记符(核心)</li><li>伪指令：由汇编编译器识别，没有对应的机器指令</li><li>其他符号:如+-*/等，由编译器识别，没有对应的机器指令</li></ul><h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>&ensp;&ensp;&ensp;&ensp;CPU要完成一系列规定的操作，需要两个重要的元素，一是指令(做什么操作)，另外一个是数据(对什么做操作) 。计算机中的很多地方都存储有我们需要的处理的数据，比如内存，比如硬盘，比如寄存器。但是这里要注意的是，CPU要取得需要处理的数据需要将硬盘上的传入内存才能拱CPU调用。</p><h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>&ensp;&ensp;&ensp;&ensp;指令和数据都是在内存上的二进制信息，CPU赋予不同的二进制于数据或者指令的意义。例如：内存中二进制信息1000100111011000,计算机可以把它看作大小为89D8H的数据来处理，也可以理解为mov ax,bx.这里我们要明白一个概念就是内存上的指令和数据的区别是又计算机识别的，就其表现形式来说都是二进制代码，无差。</p><h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的信息是按字节存储的，每个字节代表8位二进制位。对于128个存储单元的存储器来说，我们可以认为其容量为128字节。当然大容量的存储器还有以下一些换算关系：</p><pre><code>1KB=1024B 1M=1024KB 1G=1024MB 1TB=1024GB</code></pre><h2 id="1-7-CPU对存储单元的读写"><a href="#1-7-CPU对存储单元的读写" class="headerlink" title="1.7 CPU对存储单元的读写"></a>1.7 CPU对存储单元的读写</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的存储单元都是从零编号，每个存储单元都有自己的编号，我们可以称之为地址。这个地址唯一标识一个存储单元。CPU想要从某个存储单元中读取数据，那么就要通过该地址进行寻址。<br>计算机中包括三类总线：地址总线，数据总线，控制总线。CPU通过这三类总线与外部存储设备进行数据交互和控制。其中地址总线用于传输寻址存储器的地址，数据总线用于从寻址到的存储器进行读写数据，控制总线进行器件的选择和读写命令的控制。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/2.png" alt="汇编语言学习第一章-基础知识"><br>&ensp;&ensp;&ensp;&ensp;图中地址总线传输三号地址进行寻址，控制总线发送内存读取命令对三号地址存储器中的信息进行读取，数据总线将三号地址存储器中的08传送的CPU。<br>对于8086CPU，下面的机器码，能够完成从三号内存地址单元读取数据。<br>机器码:<pre><code>101000010000001100000000</code></pre>  <br>含义：从三号地址内存单元读取数据到寄存器AX<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编指令：<span class="keyword">mov</span> AX,[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了寻址空间的大小，比如16位地址总线，每位地址总线代表高低电平两个状态，那么16为地址总线代表了2^16种状态，2^16=65536byte 即65536/1024=64kB<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/3.png" alt="汇编语言学习第一章-基础知识"><br>上图为对地址为1101000000的内存单元寻址示意。</p><p>##1.9 数据总线<br>&ensp;&ensp;&ensp;&ensp;CPU通过数据总线和外部存储器进行数据传递，数据总线的大小决定了传输的速度，比如8位数据总线一次性可传输8位数据，16位数据总线一次性可传输16位数据。8088CPU数据总线为8位，8086CPU数据总线为16位。<br>举个例子，分别以8位和16位数据总线向内存中写入89D8如图所示:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/4.png" alt="汇编语言学习第一章-基础知识"><br><img src="/2016/04/13/汇编语言学习第一章-基础知识/5.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>&ensp;&ensp;&ensp;&ensp;cpu通过控制总线对外部器件进行控制，有多少根控制总线就可以有多少总控制，比如对内存的读写代表两种控制命令。</p><h2 id="1-11-内存空间概述，主板，接口卡"><a href="#1-11-内存空间概述，主板，接口卡" class="headerlink" title="1.11 内存空间概述，主板，接口卡"></a>1.11 内存空间概述，主板，接口卡</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了内存寻址空间的大小，比如10位地址总线，可寻址2^10=1024byte的地址。每台计算机都有主板，主板上的各种器件(CPU，内存，外围芯片，扩展槽)通过地址总线，控制总线和数据总线链接。在计算机中，CPU不能直接对外部设备进行控制，对外部设备直接控制的是接口卡，接口卡插在扩展槽上，扩展槽与CPU通过总线相连，进而CPU通过对扩展槽上的接口卡控制达到对外设控制的目的。</p><p>##1.12 各类存储器芯片<br>&ensp;&ensp;&ensp;&ensp;存储器包括两大类随机存储器(RAM)和只读存储器(ROM).其中随机存储器用于存储CPU运行所需的程序和数据，不过掉电之后，RAM存储器中的数据和程序会丢失。只读存储器只能读取其中的数据不能改写其中的数据。<br>其中RAM包括主板上的RAM，扩展槽上的RAM和接口卡上的RAM(比如显存)<br>另外装有BIOS的ROM，例如主板上的ROM，显卡上的ROM等。<br>计算机中各类存储器的逻辑连接情况。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/6.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-13-内存地址空间"><a href="#1-13-内存地址空间" class="headerlink" title="1.13 内存地址空间"></a>1.13 内存地址空间</h2><p>&ensp;&ensp;&ensp;&ensp;虽然在1.12中介绍了很多存储器，但是他们都是通过地址总线与CPU相连的，另外CPU这些存储器读写的时候都是通过控制总线发送读写命令。很重要的一点是，CPU将对这些存储器统一编址，这样就可以在一个地址空间里对计算机中的所有存储器进行寻址。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/7.png" alt="汇编语言学习第一章-基础知识"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于在函数中返回动态分配的内存</title>
    <link href="http://yoursite.com/2015/08/31/%E5%85%B3%E4%BA%8E%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2015/08/31/关于在函数中返回动态分配的内存/</id>
    <published>2015-08-31T08:50:17.000Z</published>
    <updated>2018-09-17T18:13:10.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.有以下题目:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char* p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们期望的输出是:ThunderDownloader,然而当我们运行此段代码的时候发现，程序崩溃了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们深入分析下不难发现，当我们传入str到GetMemeory()函数中的时候，该函数我们创建了一个临时的指针变量片p，然后将其指向NULL。然后我们为临时指针变量p动态分配内存，注意，当我们在返回的时候整个临时指针变量是释放掉的，因为其内存是在栈内存中分配的。但是我们之前传入的str的内存地址与临时变量的内存地址是不相同的。所以此时str不能获取在函数GetMemmory分配的内存，因此后面的字符串复制和链接操作都将造成程序崩溃。</p><p>我们可以用下面的图形更加生动的这一过程:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/1.jpg" alt="C++"></p><p>假设str本身内存为0x123  临时指针变量p的内存为0x456  动态分配的内存起始地址为0x789当GetMemory函数结束的时候p被释放，而再也无指针指向这块动态分配的内存了。另外str也不可能获取这段动态分配的内存的地址。所以也造成了内存泄露。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我们可以用如下两种方法解决这一问题:</p><p>一种是二级指针:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char** p)</span><br><span class="line">&#123;</span><br><span class="line">    (*p)=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(&amp;str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图为:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/2.png" alt="C++"><br>关于二级指针的方法可以参考如下的流程图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/3.jpg" alt="C++"></p><p>另一种是指针的引用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char*&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/4.png" alt="C++"><br>关于指针引用方法的流程图如下:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/5.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.有以下题目:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcat函数的坑点</title>
    <link href="http://yoursite.com/2015/08/30/strcat%E5%87%BD%E6%95%B0%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>http://yoursite.com/2015/08/30/strcat函数的坑点/</id>
    <published>2015-08-30T13:11:12.000Z</published>
    <updated>2018-09-18T16:37:54.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们先看下面这样一段代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1= <span class="string">"123"</span>;</span><br><span class="line">    char *p2= <span class="string">"ABC"</span>;</span><br><span class="line">    char str[50]= <span class="string">"xyz"</span>;</span><br><span class="line">    strcat(p1,p2);</span><br><span class="line">    strcpy(str+2,p1);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>乍一看，这段代码的原意是将p2链接到p1的后面，p1为123ABC,然后将str字符数组向后移动两个位置，将p1拷贝到从该位置开始之后的内存中。结果为xy123ABC</p><p>然而我们运行一下这段代码发现程序崩溃了，我们调用堆栈发现函数定位在这一行:<br><img src="/2015/08/30/strcat函数的坑点/1.png" alt="C++"></p><p>这是怎么回事</p><p>赶紧再查查strcat函数的用法，发现当链接p1和p2字符串的时候，将链接的字符串一起存入p1中，那么就隐含了这么个意思，就是说P1的大小必须要容得下链接后的字符串。但是本质上是字符串”123”是保存在程序中的常量区，而常量区只能进行读操作不能进行写操作</p><p>那么我们在栈区定义一个较大的数组来保存连接后的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p1[20]=<span class="string">"123"</span>;</span><br></pre></td></tr></table></figure></p><p>现在我们再运行下看看结果:<br><img src="/2015/08/30/strcat函数的坑点/2.png" alt="C++"><br>这下果然正确了</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们先看下面这样一段代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>关于位图边缘的检测定位</title>
    <link href="http://yoursite.com/2015/08/10/%E5%85%B3%E4%BA%8E%E4%BD%8D%E5%9B%BE%E8%BE%B9%E7%BC%98%E7%9A%84%E6%A3%80%E6%B5%8B%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2015/08/10/关于位图边缘的检测定位/</id>
    <published>2015-08-10T02:38:03.000Z</published>
    <updated>2018-09-19T16:16:43.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几天做了一些图像检测定位的工作，虽然老师否定了这一方法。但是还是想把最近的工作总结总结。也许会对以后有所帮助。</p><p>POTDR_室外实验_20140120_160549TwoPoint2.mat此文件为原始数据文件。我们需要将其转化为位图进行分析处理。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">load POTDR_室外实验_20140120_160549TwoPoint2.mat  %加载数据</span><br><span class="line"></span><br><span class="line">Data=data(1:size(data,1),:);  %Data两点扰动的矩阵数据388行*3472列</span><br><span class="line"></span><br><span class="line">ColmStart=100;  %因数据量太大，需要对列数据进行采样。从第100列开始取数据 </span><br><span class="line"></span><br><span class="line">ColmLag=10;     %采样数据间隔,每隔10列采一列</span><br><span class="line"></span><br><span class="line">VAR=[];     %定义一个空向量</span><br><span class="line">    </span><br><span class="line">ColmI=ColmStart:ColmLag:size(Data,2)-mod(size(Data,1),ColmLag)-ColmLag;   %ColmI为具体对3472列中哪些列进行采样绘图为1*331的向量</span><br><span class="line"></span><br><span class="line">NewData=Data(:,ColmI);  %NewData为在原3472行数据中采样抽取出来的145列.388*331(原始采样图像数据)</span><br><span class="line">  </span><br><span class="line">DiffData=diff(NewData,1); %DiffData为对NewData作一阶差分运算的差分矩阵也是145列 388*331</span><br></pre></td></tr></table></figure><p>显示差分灰度图:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(DiffData),title(<span class="string">'差分灰度图'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/2015/08/10/关于位图边缘的检测定位/1.png" alt="图像处理"><br>差分灰度图的边缘：(定位出红线的位置是本文的目标)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I=edge(DiffData,<span class="string">'sobel'</span>,<span class="string">'vertical'</span>);%差分灰度图的边缘</span><br><span class="line">imshow(I),title(<span class="string">'差分灰度的边缘'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/2015/08/10/关于位图边缘的检测定位/2.png" alt="图像处理"></p><p>由于红色边缘并不突出,所以我们需要利用图像膨胀使边缘轮廓清晰.膨胀matlab代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">B=[ 0 1 0  </span><br><span class="line">    1 1 1 </span><br><span class="line">    0 1 0 </span><br><span class="line">     ];</span><br><span class="line"> </span><br><span class="line">  A1=imdilate(I,B);%图像I被结构元素B膨胀</span><br><span class="line">  A2=imdilate(A1,B);</span><br><span class="line">  A3=imdilate(A2,B);</span><br><span class="line">  A4=imdilate(A3,B);</span><br><span class="line">  A5=imdilate(A4,B);</span><br><span class="line">  A6=imdilate(A5,B);</span><br><span class="line">  A7=imdilate(A6,B);</span><br><span class="line">  A8=imdilate(A7,B);</span><br><span class="line">  A9=imdilate(A8,B);</span><br><span class="line">  A10=imdilate(A9,B);</span><br><span class="line">  A11=imdilate(A10,B);</span><br><span class="line">     </span><br><span class="line">  A12=imdilate(A11,B);</span><br><span class="line">  A13=imdilate(A12,B);</span><br><span class="line">  A14=imdilate(A13,B);</span><br><span class="line">  A15=imdilate(A14,B);</span><br><span class="line">     </span><br><span class="line">  A16=imdilate(A15,B);</span><br><span class="line">  A17=imdilate(A16,B);</span><br><span class="line">  A18=imdilate(A17,B);</span><br><span class="line">  A19=imdilate(A18,B);</span><br><span class="line">     </span><br><span class="line">  A20=imdilate(A19,B);</span><br><span class="line">  A21=imdilate(A20,B);</span><br><span class="line">  A22=imdilate(A21,B);</span><br><span class="line">  A23=imdilate(A22,B);</span><br><span class="line">     </span><br><span class="line">  A24=imdilate(A23,B);</span><br><span class="line">  A25=imdilate(A24,B);</span><br><span class="line">  A26=imdilate(A25,B);</span><br><span class="line">  A27=imdilate(A26,B);</span><br><span class="line">     </span><br><span class="line">  A28=imdilate(A27,B);</span><br><span class="line">  A29=imdilate(A28,B);</span><br></pre></td></tr></table></figure></p><p>膨胀29次后的图像(红色边缘逐渐清晰)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(A29);title(<span class="string">'3*3第二十九次膨胀'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/2015/08/10/关于位图边缘的检测定位/3.png" alt="图像处理"></p><p>画出膨胀后的轮廓以便进行最终的红线定位：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LastPerim=bwperim(A29); %对膨胀29次的图像求轮廓</span><br><span class="line">imshow(LastPerim),title(<span class="string">'二十九次膨胀后的轮廓'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/2015/08/10/关于位图边缘的检测定位/4.png" alt="图像处理"></p><p>轮廓逐渐清晰明了。那么接下来我们如何检查出这两条红线的位置呢。<br>其实这里的原理很简单。</p><p>1.我们首先只保留图像中白线列信息。</p><p>比如p5=[17 17 17 17 17 17 17 18 18 18 18 18 18 19 19 19 19 19 19 19 20 20 21 21……. 22 22 23 2324 24 25<br>25 25 25 25 25 26 26 26]<br>表明第17列有7个点，第18列有6个点依次类推</p><p>2.我们还需要了解这样的一个原理.<br>看图如下：<br><img src="/2015/08/10/关于位图边缘的检测定位/5.png" alt="图像处理"></p><p>3.显然根据上图我们不难将x1和x3附近所以的列保留下来.保存至memlocate向量中.<br>matlab代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">p=sparse(LastPerim);%对LastPerim求稀疏矩阵即只保留值为1的元素</span><br><span class="line">  p1=find(p);  %按列索引,即找出稀疏矩阵的按列一维索引</span><br><span class="line">  p2=p1/388  %388为列数,此值为稀疏矩阵中保留位置的列值</span><br><span class="line">  p3=floor(p2)   %对p2进行取整</span><br><span class="line">  p4=p3<span class="string">'   %转置成一维行向量</span></span><br><span class="line"><span class="string">  len=length(p4)-1;</span></span><br><span class="line"><span class="string">  len=len-388; %减去最后一列边缘的388个数据点</span></span><br><span class="line"><span class="string">  calculate=0;</span></span><br><span class="line"><span class="string">  k=1;</span></span><br><span class="line"><span class="string">  p5=p4(:,1:len);</span></span><br><span class="line"><span class="string">%%找出p4中连续五个以上相等的数存储在memlocate中</span></span><br><span class="line"><span class="string">  for i=1:1:len-4</span></span><br><span class="line"><span class="string">      if (p5(i)==p5(i+1)&amp;&amp;p5(i+1)==p5(i+2)&amp;&amp;p5(i+2)==p5(i+3))</span></span><br><span class="line"><span class="string">          calculate=calculate+1;</span></span><br><span class="line"><span class="string">      else</span></span><br><span class="line"><span class="string">          if(calculate&gt;=3)</span></span><br><span class="line"><span class="string">                  memlocate(k) = p5(i);</span></span><br><span class="line"><span class="string">                  k=k+1;</span></span><br><span class="line"><span class="string">                  calculate=0;  </span></span><br><span class="line"><span class="string">          end</span></span><br><span class="line"><span class="string">      end</span></span><br><span class="line"><span class="string">  end</span></span><br></pre></td></tr></table></figure></p><p>memlocate截图如下:其中x1和x3附近总共只有21列保留了下来<br><img src="/2015/08/10/关于位图边缘的检测定位/6.png" alt="图像处理"></p><p>4.而此时我们只需要在memlocate中进行分类即可.我们在这里用简单相邻列的差来区分x1和x3这两个不同的边缘.如果差值等于1则表明是属于同一类。否则属于不同类。这样便把不同类的列位置得到了,定位也随即完成.</p><p>此部分matlab代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%对入侵点进行定位</span><br><span class="line">p=1;</span><br><span class="line">j=0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t=1:1:k-2</span><br><span class="line">    j=j+1;</span><br><span class="line">    <span class="keyword">if</span>((memlocate(t+1)-memlocate(t))&gt;=2)</span><br><span class="line">         fid=fopen(<span class="string">'LocateResult15.txt'</span>,<span class="string">'at+'</span>);</span><br><span class="line">         fprintf(fid,<span class="string">'The %d location is:%d\n'</span>,p,memlocate(t+1-j));</span><br><span class="line">         p=p+1;</span><br><span class="line">         j=0;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>LocateResult.txt截图如下：<br><img src="/2015/08/10/关于位图边缘的检测定位/7.png" alt="图像处理"></p><p>第一边缘列的位置在17列,第二边缘列的位置在254列.定位成功！</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近几天做了一些图像检测定位的工作，虽然老师否定了这一方法。但是还是想把最近的工作总结总结。也许会对以后有所帮助。&lt;/p&gt;
&lt;p&gt;POTDR
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C与C++中的const</title>
    <link href="http://yoursite.com/2015/07/30/C%E4%B8%8EC%E8%89%B9%E4%B8%AD%E7%9A%84const/"/>
    <id>http://yoursite.com/2015/07/30/C与C艹中的const/</id>
    <published>2015-07-30T14:07:54.000Z</published>
    <updated>2018-09-18T16:44:41.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同样，有下面一段代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int i = 0; </span><br><span class="line">    int *j = (int *) &amp;i; </span><br><span class="line">    *j = 1; </span><br><span class="line">    cout&lt;&lt;<span class="string">"i address = 0x"</span>&lt;&lt;hex&lt;&lt;&amp;i&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="string">"j address = 0x"</span>&lt;&lt;hex&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"i value = "</span>&lt;&lt;i&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="string">"j value = "</span>&lt;&lt;*j&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在C++编译器中运行如下:<br><img src="/2015/07/30/C与C艹中的const/1.png" alt="C++"></p><p>我们发现const关键字严格遵守了其关于常量的定义。然而疑问出来了为什么相同的地址会输出不同的值。</p><p>同样的代码我们放入C编译器中运行会发现输出结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i value = 1,j value =1</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是为什么呢？</p><p>以下是我自己的一点理解:</p><ol><li>C语言中const为不可改变的变量，其实质仍然是变量，仍然会在编译期间分配内存，那么我们可以获取该内存并修改该内存处的值。这样虽然不允许直接对const 变量修改，但是间接修改该内存位置的值达到修改该变量的效果。</li><li>C++中const关键字定义的是常量类型，在编译的期间直接确定了其值，比如我们<br>可进行如下操作在C++中 编译是可以通过的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const int size=5;</span><br><span class="line">2 int array[size];</span><br></pre></td></tr></table></figure></li></ol><p>表明在编译的时候size是已经确定了。然而这种情况在C语言的情况下是绝对不可以编译通过的，其实我猜，当我们在c++中定义一个const类型的变量的时候，编译器也是要为其分配内存的，只不过在编译阶段遇到时候直接替换，在运行的时候，该常量的值是直接存在某个寄存器中，这样运行代码中需要用到该值时直接可从寄存器中索取，而非在内存中索取。</p><p>那么，我们可以作这样一种测试，我们把const前面加上volatile关键字防止编译器直接从寄存器中取常量值，而是从内存中取，代码如下:<br><img src="/2015/07/30/C与C艹中的const/2.png" alt="C++"></p><p>我们发现此时，const类型变量i的值是已经被改变了，则证明我猜想的思路也许是对的，又或许编译器用了更复杂的方式处理，但是大概思路应该是这样吧!</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>前面说了那么多无非有以下两点:</p><table><tr><td bgcolor="green">1. C C++中的const变量是都要分配内存的。<br>2. C++只不过在编译的时候直接进行变量替换，同时在运行过程中直接在寄存器中取const变量的值，这是C++编译器优化的结果。<br>3. 而对于C语言而言每次const使用都是直接从内存中取值，这样每次const变量的间接改变都能得到反映。</td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;同样，有下面一段代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C艹对象模型浅析</title>
    <link href="http://yoursite.com/2015/07/28/C%E8%89%B9%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2015/07/28/C艹对象模型浅析/</id>
    <published>2015-07-28T03:39:09.000Z</published>
    <updated>2018-09-17T18:03:54.860Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"><a href="#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。" class="headerlink" title="本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"></a>本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。</h5><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp;&ensp;&ensp;&ensp;就如<strong>《深度探索C++对象模型》</strong>一书中介绍的C++的封装并没有给C++带来过多的开销。然而面向对象的编程方法却给广大的编程者提供了一种更为开阔的编程思路。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;好，我们主要看看前面一句。开销是什么，这里的开销主要指C++类所占内存的空间。首先,我们看这样一个例子，我们定义一个结构体和类，结构体和类中含有相同的数据成员。除此之外再无其他。我们看看这个结构体和类的大小是多少:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/1.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">看来只要数据成员相同,那么就算声明为类,也不会带来额外的内存开销。</td></tr></table></strong></p><p>&ensp;&ensp;&ensp;&ensp;现在我们再看一个例子，我们让类B更加复杂一下，我们添加一个静态成员变量和，一个静态成员函数，一个非静态成员函数，一个虚函数:我们再看看这个例子的结果将是什么样的结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">    static int d;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static void fun1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a static fun1."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void fun2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is ordinary fun2."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void fun3()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a virtual fun3."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/2.jpg" alt="C++"><br>在这里我们增加了一个静态数据成员d，一个静态成员函数fun1，非静态的成员函数fun2一个虚函数fun3.不难发现就类的代码规模来说，的确增加了不少，然而结果仅仅比之前增加了四个字节的开销。<table><tr><td bgcolor="red">《深度探索C++对象模型》中有这样一句话说C++封装所带来的开销主要来源于虚函数。</td></tr></table></p><p>那么我们可以先看看结构体A的内存分布:可以产生结构体A的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *a;</span><br><span class="line">a=new A;</span><br></pre></td></tr></table></figure></p><p>对象a的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/3.jpg" alt="C++"><br>显然a中有三个整型数据元素a,b,c刚好12个字节</p><p>现在我们看看类B的内存分布</p><p>可以产生类B的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B *b;</span><br><span class="line">b=new B;</span><br></pre></td></tr></table></figure></p><p>对象B的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/4.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">可以看到尽管类B封装的很多的内容，但是较之A而言仅仅多了一个__vfptr，我们不禁回忆起前面的一句话，C++的封装的开销主要来自于虚函数。其实如果对C++有一定了解的同学都不难猜出，这个ptr其实就是一个虚表指针。正因为这个虚表指针给封装带来了额外的4个字节的开销。</td></tr></table></strong></p><p>那么虚表指针是什么呢，虚表指针其实就是指向虚函数表的一个指针。当一个类中有虚函数的时候，类会自动生成一个指针，该指针保存的是该类中第一个虚函数的地址。所以就算有多个虚函数仍然只需要保存一个虚表指针，然后通过这个指针逐个遍历就可以取得各个虚函数的地址。然而关于虚函数在C++中功能特性我们留待下次一起学习了。<br><img src="/2015/07/28/C艹对象模型浅析/5.jpg" alt="C++"></p><p><br><br>这下一目了然了吧。<br>那么我们可以总结一下影响类的内存开销主要有以下几个方面:</p><table><tr><td bgcolor="BlueViolet">1. 非静态的数据成员<br>2. 虚函数表指针<br>3. 当然既然类也是要考虑内存对齐的。 </td></tr></table><p>还有几点需要注意:<br><strong>1.类的静态数据成员存储在全局变量区，不带来C++内存开销,该静态数据成员属于整个类的不属于具体某个对象，其初始化要在类外进行。<br>2.类的静态成员函数是属于整个类的，不属于某个对象，不会带来内存开销。注意类的静态成员函数中不能调用非静态的成员变量。<br>3.类的普通成员函数始终在程序的代码区中保存一份，不带来内存开销.</strong></p><p>最后再通过一张图片只管展示结构体A和类B的内存布局:<br><img src="/2015/07/28/C艹对象模型浅析/6.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot;&gt;&lt;a href=&quot;#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot; class=&quot;headerlink&quot; title=&quot;本文仅代
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>matlab均值滤波函数的实现</title>
    <link href="http://yoursite.com/2015/07/25/matlab%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2015/07/25/matlab均值滤波函数的实现/</id>
    <published>2015-07-25T03:22:41.000Z</published>
    <updated>2018-09-19T16:07:40.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>均值滤波的原理是对图像以一个区域（方形，圆形）等为模板，对该区域内的数据求平均后赋值给区域的中心，这种滤波方式原理简单，但是在滤波的同时会造成图像模糊。</p><p>本文将尝试对matlab中的filter2()均值函数用自定义函averfilter()实现。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%x是需要滤波的图像,n是模板大小(即n×n)</span><br><span class="line"><span class="keyword">function</span> d=averfilter(x,n)   </span><br><span class="line">a(1:n,1:n)=1;   %a即n×n模板,元素全是1</span><br><span class="line">[height, width]=size(x);   %输入图像是hightxwidth的,且hight&gt;n,width&gt;n</span><br><span class="line">x1=double(x);</span><br><span class="line">x2=x1;</span><br><span class="line"><span class="keyword">for</span> i=1:height-n+1</span><br><span class="line">    <span class="keyword">for</span> j=1:width-n+1</span><br><span class="line">        c=x1(i:i+(n-1),j:j+(n-1)).*a; %取出x1中从(i,j)开始的n行n列元素与模板相乘</span><br><span class="line">        s=sum(sum(c));                 %求c矩阵中各元素之和</span><br><span class="line">        x2(i+(n-1)/2,j+(n-1)/2)=s/(n*n); %将与模板运算后的各元素的均值赋给模板中心位置的元素</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">%未被赋值的元素取原值</span><br><span class="line">d=uint8(x2);</span><br></pre></td></tr></table></figure><p>原始彩色图apple.bmp如下：<br><img src="/2015/07/25/matlab均值滤波函数的实现/1.png" alt="图像处理"><br>转换后的灰度图如下：<br><img src="/2015/07/25/matlab均值滤波函数的实现/2.png" alt="图像处理"><br>加入高斯噪声的灰度图如下：<br><img src="/2015/07/25/matlab均值滤波函数的实现/3.png" alt="图像处理"><br>接下来将比较matlab自带filter2()均值函数和自定义的均值函数averfilter()的滤波效果：</p><p>matlab自带的filter2()测试代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=fspecial(<span class="string">'average'</span>); %生成系统预定义的3X3滤波器</span><br><span class="line">Y=filter2(A,g)/255;           %用生成的滤波器进行滤波,并归一化</span><br><span class="line">figure,imshow(Y),title(<span class="string">'用系统函数进行均值滤波后的结果'</span>); %显示滤波后的图象</span><br></pre></td></tr></table></figure></p><p>结果图：<br><img src="/2015/07/25/matlab均值滤波函数的实现/4.png" alt="图像处理"></p><p>使用自己定义的均值滤波函数averfilter()进行测试:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y2=averfilter(g,n);     %调用自编函数进行均值滤波，n为模板大小</span><br><span class="line">figure,imshow(Y2),title(<span class="string">'用自己的编写的函数进行均值滤波之后的结果'</span>); %显示滤波后的图象</span><br></pre></td></tr></table></figure></p><p>其中自定义均值滤波函数averfilter()的matlab实现代码为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%x是需要滤波的图像,n是模板大小(即n×n)</span><br><span class="line"><span class="keyword">function</span> d=averfilter(x,n)   </span><br><span class="line">a(1:n,1:n)=1;   %a即n×n模板,元素全是1</span><br><span class="line">[height, width]=size(x);   %输入图像是hightxwidth的,且hight&gt;n,width&gt;n</span><br><span class="line">x1=double(x);</span><br><span class="line">x2=x1;</span><br><span class="line"><span class="keyword">for</span> i=1:height-n+1</span><br><span class="line">    <span class="keyword">for</span> j=1:width-n+1</span><br><span class="line">        c=x1(i:i+(n-1),j:j+(n-1)).*a; %取出x1中从(i,j)开始的n行n列元素与模板相乘</span><br><span class="line">        s=sum(sum(c));                 %求c矩阵中各元素之和</span><br><span class="line">        x2(i+(n-1)/2,j+(n-1)/2)=s/(n*n); %将与模板运算后的各元素的均值赋给模板中心位置的元素</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">%未被赋值的元素取原值</span><br><span class="line">d=uint8(x2);</span><br></pre></td></tr></table></figure></p><p>结果图如下：<br><img src="/2015/07/25/matlab均值滤波函数的实现/5.png" alt="图像处理"><br>显然比较filter2()和自定义的averfilter()函数其滤波结果是基本一致的，这说明我们对于均值滤波的matlab实现是成功的。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;均值滤波的原理是对图像以一个区域（方形，圆形）等为模板，对该区域内的数据求平均后赋值给区域的中心，这种滤波方式原理简单，但是在滤波的同时会造
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题3.二维数组中的查找</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%983-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题3-二维数组中的查找/</id>
    <published>2015-07-20T14:35:32.000Z</published>
    <updated>2018-09-17T17:49:58.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断该数组中是否有该整数。</p><p>算法流程如下:<br>比如一个二维数组array:</p><pre><code>1 2 8 92 4 9 124 7 10 136 8 11 15</code></pre><p>1.这个二维数组的左上角是最小的数据,右下角为最大的数，首先判断查找的数是否number&lt;array[0][0]或number&gt;array[1][1]<br>2.当number的大小在数组范围内再开始查找,找数组的右上角或者左下角开始作为比较的基准,当选择左上角的时候，假设我们查找的为number=7<br>3.如果numbe&lt;9，说明number比最后一列都小,再比较无意义<br>这时候数组为:</p><p><pre><code>1 1 2 8<br>2 2 4 9<br>3 4 7 10<br>4 6 8 11<br></code></pre><br>4.我们再取右上角的8作为基准，8大于7,再去掉最后一列</p><p><pre><code>1 2<br>2 4<br>4 7<br>6 8</code></pre><br>5.我们再取右上角的2作为基准，2&lt;7那么，说明第一行再比较无意义，去掉第一行</p><p><pre><code>2 4<br>4 7<br>6 8</code></pre><br>6.我们再把右上角的4作为基准，4&lt;7那么,去掉第一行</p><p><pre><code>4 7<br> 6 8<br></code></pre><br>7.现在我们再比较右上角元素，7==7 恩 找到了。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool Find(int* matrix,int rows,int columns,int number)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(number&gt;matrix[rows*columns-1]||number&lt;matrix[0])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    i=0;</span><br><span class="line">    j=columns-1;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(number&gt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j&lt;0||i&lt;0||i&gt;3||j&gt;3)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点注意:</p><p><strong> <table><tr><td bgcolor="BlueViolet">1.查找的时候有的同学可能会问能不能不从右上角开始作为基准。答案是肯定的，但是只能从右上角和左下角作为基准，为什么？因为我们选择的基准必须在某个维度上是最大的在某个维度上是最小的，不然我们就不能根据比较的结果决定是否去掉一行或者去掉一列<br>2.查找的结束条件是，当我们的右上角元素索引值只要有一个维度的索引值不在二维数组的正常索引范围内就说明需要查找的元素不在这个数组中。<br><br>尤其是第一点,希望读者好好理解。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题2.实例Singleton模式</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%982-%E5%AE%9E%E4%BE%8BSingleton%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题2-实例Singleton模式/</id>
    <published>2015-07-20T13:16:21.000Z</published>
    <updated>2018-09-17T17:39:31.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个类,我们只能生成该类的一个实例</p><p>这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只能生成一个类的实例。那么我们不难考虑到下面几点:</p><ol><li>不能new多个对象，那么必然该类的构造函数是私有的</li><li>类对象只有一个，那么必然该对象只能有一个私有的静态成员变量，该成员变量为类实例或者类实例的指针。</li><li>但是我们同时还要考虑到如果获取这个唯一对象实例,那么该类必然有一个公有的成员函数来获取这个唯一的类实例然    而由于不允许new对象,那么必须提供一种类操作该接口的方式,很显然就是静态成员函数。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>至此不难写设计出这样一个类:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingle</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    CSingle()  //私有构造函数,禁止new对象实例</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static CSingle *m_pInstance;  //私有静态全局变量,保证唯一性</span><br><span class="line">public:</span><br><span class="line">    static CSingle * GetInstance()  //提供一个共有接口获取该唯一类实例</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance == NULL)</span><br><span class="line">            m_pInstance = new CSingle();</span><br><span class="line">        <span class="built_in">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>那么我们构造这个唯一实例是这样的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSingle *Single=CSingle::GetInstance();//当该唯一实例不存在时,这是唯一获取类实例的方法。</span><br><span class="line">CSingle *Single1=Single-&gt;GetInstance();//当上一步执行后便可用此方法获取唯一类实例</span><br><span class="line">CSingle &amp; Single1=Single-&gt;GetInstance();//当然也可以这样</span><br></pre></td></tr></table></figure></p><p><strong> <table><tr><td bgcolor="BlueViolet">上面的做法对于单线程来说可以表现的很好了，但是对于多线程来说，就可能有问题了。当两个线程同时创建实例的时候，这时候实例不存在，这时候就可能产生两个类实例，于是我们就需要用同步的方法保证创建的时候只有一个线程。线程同步的方法很多，可以是临界区，可以是互斥等。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;设计一个类,我们只能生成该类的一个实例&lt;/p&gt;
&lt;p&gt;这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题1:赋值运算符函数</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%981-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题1-赋值运算符函数/</id>
    <published>2015-07-20T12:37:08.000Z</published>
    <updated>2018-09-17T17:39:08.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CMyString</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CMyString(char *pData=NULL);</span><br><span class="line">    CMyString(const CMyString &amp; str);</span><br><span class="line">    ~CMyString(void);</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    char * m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>首先在解答这道题目之前,先要作一些说明:</p><ol><li><p>任何类都是默认的重载赋值操作符。</p></li><li><p>类一旦被声明并且编译后就会为该类的实例分配内存。</p></li><li><p>如果类的成员变量没有在堆(动态分配)中分配内存，那么无需重载赋值操作符也可。因为这样的赋值只是为每个成员变量赋值而已。</p></li></ol><p>比如:对象A有成员变量int a1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.a1=1;</span><br><span class="line">A b;</span><br><span class="line">b.a1=2; </span><br><span class="line">a=b;</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>当执行到a=b;这一步的时候其实即使我们没有重载赋值操作符,也会调用类A的对象a的默认赋值函数</p><p>至此,对象a中的a1成功赋值为b1即2，没有问题的。</p><p>接下来我们要考虑另外一种情况</p><p>假如类A中有一个指针成员变量int *ptr;该ptr在构造函数中new了一块内存。那么我们重新考虑类A的两个对象a,b。对象a,b分别有一个指针ptr，并且该指针在构造函数中分别new了一块内存我们分别以mema和memb表示。在a的ptr中new的内存mema中的值我们设为1,在b的ptr中new的内存memb中的值我们设为2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;/在构造函数new ptr(mema)</span><br><span class="line">A b;/在构造函数new ptr(memb)</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure></p><p>当我们执行到a=b这一步的时候,我们如果没有重载赋值操作符。那么<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void A::operate = (A b)</span><br><span class="line">&#123;</span><br><span class="line">     this.ptr=b.ptr;5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><table><tr><td bgcolor="">乍看好像也没什么错,是的<br>this.ptr=b.ptr这句是将对象b.ptr的所指向的内推地址memb赋值给了a.ptr所指向的对象。好了问题来了,那么a.ptr所指向的那块内推是分配在堆中的也就所如果我们没有主动释放它是不会自动释放的。然而a.ptr已经指向了memb，这样很明显对象a出现了内存泄露。当然问题还不止于此,现在a.ptr和b.ptr都同时指向了memb.那么如果当对象a或者b结束后必然会释放掉memb，比如说a先结束释放memb，那么b.ptr是不是就成了野指针了呢,如果b先结束,那么a.ptr便成为了野指针,同时对象a还出现了内存泄露.</td></tr></table></strong></p><p>那么你会问为什么之前直接赋值就可以而这里直接赋值就不行呢,这就涉及一个内存管理的问题,分配在堆的内存是需要我们用户自己释放的,而分配在栈的内存是由程序自己管理，程序结束后会自动释放。</p><p>现在明白重载赋值操作符的场景了吧，</p><p>那么还有几点需要说明:</p><ol><li>赋值操作符重载通常形参我们是引用,引用可以减少直接传值带来的构造开销.</li><li>赋值操作符重载通常形参是常量,这是为了防止在赋值过程中操作符右值被修改。</li><li>如果为了连续赋值应该把返回值类型声明为该类型的引用,否则函数的返回值为void,不能连续赋值。</li><li>当然为我们还应该考虑传入的对象是否和被赋值对象是否相等。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>综合以上因素，这道题结果如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::operator = (const CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(this==&amp;str)</span><br><span class="line">        <span class="built_in">return</span> *this;</span><br><span class="line"> </span><br><span class="line">    delete []m_pData;</span><br><span class="line">    m_pData=NULL;</span><br><span class="line"> </span><br><span class="line">    m_pData=new char[strlen(str.m_pData)+1];</span><br><span class="line"> </span><br><span class="line">    strcpy(m_pData,str.m_pData);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如下为类型CMyString的声明，请为该类型添加赋值运算符函数&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>matlab边缘之sobel简单实例</title>
    <link href="http://yoursite.com/2015/07/18/matlab%E8%BE%B9%E7%BC%98%E4%B9%8Bsobel%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2015/07/18/matlab边缘之sobel简单实例/</id>
    <published>2015-07-18T14:10:21.000Z</published>
    <updated>2018-09-19T16:02:52.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近在项目中需要做一些图像边缘检测的工作，但是由于之前没接触过图像处理的相关知识，所以只得在matlab里面对一些图像处理函数挨个挨个的试着用。在用的过程中在慢慢的明白了一些简单的图像处理方法。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">load POTDR_室外实验_20140120_160549TwoPoint2.mat  %加载数据，测试数据</span><br><span class="line"><span class="attribute">Data</span>=data(1:size(data,1),:);  %Data两点扰动的矩阵数据388行<span class="number">*3472</span>列</span><br><span class="line"><span class="attribute">ColmStart</span>=100;  %因数据量太大，需要对列数据进行采样。从第100列开始取数据 </span><br><span class="line"><span class="attribute">ColmLag</span>=10;     %采样数据间隔,每隔10列采一列</span><br><span class="line">    VAR=[];     %定义一个空向量</span><br><span class="line"> <span class="attribute">ColmI</span>=ColmStart:ColmLag:size(Data,2)-mod(size(Data,1),ColmLag)-ColmLag;   %ColmI为具体对3472列中哪些列进行采样绘图为1<span class="number">*331</span>的向量</span><br><span class="line">  <span class="attribute">NewData</span>=Data(:,ColmI);  %NewData为在原3472行数据中采样抽取出来的145列.388<span class="number">*331</span>(原始采样图像数据)</span><br><span class="line">  <span class="attribute">DiffData</span>=diff(NewData,1); %DiffData为对NewData作一阶差分运算的差分矩阵也是145列 388<span class="number">*331</span></span><br><span class="line">  <span class="attribute">IDiffData</span>=abs(DiffData);  %取差分图像数据的绝对值，使得图像中的值都为正</span><br></pre></td></tr></table></figure><p>接下来将画一些图像，让读者有一些直观的印象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imshow(NewData); %显示原始采样图像数据的的灰度图：</span><br><span class="line">``` </span><br><span class="line">![图像处理](matlab边缘之sobel简单实例/1.png)</span><br><span class="line">``` bash</span><br><span class="line">edge(NewData,<span class="string">'sobel'</span>,<span class="string">'vertical'</span>);%原始采样图像数据的灰度图的垂直方向的边缘检测:</span><br></pre></td></tr></table></figure></p><p><img src="/2015/07/18/matlab边缘之sobel简单实例/2.png" alt="图像处理"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(DiffData);%显示差分图像数据的灰度图：</span><br></pre></td></tr></table></figure><p><img src="/2015/07/18/matlab边缘之sobel简单实例/3.png" alt="图像处理"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge(DiffData,<span class="string">'sobel'</span>,<span class="string">'vertical'</span>);%差分图像的垂直边缘检测</span><br></pre></td></tr></table></figure><p><img src="/2015/07/18/matlab边缘之sobel简单实例/4.png" alt="图像处理"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(IDiffData);%差分图像绝对值的灰度图</span><br></pre></td></tr></table></figure><p><img src="/2015/07/18/matlab边缘之sobel简单实例/5.png" alt="图像处理"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edge(IDiffData,<span class="string">'sobel'</span>,<span class="string">'vertical'</span>);%显示差分绝对值的垂直边缘检测</span><br><span class="line">VAR=[VAR var(DiffData,1)];  %^VAR为一个1*331的行向量，其中的每个值为差分矩阵每个列向量的方差，方差越大，代表NewData中列与列之间的数据变化大。 </span><br><span class="line">plot(VAR);hold on;plot(VAR,<span class="string">'r*'</span>); </span><br><span class="line">axis tight;title(<span class="string">'差分后的方差图像'</span>); %二维输出方差向量。并描出每隔方差向量点。一列一个点</span><br></pre></td></tr></table></figure></p><p><img src="/2015/07/18/matlab边缘之sobel简单实例/6.png" alt="图像处理"></p><p>至此：边缘检测的一些图像和matlab代码已经呈现出来了。从这些图像中不难看出边缘检测的规律，读者也可以自己对照着进行一些matlab实验。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近在项目中需要做一些图像边缘检测的工作，但是由于之前没接触过图像处理的相关知识，所以只得在matlab里面对一些图像处理函数挨个挨个的试着用
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理之sobel边缘检测</title>
    <link href="http://yoursite.com/2015/07/11/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8Bsobel%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2015/07/11/数字图像处理之sobel边缘检测/</id>
    <published>2015-07-11T07:11:02.000Z</published>
    <updated>2018-09-19T15:56:52.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前两部文章介绍了几种边缘检测算法，和位图的内存结构。如果对前两篇文章已经理解透彻了，那么本文将带你进入数字图像处理的世界。</p><p>本文通过C代码实现基本的sobel边缘检测，包括8个方向和垂直方向</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>头文件TestBmp.h如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned char BYTE;</span><br><span class="line">typedef unsigned short WORD;</span><br><span class="line">typedef unsigned int DWORD;</span><br><span class="line">typedef long LONG;</span><br><span class="line"></span><br><span class="line">//位图文件头定义;</span><br><span class="line">//其中不包含文件类型信息（由于结构体的内存结构决定，</span><br><span class="line">//要是加了的话将不能正确读取文件信息）</span><br><span class="line">typedef struct  tagBITMAPFILEHEADER&#123;</span><br><span class="line">    //WORD bfType;//文件类型，必须是0x424D，即字符“BM”</span><br><span class="line">    DWORD bfSize;//文件大小</span><br><span class="line">    WORD bfReserved1;//保留字</span><br><span class="line">    WORD bfReserved2;//保留字</span><br><span class="line">    DWORD bfOffBits;//从文件头到实际位图数据的偏移字节数</span><br><span class="line">&#125;BITMAPFILEHEADER;</span><br><span class="line"></span><br><span class="line">typedef struct tagBITMAPINFOHEADER&#123;</span><br><span class="line">    DWORD biSize;//信息头大小</span><br><span class="line">    LONG biWidth;//图像宽度</span><br><span class="line">    LONG biHeight;//图像高度</span><br><span class="line">    WORD biPlanes;//位平面数，必须为1</span><br><span class="line">    WORD biBitCount;//每像素位数</span><br><span class="line">    DWORD  biCompression; //压缩类型</span><br><span class="line">    DWORD  biSizeImage; //压缩图像大小字节数</span><br><span class="line">    LONG  biXPelsPerMeter; //水平分辨率</span><br><span class="line">    LONG  biYPelsPerMeter; //垂直分辨率</span><br><span class="line">    DWORD  biClrUsed; //位图实际用到的色彩数</span><br><span class="line">    DWORD  biClrImportant; //本位图中重要的色彩数</span><br><span class="line">&#125;BITMAPINFOHEADER; //位图信息头定义</span><br><span class="line"></span><br><span class="line">typedef struct tagRGBQUAD&#123;</span><br><span class="line">    BYTE rgbBlue; //该颜色的蓝色分量</span><br><span class="line">    BYTE rgbGreen; //该颜色的绿色分量</span><br><span class="line">    BYTE rgbRed; //该颜色的红色分量</span><br><span class="line">    BYTE rgbReserved; //保留值</span><br><span class="line">&#125;RGBQUAD;//调色板定义</span><br></pre></td></tr></table></figure></p><p>源文件TestBmp.cpp如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;math.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;iomanip.h&gt;   </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;windows.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;fstream.h&gt;        </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*以下该模块是完成BMP图像(彩色图像是24bit RGB各8bit)的像素获取，</span><br><span class="line"></span><br><span class="line">                并存在文件名为xiang_su_zhi.txt中  </span><br><span class="line">                                                                    */</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">//用到的全局变量 </span><br><span class="line">  </span><br><span class="line">unsigned char *pBmpBuf;//读入图像数据的指针 </span><br><span class="line">       </span><br><span class="line">int bmpWidth;//图像的宽  </span><br><span class="line"></span><br><span class="line">int bmpHeight;//图像的高 </span><br><span class="line"> </span><br><span class="line">RGBQUAD *pColorTable;//颜色表指针  </span><br><span class="line"></span><br><span class="line">int biBitCount;//图像类型，每像素位数  </span><br><span class="line"></span><br><span class="line">/*static s[8][9]=&#123;</span><br><span class="line">    &#123;-1,-2,-1,0,0,0,1,2,1&#125;,</span><br><span class="line">    &#123;0,-1,-2,1,0,-1,2,1,0&#125;,</span><br><span class="line">    &#123;1,0,-1,2,0,-2,1,0,-1&#125;,</span><br><span class="line">    &#123;2,1,0,1,0,-1,0,-1,-2&#125;,</span><br><span class="line">    &#123;1,2,1,0,0,0,-1,-2,-1&#125;,</span><br><span class="line">    &#123;0,1,2,-1,0,1,-2,-1,0&#125;,</span><br><span class="line">    &#123;-1,0,1,-2,0,2,-1,0,1&#125;,</span><br><span class="line">    &#123;-2,-1,0,-1,0,1,0,1,2&#125;</span><br><span class="line"> &#125;;*/</span><br><span class="line"></span><br><span class="line">static s[9]=&#123;-1,0,1,-2,0,2,-1,0,1&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*                读图像的位图数据、宽、高、颜色表及</span><br><span class="line"></span><br><span class="line">            每像素位数等数据进内存，存放在相应的全局变量中      </span><br><span class="line">                                                                */</span><br><span class="line">/************************************************************************/    </span><br><span class="line"></span><br><span class="line">bool readBmp(char *bmpName)   </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    FILE *fp=fopen(bmpName,<span class="string">"rb"</span>);//二进制只读方式打开指定的图像文件  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fp==0)            //判断文件是否正确打开</span><br><span class="line">        <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //跳过位图文件头结构BITMAPFILEHEADER,使得文件指针指向信息头的开始 </span><br><span class="line">     fseek(fp, sizeof(BITMAPFILEHEADER),0);  </span><br><span class="line"></span><br><span class="line">    //定义位图信息头结构变量，读取位图信息头进内存，存放在变量head中,为了获取图像的宽,高,每像素所占位数 </span><br><span class="line">    BITMAPINFOHEADER head;   </span><br><span class="line">    fread(&amp;head, sizeof(BITMAPINFOHEADER), 1,fp); </span><br><span class="line"></span><br><span class="line">    //获取图像宽、高、每像素所占位数等信息  </span><br><span class="line">    bmpWidth = head.biWidth;  </span><br><span class="line">    bmpHeight = head.biHeight;</span><br><span class="line">    biBitCount = head.biBitCount;</span><br><span class="line"></span><br><span class="line">    //定义变量，计算图像每行像素所占的字节数（必须是4的倍数）    </span><br><span class="line">    int lineByte=(bmpWidth * biBitCount/8+3)/4*4;</span><br><span class="line"></span><br><span class="line">    //灰度图像有颜色表(调色板)，且颜色表表项为256  </span><br><span class="line">    <span class="keyword">if</span>(biBitCount==8) </span><br><span class="line">    &#123;  </span><br><span class="line">        //申请颜色表所需要的空间，读颜色表进内存  </span><br><span class="line">        pColorTable=new RGBQUAD[256];     //申请256种颜色表大小的内存</span><br><span class="line">        fread(pColorTable,sizeof(RGBQUAD),256,fp);  //读取概灰度图的颜色表到pColorTable所指向的内存中</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //申请位图数据所需要的空间，读位图数据进pBmpBuf指向的内存  </span><br><span class="line">    pBmpBuf=new unsigned char[lineByte * bmpHeight];  </span><br><span class="line">    fread(pBmpBuf,1,lineByte * bmpHeight,fp); </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fclose(fp);//关闭文件   </span><br><span class="line">    <span class="built_in">return</span> 1;//读取文件成功 </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*        给定一个图像位图数据、宽、高、颜色表指针及</span><br><span class="line"></span><br><span class="line">        每像素所占的位数等信息,将其写到指定文件中</span><br><span class="line">                                                                      */</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">bool saveBmp(char *bmpName, unsigned char *imgBuf, int width, int height, int biBitCount, RGBQUAD *pColorTable)  </span><br><span class="line">&#123;    </span><br><span class="line">    //如果位图数据指针为0，则没有数据传入，函数返回  </span><br><span class="line">    <span class="keyword">if</span>(!imgBuf)  </span><br><span class="line">        <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">    //颜色表大小，以字节为单位，灰度图像颜色表为1024字节，彩色图像颜色表大小为0        </span><br><span class="line">        int colorTablesize=0;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">                colorTablesize=1024;//一个RGBQUAD(颜色)结构占四个字节,对于8位的灰度图而言,一共有256*4=1024个字节大小的颜色表   </span><br><span class="line"></span><br><span class="line">        //待存储图像数据每行字节数为4的倍数    </span><br><span class="line">        int lineByte=(width * biBitCount/8+3)/4*4; </span><br><span class="line">        </span><br><span class="line">        //以二进制写的方式打开文件   </span><br><span class="line">        FILE *fp=fopen(bmpName,<span class="string">"wb"</span>);  </span><br><span class="line">        <span class="keyword">if</span>(fp==0)  </span><br><span class="line">            <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">        //申请位图文件头结构变量，填写文件头信息  </span><br><span class="line">        BITMAPFILEHEADER fileHead;    </span><br><span class="line">        fileHead.bfType = 0x4D42;//bmp类型  </span><br><span class="line"></span><br><span class="line">        //bfSize是图像文件4个组成部分之和   </span><br><span class="line">        fileHead.bfSize= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + colorTablesize + lineByte*height;  </span><br><span class="line">        fileHead.bfReserved1 = 0;        </span><br><span class="line">        fileHead.bfReserved2 = 0; </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //bfOffBits是图像文件前3个部分所需空间之和        </span><br><span class="line">        fileHead.bfOffBits=54+colorTablesize;  </span><br><span class="line"></span><br><span class="line">        //写文件头进文件  </span><br><span class="line">        fwrite(&amp;fileHead, sizeof(BITMAPFILEHEADER),1, fp);  </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //申请位图信息头结构变量，填写信息头信息  </span><br><span class="line">         BITMAPINFOHEADER head;   </span><br><span class="line">          head.biBitCount=biBitCount;  </span><br><span class="line">          head.biClrImportant=0;  </span><br><span class="line">          head.biClrUsed=0;  </span><br><span class="line">          head.biCompression=0;  </span><br><span class="line">          head.biHeight=height;        </span><br><span class="line">          head.biPlanes=1;  </span><br><span class="line">          head.biSize=40;        </span><br><span class="line">          head.biSizeImage=lineByte*height;  </span><br><span class="line">          head.biWidth=width;  </span><br><span class="line">          head.biXPelsPerMeter=0;        </span><br><span class="line">          head.biYPelsPerMeter=0; </span><br><span class="line">          </span><br><span class="line">        //写位图信息头进内存   </span><br><span class="line">        fwrite(&amp;head, sizeof(BITMAPINFOHEADER),1, fp);    </span><br><span class="line"></span><br><span class="line">        //如果灰度图像，有颜色表，写入文件   </span><br><span class="line">            <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">                fwrite(pColorTable, sizeof(RGBQUAD),256, fp);  </span><br><span class="line"></span><br><span class="line">        //写位图数据进文件  </span><br><span class="line">        fwrite(imgBuf, height*lineByte, 1, fp); </span><br><span class="line">           </span><br><span class="line">        //关闭文件    </span><br><span class="line">        fclose(fp);  </span><br><span class="line">        <span class="built_in">return</span> 1;        </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sobel()</span><br><span class="line">&#123;</span><br><span class="line">    //读入指定BMP文件进内存        </span><br><span class="line">    char readPath[]=<span class="string">"line.bmp"</span>;  </span><br><span class="line">    </span><br><span class="line">    //读取图像信息</span><br><span class="line">    readBmp(readPath); </span><br><span class="line">    </span><br><span class="line">    //输出图像的信息  宽度（单位像素） 高度(单位像素) 每个像素的位数</span><br><span class="line">     cout&lt;&lt;<span class="string">"width="</span>&lt;&lt;bmpWidth&lt;&lt;<span class="string">" height="</span>&lt;&lt;bmpHeight&lt;&lt;<span class="string">" biBitCount="</span>&lt;&lt;biBitCount&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">     //每行字节数(图像数据真正的宽度)  </span><br><span class="line">         int RealWidth=(bmpWidth*biBitCount/8+3)/4*4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         BYTE *pBmpSobel=new BYTE[RealWidth*bmpHeight];</span><br><span class="line">         memset(pBmpSobel,0,RealWidth*bmpHeight);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //////////////////////////////////////////////////////////////////////////</span><br><span class="line">         //八个方向的Sobel边缘检测</span><br><span class="line">    //////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">/*    int d,max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int y=1;y&lt;bmpHeight-1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int x=1;x&lt;RealWidth-1;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=0;</span><br><span class="line">        //////////////////////////////////////////////////////////////////////////</span><br><span class="line">            //分别从八个方向进行Sobel边缘化，上 下 左 右，左上，左下，右上，右下</span><br><span class="line">        //////////////////////////////////////////////////////////////////////////</span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;8;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                d=0;</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line">                //一个sobel算子和一个3*3的像素矩阵相乘得到一个边缘图像像素值</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line">                    <span class="keyword">for</span>(int y2=0;y2&lt;3;y2++)</span><br><span class="line">                        <span class="keyword">for</span>(int x2=0;x2&lt;3;x2++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            d+=s[i][x2+y2*3]*pBmpBuf[(y-1+y2)*RealWidth+x-1+x2];</span><br><span class="line">                        &#125;</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(d&gt;max)max=d;        //取出八个方向上的最大值保存在max中，作为灰度图某像素点的边缘像素值</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;255)max=255;            //将边缘像素值大于255的像素点 像素值置为255（白色）</span><br><span class="line">            pBmpSobel[y*RealWidth+x]=(BYTE)max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //////////////////////////////////////////////////////////////////////////</span><br><span class="line">         //一个方向的Sobel边缘检测(垂直方向)</span><br><span class="line">    //////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">    int d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int y=1;y&lt;bmpHeight-1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int x=1;x&lt;RealWidth-1;x++)</span><br><span class="line">        &#123;</span><br><span class="line">                d=0;</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line">                //一个sobel算子和一个3*3的像素矩阵相乘得到一个边缘图像像素值</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line">                    <span class="keyword">for</span>(int y2=0;y2&lt;3;y2++)</span><br><span class="line">                        <span class="keyword">for</span>(int x2=0;x2&lt;3;x2++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            d+=s[x2+y2*3]*pBmpBuf[(y-1+y2)*RealWidth+x-1+x2];</span><br><span class="line">                        &#125;</span><br><span class="line">            //////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(d&gt;255)d=255;    //将边缘像素值大于255的像素点 像素值置为255（白色）</span><br><span class="line">            <span class="keyword">if</span>(d&lt;0)d=0;        //将边缘像素值大于255的像素点 像素值置为255（黑色）</span><br><span class="line">            pBmpSobel[y*RealWidth+x]=(BYTE)d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将图像数据存盘  </span><br><span class="line">    </span><br><span class="line">    char writePath[]=<span class="string">"f.bmp"</span>;</span><br><span class="line">    </span><br><span class="line">    //图片处理后再存储  </span><br><span class="line">    saveBmp(writePath, pBmpSobel, bmpWidth, bmpHeight, biBitCount, pColorTable); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     //清除缓冲区，pBmpBuf和pColorTable是全局变量，在文件读入时申请的空间  </span><br><span class="line">    delete []pBmpBuf;  </span><br><span class="line">    delete []pBmpSobel;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">             delete []pColorTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*                             主函数                                      */</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">    sobel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>灰度原图line.bmp（垂直方向上）：<br><img src="/2015/07/11/数字图像处理之sobel边缘检测/1.png" alt="图像处理"><br>垂直方向的sobel图为f.bmp：<br><img src="/2015/07/11/数字图像处理之sobel边缘检测/2.png" alt="图像处理"><br>八个方向的灰度原图test.bmp:<br><img src="/2015/07/11/数字图像处理之sobel边缘检测/3.png" alt="图像处理"><br>八个方向的sobel边缘结果图f.bmp:<br><img src="/2015/07/11/数字图像处理之sobel边缘检测/4.png" alt="图像处理"><br>对该灰度原图的垂直sobel：<br><img src="/2015/07/11/数字图像处理之sobel边缘检测/5.png" alt="图像处理"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前两部文章介绍了几种边缘检测算法，和位图的内存结构。如果对前两篇文章已经理解透彻了，那么本文将带你进入数字图像处理的世界。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>继上篇一个demo弄清楚位图在内存中的存储结构</title>
    <link href="http://yoursite.com/2015/07/05/%E7%BB%A7%E4%B8%8A%E7%AF%87%E4%B8%80%E4%B8%AAdemo%E5%BC%84%E6%B8%85%E6%A5%9A%E4%BD%8D%E5%9B%BE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2015/07/05/继上篇一个demo弄清楚位图在内存中的存储结构/</id>
    <published>2015-07-05T10:33:22.000Z</published>
    <updated>2018-09-19T15:52:38.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本来续数字图像处理之位图在计算机中的存储结构一文"><a href="#本来续数字图像处理之位图在计算机中的存储结构一文" class="headerlink" title="本来续数字图像处理之位图在计算机中的存储结构一文"></a>本来续<strong>数字图像处理之位图在计算机中的存储结构</strong>一文</h4><h2 id="功能一览"><a href="#功能一览" class="headerlink" title="功能一览"></a>功能一览</h2><p>该实例实现三个功能：<br>1.读取位图文件数据。<br>2.将位图中像素数据保存到TXT中。<br>3.根据读取的位图函数中的数据保存位图文件。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>头文件BmpNew.h如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned char BYTE;</span><br><span class="line">typedef unsigned short WORD;</span><br><span class="line">typedef unsigned int DWORD;</span><br><span class="line">typedef long LONG;</span><br><span class="line"></span><br><span class="line">//位图文件头定义;</span><br><span class="line">//其中不包含文件类型信息（由于结构体的内存结构决定，</span><br><span class="line">//要是加了的话将不能正确读取文件信息）</span><br><span class="line">typedef struct  tagBITMAPFILEHEADER&#123;</span><br><span class="line">    //WORD bfType;//文件类型，必须是0x424D，即字符“BM”</span><br><span class="line">    DWORD bfSize;//文件大小</span><br><span class="line">    WORD bfReserved1;//保留字</span><br><span class="line">    WORD bfReserved2;//保留字</span><br><span class="line">    DWORD bfOffBits;//从文件头到实际位图数据的偏移字节数</span><br><span class="line">&#125;BITMAPFILEHEADER;</span><br><span class="line"></span><br><span class="line">typedef struct tagBITMAPINFOHEADER&#123;</span><br><span class="line">    DWORD biSize;//信息头大小</span><br><span class="line">    LONG biWidth;//图像宽度</span><br><span class="line">    LONG biHeight;//图像高度</span><br><span class="line">    WORD biPlanes;//位平面数，必须为1</span><br><span class="line">    WORD biBitCount;//每像素位数</span><br><span class="line">    DWORD  biCompression; //压缩类型</span><br><span class="line">    DWORD  biSizeImage; //压缩图像大小字节数</span><br><span class="line">    LONG  biXPelsPerMeter; //水平分辨率</span><br><span class="line">    LONG  biYPelsPerMeter; //垂直分辨率</span><br><span class="line">    DWORD  biClrUsed; //位图实际用到的色彩数</span><br><span class="line">    DWORD  biClrImportant; //本位图中重要的色彩数</span><br><span class="line">&#125;BITMAPINFOHEADER; //位图信息头定义</span><br><span class="line"></span><br><span class="line">typedef struct tagRGBQUAD&#123;</span><br><span class="line">    BYTE rgbBlue; //该颜色的蓝色分量</span><br><span class="line">    BYTE rgbGreen; //该颜色的绿色分量</span><br><span class="line">    BYTE rgbRed; //该颜色的红色分量</span><br><span class="line">    BYTE rgbReserved; //保留值</span><br><span class="line">&#125;RGBQUAD;//调色板定义</span><br></pre></td></tr></table></figure></p><p>源文件BmpNew.cpp如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;math.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;iomanip.h&gt;   </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;windows.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;fstream.h&gt;        </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*以下该模块是完成BMP图像(彩色图像是24bit RGB各8bit)的像素获取，</span><br><span class="line"></span><br><span class="line">                并存在文件名为xiang_su_zhi.txt中  </span><br><span class="line">                                                                    */</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">//用到的全局变量 </span><br><span class="line">  </span><br><span class="line">unsigned char *pBmpBuf;//读入图像数据的指针 </span><br><span class="line">       </span><br><span class="line">int bmpWidth;//图像的宽  </span><br><span class="line"></span><br><span class="line">int bmpHeight;//图像的高 </span><br><span class="line"> </span><br><span class="line">RGBQUAD *pColorTable;//颜色表指针  </span><br><span class="line"></span><br><span class="line">int biBitCount;//图像类型，每像素位数  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*                读图像的位图数据、宽、高、颜色表及</span><br><span class="line"></span><br><span class="line">            每像素位数等数据进内存，存放在相应的全局变量中      </span><br><span class="line">                                                                */</span><br><span class="line">/************************************************************************/    </span><br><span class="line"></span><br><span class="line">bool readBmp(char *bmpName)   </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    FILE *fp=fopen(bmpName,<span class="string">"rb"</span>);//二进制只读方式打开指定的图像文件  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fp==0)            //判断文件是否正确打开</span><br><span class="line">        <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //跳过位图文件头结构BITMAPFILEHEADER,使得文件指针指向信息头的开始 </span><br><span class="line">     fseek(fp, sizeof(BITMAPFILEHEADER),0);  </span><br><span class="line"></span><br><span class="line">    //定义位图信息头结构变量，读取位图信息头进内存，存放在变量head中,为了获取图像的宽,高,每像素所占位数 </span><br><span class="line">    BITMAPINFOHEADER head;   </span><br><span class="line">    fread(&amp;head, sizeof(BITMAPINFOHEADER), 1,fp); </span><br><span class="line"></span><br><span class="line">    //获取图像宽、高、每像素所占位数等信息  </span><br><span class="line">    bmpWidth = head.biWidth;  </span><br><span class="line">    bmpHeight = head.biHeight;</span><br><span class="line">    biBitCount = head.biBitCount;</span><br><span class="line"></span><br><span class="line">    //定义变量，计算图像每行像素所占的字节数（必须是4的倍数）    </span><br><span class="line">    int lineByte=(bmpWidth * biBitCount/8+3)/4*4;</span><br><span class="line"></span><br><span class="line">    //灰度图像有颜色表(调色板)，且颜色表表项为256  </span><br><span class="line">    <span class="keyword">if</span>(biBitCount==8) </span><br><span class="line">    &#123;  </span><br><span class="line">        //申请颜色表所需要的空间，读颜色表进内存  </span><br><span class="line">        pColorTable=new RGBQUAD[256];     //申请256种颜色表大小的内存</span><br><span class="line">        fread(pColorTable,sizeof(RGBQUAD),256,fp);  //读取概灰度图的颜色表到pColorTable所指向的内存中</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //申请位图数据所需要的空间，读位图数据进pBmpBuf指向的内存  </span><br><span class="line">    pBmpBuf=new unsigned char[lineByte * bmpHeight];  </span><br><span class="line">    fread(pBmpBuf,1,lineByte * bmpHeight,fp); </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    fclose(fp);//关闭文件   </span><br><span class="line">    <span class="built_in">return</span> 1;//读取文件成功 </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*        给定一个图像位图数据、宽、高、颜色表指针及</span><br><span class="line"></span><br><span class="line">        每像素所占的位数等信息,将其写到指定文件中</span><br><span class="line">                                                                      */</span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">bool saveBmp(char *bmpName, unsigned char *imgBuf, int width, int height, int biBitCount, RGBQUAD *pColorTable)  </span><br><span class="line">&#123;    </span><br><span class="line">    //如果位图数据指针为0，则没有数据传入，函数返回  </span><br><span class="line">    <span class="keyword">if</span>(!imgBuf)  </span><br><span class="line">        <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">    //颜色表大小，以字节为单位，灰度图像颜色表为1024字节，彩色图像颜色表大小为0        </span><br><span class="line">        int colorTablesize=0;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">                colorTablesize=1024;//一个RGBQUAD(颜色)结构占四个字节,对于8位的灰度图而言,一共有256*4=1024个字节大小的颜色表   </span><br><span class="line"></span><br><span class="line">        //待存储图像数据每行字节数为4的倍数    </span><br><span class="line">        int lineByte=(width * biBitCount/8+3)/4*4; </span><br><span class="line">        </span><br><span class="line">        //以二进制写的方式打开文件   </span><br><span class="line">        FILE *fp=fopen(bmpName,<span class="string">"wb"</span>);  </span><br><span class="line">        <span class="keyword">if</span>(fp==0)  </span><br><span class="line">            <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">        //申请位图文件头结构变量，填写文件头信息  </span><br><span class="line">        BITMAPFILEHEADER fileHead;    </span><br><span class="line">        fileHead.bfType = 0x4D42;//bmp类型  </span><br><span class="line"></span><br><span class="line">        //bfSize是图像文件4个组成部分之和   </span><br><span class="line">        fileHead.bfSize= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + colorTablesize + lineByte*height;  </span><br><span class="line">        fileHead.bfReserved1 = 0;        </span><br><span class="line">        fileHead.bfReserved2 = 0; </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //bfOffBits是图像文件前3个部分所需空间之和        </span><br><span class="line">        fileHead.bfOffBits=54+colorTablesize;  </span><br><span class="line"></span><br><span class="line">        //写文件头进文件  </span><br><span class="line">        fwrite(&amp;fileHead, sizeof(BITMAPFILEHEADER),1, fp);  </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //申请位图信息头结构变量，填写信息头信息  </span><br><span class="line">         BITMAPINFOHEADER head;   </span><br><span class="line">          head.biBitCount=biBitCount;  </span><br><span class="line">          head.biClrImportant=0;  </span><br><span class="line">          head.biClrUsed=0;  </span><br><span class="line">          head.biCompression=0;  </span><br><span class="line">          head.biHeight=height;        </span><br><span class="line">          head.biPlanes=1;  </span><br><span class="line">          head.biSize=40;        </span><br><span class="line">          head.biSizeImage=lineByte*height;  </span><br><span class="line">          head.biWidth=width;  </span><br><span class="line">          head.biXPelsPerMeter=0;        </span><br><span class="line">          head.biYPelsPerMeter=0; </span><br><span class="line">          </span><br><span class="line">        //写位图信息头进内存   </span><br><span class="line">        fwrite(&amp;head, sizeof(BITMAPINFOHEADER),1, fp);    </span><br><span class="line"></span><br><span class="line">        //如果灰度图像，有颜色表，写入文件   </span><br><span class="line">            <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">                fwrite(pColorTable, sizeof(RGBQUAD),256, fp);  </span><br><span class="line"></span><br><span class="line">        //写位图数据进文件  </span><br><span class="line">        fwrite(imgBuf, height*lineByte, 1, fp); </span><br><span class="line">           </span><br><span class="line">        //关闭文件    </span><br><span class="line">        fclose(fp);  </span><br><span class="line">        <span class="built_in">return</span> 1;        </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*                以下为像素的读取函数                                    */</span><br><span class="line"></span><br><span class="line">/************************************************************************/ </span><br><span class="line">void doIt()  </span><br><span class="line">&#123;  </span><br><span class="line">    //读入指定BMP文件进内存        </span><br><span class="line">    char readPath[]=<span class="string">"test.bmp"</span>;  </span><br><span class="line"></span><br><span class="line">    //读取图像信息</span><br><span class="line">    readBmp(readPath); </span><br><span class="line">    </span><br><span class="line">    //输出图像的信息  宽度（单位像素） 高度(单位像素) 每个像素的位数</span><br><span class="line">     cout&lt;&lt;<span class="string">"width="</span>&lt;&lt;bmpWidth&lt;&lt;<span class="string">" height="</span>&lt;&lt;bmpHeight&lt;&lt;<span class="string">" biBitCount="</span>&lt;&lt;biBitCount&lt;&lt;endl;     </span><br><span class="line">     </span><br><span class="line">     //循环变量，图像的坐标  </span><br><span class="line">     //每行字节数  </span><br><span class="line">         int lineByte=(bmpWidth*biBitCount/8+3)/4*4;</span><br><span class="line">         </span><br><span class="line">         //循环变量，针对彩色图像，遍历每像素的三个分量</span><br><span class="line">          int m=0,n=0,count_xiang_su=0;  </span><br><span class="line"></span><br><span class="line">         //将图像左下角1/4部分置成黑色         </span><br><span class="line">         ofstream outfile(<span class="string">"test2.txt"</span>,ios::<span class="keyword">in</span>|ios::trunc); //概txt文档用于保存图像的像素数据，以8*8的矩阵形式输出</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span>(biBitCount==8) //对于灰度图像  </span><br><span class="line">         &#123; </span><br><span class="line"></span><br><span class="line">             /************************************************************************/</span><br><span class="line"></span><br><span class="line">             /*    以下完成图像的分割成8*8小单元，并把像素值存储到指定文本中</span><br><span class="line"></span><br><span class="line">             由于BMP图像的像素数据是从左下角：由左往右，由下往上逐行扫描的*/</span><br><span class="line">             </span><br><span class="line">             /************************************************************************/</span><br><span class="line"></span><br><span class="line">             int L1=0;  </span><br><span class="line">             int hang=63;  </span><br><span class="line">             int lie=0;  </span><br><span class="line">             //int L2=0;  </span><br><span class="line">             //int fen_ge=8; </span><br><span class="line">             </span><br><span class="line">             //-----------------------------------------------------------------</span><br><span class="line">              //最外层<span class="keyword">for</span>循环控制行，一次八行</span><br><span class="line">             //-----------------------------------------------------------------</span><br><span class="line">             <span class="keyword">for</span>(int fen_ge_hang=0;fen_ge_hang&lt;8;fen_ge_hang++)//64*64矩阵行循环  </span><br><span class="line">             &#123;   </span><br><span class="line">                 //-----------------------------------------------</span><br><span class="line">                   //第三层<span class="keyword">for</span>循环按列循环，循环8次8列，至此最后8列被分成了8个8*8矩阵保存在文本文档中</span><br><span class="line">                 //-----------------------------------------------</span><br><span class="line">                 <span class="keyword">for</span>(int fen_ge_lie=0;fen_ge_lie&lt;8;fen_ge_lie++)//64*64列矩阵循环  </span><br><span class="line">                 &#123;   </span><br><span class="line">                     //----------------------------------------------------------------</span><br><span class="line">                       //最内层的两个<span class="keyword">for</span>循环循环从最后一行左边开始读取8*8矩阵到txt文件中</span><br><span class="line">                     //----------------------------------------------------------------  </span><br><span class="line">                     <span class="keyword">for</span>(L1=hang;L1&gt;hang-8;L1--)//8*8矩阵行  </span><br><span class="line">                     &#123;  </span><br><span class="line">                         <span class="keyword">for</span>(int L2=lie;L2&lt;lie+8;L2++)//8*8矩阵列  </span><br><span class="line">                         &#123;  </span><br><span class="line">                             m=*(pBmpBuf+L1*lineByte+L2);</span><br><span class="line">                             </span><br><span class="line">                             outfile&lt;&lt;m&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">                                 </span><br><span class="line">                             count_xiang_su++; </span><br><span class="line">                             </span><br><span class="line">                             <span class="keyword">if</span>(count_xiang_su%8==0)//每8*8矩阵读入文本文件  </span><br><span class="line">                                 outfile&lt;&lt;endl;  </span><br><span class="line">                         &#125;  </span><br><span class="line">                     &#125;</span><br><span class="line">                    //---------------------------------------------</span><br><span class="line"></span><br><span class="line">                     hang=63-fen_ge_hang*8;//64*64矩阵行变换 </span><br><span class="line">                     </span><br><span class="line">                     lie+=8;//64*64矩阵列变换  </span><br><span class="line"></span><br><span class="line">                        //该一行（64）由8个8*8矩阵的行组成  </span><br><span class="line">                 &#125;  </span><br><span class="line">                 hang-=8;//64*64矩阵的列变换</span><br><span class="line">                 </span><br><span class="line">                 lie=0;//64*64矩阵</span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         </span><br><span class="line">         //判断概灰度图像数据是否写入到文本文档中</span><br><span class="line">         <span class="keyword">if</span>(!outfile)  </span><br><span class="line">         &#123;  </span><br><span class="line">             cout&lt;&lt;<span class="string">"open error!"</span>&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">             <span class="built_in">exit</span>(1);  </span><br><span class="line">         &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span>    <span class="keyword">if</span>(biBitCount==24)  </span><br><span class="line">         &#123;</span><br><span class="line">             //彩色图像  </span><br><span class="line">             //-------------------------------------------------------</span><br><span class="line">                //彩色图像的读取是每次读一行从左上角开始读，最外层控制行</span><br><span class="line">                    //第二次<span class="keyword">for</span>控制列,而彩色图每个像素由三个字节的颜色描述</span><br><span class="line">                    //所以第三个<span class="keyword">for</span>是将每个像素的R,G,B分量依次读入到文本</span><br><span class="line">                    //文档中</span><br><span class="line">             //-------------------------------------------------------</span><br><span class="line">             <span class="keyword">for</span>(int i=0;i&lt;bmpHeight;i++)  </span><br><span class="line">             &#123;  </span><br><span class="line">                 <span class="keyword">for</span>(int j=0;j&lt;bmpWidth;j++)  </span><br><span class="line">                 &#123;  </span><br><span class="line">                     <span class="keyword">for</span>(int k=0;k&lt;3;k++)//每像素RGB三个分量分别置0才变成黑色  </span><br><span class="line">                     &#123;   </span><br><span class="line">                         m=*(pBmpBuf+i*lineByte+j*3+k);  </span><br><span class="line"></span><br><span class="line">                         outfile&lt;&lt;m&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line"></span><br><span class="line">                         count_xiang_su++;  </span><br><span class="line"></span><br><span class="line">                         <span class="keyword">if</span>(count_xiang_su%8==0)  </span><br><span class="line">                         &#123;  </span><br><span class="line">                             outfile&lt;&lt;endl;  </span><br><span class="line">                         &#125;                        </span><br><span class="line">                     &#125;  </span><br><span class="line">                     n++;   //计算RGB图的像素</span><br><span class="line">                 &#125;  </span><br><span class="line">                 </span><br><span class="line">             &#125;  </span><br><span class="line">             cout&lt;&lt;<span class="string">"总的像素个素为:"</span>&lt;&lt;n&lt;&lt;endl;  </span><br><span class="line">             cout&lt;&lt;<span class="string">"----------------------------------------------------"</span>&lt;&lt;endl;  </span><br><span class="line">         &#125;  </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         //将图像数据存盘  </span><br><span class="line">         </span><br><span class="line">         char writePath[]=<span class="string">"f.bmp"</span>;</span><br><span class="line"></span><br><span class="line">         //图片处理后再存储  </span><br><span class="line">         saveBmp(writePath, pBmpBuf, bmpWidth, bmpHeight, biBitCount, pColorTable); </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">         //清除缓冲区，pBmpBuf和pColorTable是全局变量，在文件读入时申请的空间  </span><br><span class="line">         delete []pBmpBuf;  </span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span>(biBitCount==8)  </span><br><span class="line">             delete []pColorTable;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line">/*                             主函数                                      */</span><br><span class="line"></span><br><span class="line">/************************************************************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">    doIt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试的test.bmp图片如下：<br><img src="/2015/07/05/继上篇一个demo弄清楚位图在内存中的存储结构/1.png" alt="图像处理"><br>输出保存的图片如下f.tmp：<br><img src="/2015/07/05/继上篇一个demo弄清楚位图在内存中的存储结构/2.png" alt="图像处理"><br>保存的text2.txt截图如下:<br><img src="/2015/07/05/继上篇一个demo弄清楚位图在内存中的存储结构/1.jpg" alt="图像处理"><br>至此，对于一张灰度BMP图像数据的读取，像素数据保存，以及存盘显示就已经完整的实现了</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;本来续数字图像处理之位图在计算机中的存储结构一文&quot;&gt;&lt;a href=&quot;#本来续数字图像处理之位图在计算机中的存储结构一文&quot; class=&quot;headerlink&quot; title=&quot;本来续数字图像处理之位图在计算机中的存储结构一文&quot;&gt;&lt;/a&gt;本来续&lt;strong&gt;数字图
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理之位图在计算机中的存储结构</title>
    <link href="http://yoursite.com/2015/06/30/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%BD%8D%E5%9B%BE%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2015/06/30/数字图像处理之位图在计算机中的存储结构/</id>
    <published>2015-06-30T01:11:03.000Z</published>
    <updated>2018-09-19T15:46:38.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>位图是windows中广泛应用的一种图像格式,其后缀名为.bmp.位图也称为位映射图片.一张位图包含了许许多多的像素点,每个像素点有不同的颜色。由此构成了五彩斑斓的位图图像,然而正是因为由像素点这一基本元素构成，所以在放大图片的时候，人眼便能够区分一个一个的像素点,进而造成位图失真。<br>本文主要介绍位图文件在计算机内存中的存储形式。</p><h2 id="DDB-DIB"><a href="#DDB-DIB" class="headerlink" title="DDB-DIB"></a>DDB-DIB</h2><p>当然这里还要介绍两种位图:DDB,DIB</p><p>DDB(device dependent bitmap),为设备相关位图,这种位图与具体的输出设备相关。在这种位图的结构中没有保存调色板信息。因为在输出显示时是调用系统的调色板。这便是这种位图的局限性。</p><p>DIB(device independent bitmap),为设备无关位图。这种位图与具体的输出无关。其结构中包含四个部分文件头,信息头,调色板,数据区域。所以下文均是介绍这种位图的结构信息。</p><h2 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h2><p>BMP文件由文件头，位图信息头，颜色信息和图像数据四部分组成。<br><img src="/2015/06/30/数字图像处理之位图在计算机中的存储结构/1.png" alt="图像处理"></p><p>在windows wingdi.h中对位图文件头和信息头也作了相应的结构体定义。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//对位图文件头的定义</span><br><span class="line"></span><br><span class="line">typedef struct tagBITMAPFILEHEADER &#123;</span><br><span class="line">        WORD    bfType;                        //位图文件的类型，   必须为BM 对应的16进制为0x4D42</span><br><span class="line">        DWORD   bfSize;                    //位图文件的大小，字节单位</span><br><span class="line">        WORD    bfReserved1;            //位图文件保留字，必须为0</span><br><span class="line">        WORD    bfReserved2;            //位图文件保留字，必须为0</span><br><span class="line">        DWORD   bfOffBits;                //为从文件头到实际图像数据区域的长度，即前三个结构长度之和。</span><br><span class="line">&#125; BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure></p><p>文件头长度固定为14个字节，其中WORD占两个字节，DWORD占四个字节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//对位图信息头的定义</span><br><span class="line"></span><br><span class="line">typedef struct tagBITMAPINFOHEADER&#123;</span><br><span class="line">        DWORD      biSize;                //指定该信息头所占字节数，固定占40个字节</span><br><span class="line">        LONG       biWidth;                //位图的宽度，单位为像素</span><br><span class="line">        LONG       biHeight;                //位图的高度，单位为像素</span><br><span class="line">        WORD       biPlanes;                //目标设备的位面数，必须是1</span><br><span class="line">        WORD       biBitCount;                //每个像素所占的位数</span><br><span class="line">        DWORD      biCompression;        //位图的压缩方式，大多数情况下为0，也可能是BI_RGB</span><br><span class="line">        DWORD      biSizeImage;            //位图的大小，字节单位</span><br><span class="line">        LONG       biXPelsPerMeter;        //水平分辨率，水平每米所占像素个数</span><br><span class="line">        LONG       biYPelsPerMeter;        //垂直分辨率，垂直每米所占像素个数</span><br><span class="line">        DWORD      biClrUsed;            //指出该位图中实际使用的色彩数，若为0，则为2^biBitCount</span><br><span class="line">        DWORD      biClrImportant;        //位图显示中比较重要的颜色数,若为0，则所有颜色都是重要的。</span><br><span class="line">&#125; BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure></p><p>信息头固定长度为40个字节，其中word占两个字节，Dword和Long各占四个字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对颜色表的定义(针对一个像素而定义)</span><br><span class="line"></span><br><span class="line">typedef struct tagRGBQUAD &#123;</span><br><span class="line">        BYTE    rgbBlue;                //该颜色的蓝色分量(0-255)</span><br><span class="line">        BYTE    rgbGreen;                //该颜色的绿色分量(0-255)</span><br><span class="line">        BYTE    rgbRed;                    //该颜色的红色分量(0-255)</span><br><span class="line">        BYTE    rgbReserved;                //保留值</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><p>颜色表中RGBQUAD结构数据的个数有biBitCount来确定:<br>当biBitCount=1,4,8时，分别有2,16,256个表项;<br>当biBitCount=24时，没有颜色表项。<br>位图信息头和颜色表组成位图信息，BITMAPINFO结构定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagBITMAPINFO</span><br><span class="line"> &#123;</span><br><span class="line">   BITMAPINFOHEADER bmiHeader; // 位图信息头</span><br><span class="line">   RGBQUAD bmiColors[1]; // 颜色表</span><br><span class="line">&#125; BITMAPINFO;</span><br></pre></td></tr></table></figure></p><h2 id="位图数据"><a href="#位图数据" class="headerlink" title="位图数据"></a>位图数据</h2><p>位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,扫描行之间是从下到上。</p><p>位图的一个像素值所占的字节数:<br>当biBitCount=1时，8个像素占1个字节;<br>当biBitCount=4时，2个像素占1个字节;<br>当biBitCount=8时，1个像素占1个字节;<br>当biBitCount=24时,1个像素占3个字节;<br>Windows规定一个扫描行所占的字节数必须是<br>4的倍数(即以long为单位),不足的以0填充，<br>一个扫描行所占的字节数计算方法:<br>DataSizePerLine= (biWidth<em> biBitCount+31)/8;<br>//一个扫描行所占的字节数<br>DataSizePerLine= DataSizePerLine/4</em>4;<br>//字节数必须是4的倍数<br>位图数据的大小(不压缩情况下):<br>DataSize= DataSizePerLine* biHeight;</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2015/06/30/数字图像处理之位图在计算机中的存储结构/2.png" alt="图像处理"><br><img src="/2015/06/30/数字图像处理之位图在计算机中的存储结构/3.png" alt="图像处理"><br>上图则是对苹果位图用16位编辑器打开后的存储结构</p><p><strong>前14个字节为位图文件头:</strong><br>0-1字节:42 4D 位图类型BM<br>2-5字节:36 A8 05 00 位图文件大小为实际上应该0x0005A836  总共为370742个字节<br>6-7字节:00 00 保留字 0<br>8-9字节:00 00 保留字 0<br>10-13字节:36 00 00 00位图文件头到数据的偏移,实际上为00 00 00 36,实例偏移为54字节。<br>而文件头14字节，信息头40字节一共54字节。那么颜色表呢?颜色表为0.是的，颜色表为0<br>说明该位图使用24位真彩色，而非索引调色板。故位图信息结构中不包括调色板。</p><p><strong>第14到53这40个字节为位图信息头:</strong><br>14-17字节:28 00 00 00实际上为0x00000028=40标识该信息头结构所占字节数。<br>18-21字节:55 01 00 00实际上为0x00000155=341标识该位图的宽度，单位为像素<br>22-25字节:00 00 01 6A实际上为0x0000016A=362标识该位图的高度，单位为像素<br>26-27字节:01 00实际上为0x0001=1标识目标设备的位面数，强制为1<br>28-29字节:18 00实际上为0x0018=24标识每个像素所占的位数。因为每个像素由RGB三种颜色分量组成，且每个分量占一个字节。而每个像素占24.故该图使用了RGB三种分量的所有组合，为24色真彩色图像<br>30-33字节:00 00 00 00实际上为0，标识位图压缩类型<br>34-37字节:00 A8 05 00实际上为0x0005A800=1448,表示为位图大小，字节为单位<br>38-41字节:C4 0E 00 00实际上为0x00000EC4=3780,表示水平每米所占的像素，即水平分辨率<br>42-45字节:C4 0E 00 00实际上为0x00000EC4=3780,表示垂直每米所占的像素，即垂直分辨率<br>46-49字节:00 00 00 00表示实际使用的颜色数。若为0，则标识为真彩色位图，使用的颜色种类为2^biBitCount<br>50-53字节:00 00 00 00表示位图显示中比较重要的颜色数.若为0，则标识位图中所以的颜色都重要</p><p>而位图图像数据的扫描读取方式则是以从左到右，从下到上的方式进行。而本图又为24位真彩图,故每个像素占三个字节。故每次从最后一行开始从左到右。一次性读三个字节代表一个像素的颜色数据值。</p><p><strong>而对应非24为真色图：</strong></p><p>当biBitCount=16时，两个字节代表一个像素点的颜色数据值。此时存在颜色表，颜色表的种类为2^16种。所以在图像中保存此调色板，在显示位图时调用此调色板的索引值以两个字节代表一个像素点进行显示。</p><p>当biBitCount=8时，一个字节代表一个像素点的颜色数据值。此时存在颜色表，颜色表的种类为2^8=256种。所以在图像中保存此调色板，在显示位图时调用此调色板的索引值以一个字节代表一个像素点进行显示。</p><p>当biBitCount=4时，半个字节代表一个像素点的颜色数据值。此时存在颜色表，颜色表的种类为2^4=128种。所以在图像中保存此调色板，在显示位图时调用此调色板的索引值以半个字节代表一个像素点进行显示，即一个字节表示两个像素点。</p><p>当biBitCount=2时，个字节代表一个像素点的颜色数据值。此时存在颜色表，颜色表的种类为2^2=4种。所以在图像中保存此调色板，在显示位图时调用此调色板的索引值以四分之一个字节代表一个像素点进行显示，即一个字节表示四分之一个像素点。</p><p>当biBitCount=1时，此时为灰度图像。仅黑白两种颜色。一个字节可标识八个像素点。</p><p>所以不能看出颜色深度越神，所保存的调色板越大，存储需要的内存空间越大。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>至此,本文关于设备无关位图的结构已经作了详解的解释，相信读者在看完此文后对位图结构有个大致了解，以至于在后续图像处理的应用中有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;位图是windows中广泛应用的一种图像格式,其后缀名为.bmp.位图也称为位映射图片.一张位图包含了许许多多的像素点,每个像素点有不同的颜
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像处理之边缘检测概述</title>
    <link href="http://yoursite.com/2015/06/26/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2015/06/26/图像处理之边缘检测概述/</id>
    <published>2015-06-26T14:34:08.000Z</published>
    <updated>2018-09-19T15:42:01.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于项目需要，需要做一些边缘检测相关的工作。于是把最近几天的学习内容做一下整理。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>在图像处理和计算机视觉中，边缘检测被广泛使用。其目的在于标识出数字图像中亮点变化明显的点，进而提取出有用的信息。通常情况下我们可以将数字图像表示为二位数组，而概二位数组中每个元素的值则对应着图像各个像素点的灰度值。而边缘检测的根本原理是通过算法将该数组中各个数据邻域内数值变化大的数据元素进行突出显示，而邻域内变化不大的相邻数据元素数据元素进行屏蔽或降低其灰度显示。</p><p>不难看出其边缘检测的很像即为如何找出一种算法来突出这种邻域内的数值变化率。</p><h2 id="边缘检测算法有哪些"><a href="#边缘检测算法有哪些" class="headerlink" title="边缘检测算法有哪些"></a>边缘检测算法有哪些</h2><p>不难看出，边缘检测算法的核心是突出图像中变化率，无论目标与目标，还是目标与背景之间。这于导数的概念离奇的详尽。而对于离散的数字图像中，我们可以使用与求导类比的差分运算来提取图像边缘。基于此原理应用于二维数组中我们可以求出该二维数组的梯度模矩阵。该梯度模矩阵就能比较清楚的表示出图像矩阵的边缘。当然也可以设定一个阈值，当梯度模矩阵中大于阈值的元素则保留，而低于阈值的元素则设为黑度。</p><p>根据梯度模矩阵的不同求法，边缘检测算法可以分为两大类：一阶导数方式（梯度算子）和二阶导数方式<br>而一阶导数方式中几种常见的边缘算子为：Robert,Sobel,PreWitt,kvisch.</p><p>而二阶导数方式常见的有：laplace算子</p><h2 id="边缘检测在图像处理中的一般步骤"><a href="#边缘检测在图像处理中的一般步骤" class="headerlink" title="边缘检测在图像处理中的一般步骤"></a>边缘检测在图像处理中的一般步骤</h2><p><img src="/2015/06/26/图像处理之边缘检测概述/1.png" alt="图像处理"></p><p>其中第一步为滤波，因为图像中存在噪声所以需要先进行滤波。然而数字图像中的噪声大多和边缘信号一样占据高频段，所以如果滤波过于完全很可能连同边缘一起滤除，使得滤波后的图像变得模糊，无法提取有效的边缘。而第二步为我们通常所说的利用边缘算子对边缘进行增强。这一步的结果便可直接当做边缘检测的结果。然而大多数边缘检测还需要进行第三部，设定阈值，对超过阈值的像素点进行突出，对低于阈值的像素点进行屏蔽。</p><h2 id="matlab边缘处理示例"><a href="#matlab边缘处理示例" class="headerlink" title="matlab边缘处理示例"></a>matlab边缘处理示例</h2><p><img src="/2015/06/26/图像处理之边缘检测概述/1.jpg" alt="图像处理"><br><img src="/2015/06/26/图像处理之边缘检测概述/2.jpg" alt="图像处理"><br>程序结果如下：<br><img src="/2015/06/26/图像处理之边缘检测概述/3.jpg" alt="图像处理"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>本文对边缘检测做了简单的概述，也是对近两天学习的总结。通过此文相信大家会对边缘检测有了大概的了解，通过最后一个示例程序使读者对各种边缘处理的印象更加直观。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近由于项目需要，需要做一些边缘检测相关的工作。于是把最近几天的学习内容做一下整理。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议详解卷1--第一章概述--读书笔记</title>
    <link href="http://yoursite.com/2015/06/25/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/</id>
    <published>2015-06-25T02:44:11.000Z</published>
    <updated>2018-09-18T16:56:29.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>百度百科这样说TCP/IP协议:<br>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</p><p>好了我再说说我的理解:<br>先说说OSI(open System Interconnection)互联开放模型,是某某某组织为网络互联提供的一种标准模型。记住只是一种模型而已,它大致是这样的，为了表示原创性,图片我尽量画。<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/1.jpg" alt="TCP/IP协议详解"></p><p>好了，在整个理论的模型基础上,美国某某某组织定义和实现了TCP/IP协议,这个协议就是现在我们网络连接时这样用的协议,记住TCP/IP是个协议族,意思是他有很多协议,好了既然TCP/IP协议是在OSI模型上定义和实现的,那么两者的关系大概是这样:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/2.jpg" alt="TCP/IP协议详解"></p><p>明白了,TCP/IP协议将OSI的前三层融合到一层，而传输层和网络层仍然没有改变,物理层为OSI模型中的数据链路层和物理层这两层的结合。</p><h2 id="TCP-IP各层的意义和各层的意义"><a href="#TCP-IP各层的意义和各层的意义" class="headerlink" title="TCP/IP各层的意义和各层的意义"></a>TCP/IP各层的意义和各层的意义</h2><blockquote><ul><li>首先:应用层是基于底层协议实现的各种协议，是我们用户之间可以接触到的,比如我们远程登录使用的Telnet协议,比如我们发送邮件的SMTP(简单邮件传输协议),比如我们接受邮件用的pop3协议等。</li><li>其次:传输层,书上说传输层是提供端到端的传输，好晦涩，端是啥我不懂，我的理解是传输层通过端口来进行两个主机之间的通信，因为网络层的IP封装已经提供了主机IP的信息，所以传输层只需要提供某IP的端口信息就可以建议与该主机相<br>应的端口进行通信。传输层的协议包括TCP和UDP两种协议,TCP是可靠的,什么是可靠的呢,意思就是使用TCP协议通信会对本次通信的过程进行保证,保证什么,保证信息从源机到目的机，其中用的机制包括建立连接，超时重传等。UDP提供一种不可靠,不可靠是啥意思呢，就是我只管给你传送,至于你收不到收不到也就跟我没毛关系了。</li><li>网络层，主要协议是IP协议，网络层就是网络互联，意思就是什么呢，提供连个主机之间的连接，而这种连接就是基于IP地址的，理论上说只要是连接到Internet网上的每台主机都有一个唯一的IP地址，这样我们就可以用这个唯一IP就可以连接到任何一台电脑，但是理想很丰满，现实很骨感，IPv4是不够用的，那意思就是说每台电脑就不可能划分唯一的IP，但是科学技术是第一生产力，你懂的总有方法解决，比如划分子网，DHCP等用来缓解IP紧张的压力，但是这不是根本的，根本的就是IPv6的推行和发展才能从根本上解决这个问题，提供足够的IP给世界上接入互联网的每个终端。</li><li>最后；物理层也叫网络接口层，这一层的主要目的是提供网络传输的物理细节，这一层包括了很多协议比如最流行的的以太网协议。</li></ul></blockquote><p><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/3.jpg" alt="TCP/IP协议详解"></p><h2 id="IP地址和端口"><a href="#IP地址和端口" class="headerlink" title="IP地址和端口"></a>IP地址和端口</h2><p>IP地址是很重要的，为啥重要，如何没有这玩意儿我们不可能连接到Internet整个庞大的网络，现在用的IPv4提供的IP数量理论上是不够用的，所以呢有某某某组织也在积极的推动IPv6标准IPv4包括32位，通常表示成点分10进制，例如192.168.1.1但是在内存中还是2进制表示,类似<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000011000000000000100000001</span><br></pre></td></tr></table></figure></p><p>其结构类似这样:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/4.jpg" alt="TCP/IP协议详解"></p><p>这就是5类IP地址的结构,<br>我们可以根据网络号转化成点分10进制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A类:0.0.0.0-127.255.255.255</span><br><span class="line">B类:128.0.0.0-191.255.255.255</span><br><span class="line">C类:192.0.0.0-223.255.255.255</span><br><span class="line">D类:234.0.0.0-239.255.255.255</span><br><span class="line">E类:240.0.0.0-247.255.255.255</span><br></pre></td></tr></table></figure></p><p>从A-E网络号站的位数依次增多，主机号占的位数依次减少意思就是啥呢:分配一个A类地址,可以包含2^24个主机 而分配一个C类地址只有2^8(256)个主机,我们还可以直接根据点分10进制的的一个数判断此类IP到底是那类IP地址。当然如果有子网划分就不能只靠判断哪类地址来决定其主机个数，还要结合子网掩码一起来判断。</p><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS Domain Name System 域名解析系统,这是Internet提供的一项服务。当我们上网的时候需要在浏览器键入我们想要浏览的网站，通常我们是键入网站的域名，为什么用域名呢，因为域名好用啊，好记啊，不敢想象如果我们浏览网站总是要通过IP来访问服务器那是多么痛苦。那这个DNS是如何实现的呢，其实DNS解析是通过<br>分布在世界各地的DNS服务器来实现的，每个DNS服务器都会维护一个默认的域名和IP映射表，当我们通过域名访问网站的时候，该域名首先进入DNS服务器，然后在域名IP映射表中进行查询，如果查询到对应的IP，然后通过IP对服务器进行寻址访问，如果没有找到该映射项，那么就会在上一级的DNS服务器中继续查找。</p><p>我们可以通过dos下运行命令来查询本机的DNS服务器IP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure></p><h2 id="关于Tcp-ip通信过程"><a href="#关于Tcp-ip通信过程" class="headerlink" title="关于Tcp/ip通信过程"></a>关于Tcp/ip通信过程</h2><p>那么说到这里，大家就想问TCP/IP协议族如何实现主机之间的通信连接呢这里我只有继续发挥的我绘画功底和想象能力了:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/5.jpg" alt="TCP/IP协议详解"><br>这就是TCP/IP通信过程,其实就是解包和封包的过程，而后面我们具体就要学的就是各个层中有哪些解包封包的方式，这些解包封包方式的差异就形成了各个层中不同的协议。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;百度百科这样说TCP/IP协议:&lt;br&gt;Transmission Control Protocol/Internet Protocol的简写
      
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>wireshark----教你如何抓包</title>
    <link href="http://yoursite.com/2015/06/24/wireshark-%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85/"/>
    <id>http://yoursite.com/2015/06/24/wireshark-教你如何抓包/</id>
    <published>2015-06-24T05:54:02.000Z</published>
    <updated>2018-09-18T17:32:12.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>wireshark是一款强大的抓包工具,走过路过一定不要错过就是了,当你学习TCP/IP协议的时候,学习使用wireshark抓包正是理论联系实际最好的方法,先大概看看协议,然后抓取各种协议包分析每个字节就可以和每层协议的封装<br>相对应。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>抓包之前首先你得安装wireshark是吧.wireshark图标大概是这样。<br><img src="/2015/06/24/wireshark-教你如何抓包/1.jpg" alt="抓包"><br>打开之后大概是这样:<br><img src="/2015/06/24/wireshark-教你如何抓包/2.jpg" alt="抓包"><br>有两张网卡：我用的无线网卡上网的所以我选择下面的:<br><img src="/2015/06/24/wireshark-教你如何抓包/3.jpg" alt="抓包"><br>开始抓包:<br><img src="/2015/06/24/wireshark-教你如何抓包/4.jpg" alt="抓包"><br>抓了好多是吧。但是这些包的意义是什么呢 我们以DNS协议为例,我们开启抓包,访问<a href="http://blog.csdn.net/" target="_blank" rel="noopener">http://blog.csdn.net/</a> 我们知道访问某个网站的时候先会在域名服务器上查询域名的IP</p><p>那么我们会看到有这样一个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/5.jpg" alt="抓包"></p><p>我们在包上点击右键:<br><img src="/2015/06/24/wireshark-教你如何抓包/6.jpg" alt="抓包"><br>Follow UDP Stream会跟踪整个DNS查询过程。</p><p>这时会只会剩下两个包,一个请求查询包,一个response包，这里有两个IP地址:192.168.1.109为我本机的IP地址,202.112.14.151为DNS服务器地址这些信息我们可以通过DOS的ipconfig /all查询<br><img src="/2015/06/24/wireshark-教你如何抓包/7.jpg" alt="抓包"></p><p>我们点开第一个包：<br><img src="/2015/06/24/wireshark-教你如何抓包/8.jpg" alt="抓包"><br>从上到下分别为:可以看出各层对应的协议,User Datagram Protocol表示该DNS查询包使用的是UDP传输协议,所以follow udp stream 懂了吧Domain Name System(query)DNS查询懂了吧我们点击Domain Name System(query)看看16进制大概是这样：<br><img src="/2015/06/24/wireshark-教你如何抓包/9.jpg" alt="抓包"></p><p>我们再看看第一个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/10.jpg" alt="抓包"><br>看到了吧 我们查询的是blog.csdn.net域名<br>再看看第二个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/11.jpg" alt="抓包"><br>看到了吧这是第二个包返回我们的查询IP </p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;wireshark是一款强大的抓包工具,走过路过一定不要错过就是了,当你学习TCP/IP协议的时候,学习使用wireshark抓包正是理论联
      
    
    </summary>
    
      <category term="抓包" scheme="http://yoursite.com/categories/%E6%8A%93%E5%8C%85/"/>
    
    
      <category term="抓包" scheme="http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>TCP快速重传和快速恢复</title>
    <link href="http://yoursite.com/2015/04/21/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2015/04/21/TCP快速重传和快速恢复/</id>
    <published>2015-04-21T05:24:55.000Z</published>
    <updated>2018-09-18T17:01:36.980Z</updated>
    
    <content type="html"><![CDATA[<p>当tcp传送一个分组时会设置一个定时器，如果在规定的实际间隔内没有收到ACK分组，那么则重新传输该分组，但是如果tcp收到三个连续的ACK分组，此时不管是否过超时间隔则重传该分组，具体步骤如下:</p><table><tr><td bgcolor="green">1. 将慢启动阈值ssthresh设为拥塞窗口(cwnd–可理解为发送数据包大小)的一半<br>2. 对于连续三个重复的ACK报文，cwnd依次加1，重发分组<br>3. 当新的ACK分组再次到来的时候，把拥塞窗口的大小设为慢启动阈值的大小<br>4. 进入拥塞避免算法。<br><em> 1,2,3个步骤为快速重传机制，为什么快，因为不需要等定时器时间到再重传</em> 1,2,3,4则是快速恢复机制</td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当tcp传送一个分组时会设置一个定时器，如果在规定的实际间隔内没有收到ACK分组，那么则重新传输该分组，但是如果tcp收到三个连续的ACK分组，此时不管是否过超时间隔则重传该分组，具体步骤如下:&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;green&quot;&gt;1. 将
      
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
</feed>
