<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vpoet&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-30T12:48:22.614Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>vpoet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>勒索木马FireCrypt分析</title>
    <link href="http://yoursite.com/2017/01/05/%E8%83%BDDDoS%E7%9A%84%E5%8B%92%E7%B4%A2%E6%9C%A8%E9%A9%ACFireCrypt%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/</id>
    <published>2017-01-05T03:37:20.000Z</published>
    <updated>2018-09-30T12:48:22.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：<a href="http://www.freebuf.com/articles/system/124618.html" target="_blank" rel="noopener">流氓会武功：这款勒索软件不仅能勒索，还能DDoS</a>。本文进行后续分析。</p><p>经分析，该类样本通过木马生成器自定义生成，运行该样本会对特定文件类型进行AES加密，同时伴随着持续但微弱的DDoS行为(请求特定网站下载文件)。以下是详细的样本分析结果。</p><h2 id="一．样本运行效果"><a href="#一．样本运行效果" class="headerlink" title="一．样本运行效果"></a>一．样本运行效果</h2><p>该样本运行后会加密系统所有盘符下的特定文件类型的文件，加密后会在文件名后加上firecrypt后缀，如下图所示:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/1.png" alt="病毒分析"></p><p>在加密结束后，样本会在桌面生成两个文件分别为xxxx-READ_ME.html和xxxx-filesencrypted.html，xxxx-READ_ME.html是加密后提示给受害用户的解密提示，xxxx-filesencrypted.html是当前受害者电脑所有被加密文件的路径位置信息，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/2.png" alt="病毒分析"><br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/3.png" alt="病毒分析"></p><p>该解密提示界面警告受害者AES密钥的销毁时间，用户需要在密钥销毁之前向特定比特币地址支付500美元赎金以获得AES密钥和解密程序。木马会在每台被加密的机器上生成一个唯一的USER ID用于识别受害机器。</p><p>此外，在文件加密完成后，该木马会创建数个后台线程去固定的某个网站上下载文件到%Temp%目录下，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/4.png" alt="病毒分析"></p><h2 id="二．样本运行流程"><a href="#二．样本运行流程" class="headerlink" title="二．样本运行流程"></a>二．样本运行流程</h2><p>此木马是基于.NET环境开发，依赖.NET Framework 4.0及以上。通过reflector工具可以对木马进行反编译，从而分析出该木马大致运行流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/5.png" alt="病毒分析"></p><h2 id="三．文件加密分析"><a href="#三．文件加密分析" class="headerlink" title="三．文件加密分析"></a>三．文件加密分析</h2><ol><li>样本首先查找受害电脑的所有盘符:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/6.png" alt="病毒分析"></li></ol><p>然后递归遍历所有系统盘符下的所有文件，查找符合如下后缀名的文件，将这些文件的路径信息加入%AppData%\SysWin32\files.txt，加密文件类型如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/7.png" alt="病毒分析"></p><ol start="2"><li>样本会产生一个32个字符的随机字符串，该随机字符串用于后续AES256密钥的生成:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/8.png" alt="病毒分析"><br>其中随机数产生的算法如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/9.png" alt="病毒分析"></li><li>AES256加密流程如下,Encrypt_Fun方法中调用的AES256_Encrypt为加密的主要函数:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/10.png" alt="病毒分析"><br>AES256_Encrypt方法传入带加密的数据和用于加密的密码，此密码再与一些其它的参数生成真正的密钥，具体流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/11.png" alt="病毒分析"><br>至此，文件完整的加密流程已经完结了。该样本在加密每个文件的时候都会产生一个32个字符的随机字符串，然后通过该随机字符串去生成AES加密密钥。这样每次加密的密钥都是不同的，但是在整个加密流程前后并未发现木马通过网络将密钥发送给远端的服务器，一旦用户的电脑被此类木马感染后，即使向作者给出的比特币地址支付赎金，仍然无法获取需要解密的AES密钥。<h2 id="四．木马的DDoS行为"><a href="#四．木马的DDoS行为" class="headerlink" title="四．木马的DDoS行为"></a>四．木马的DDoS行为</h2>当加密行为完成后，样本将在后台创建多个线程:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/12.png" alt="病毒分析"><br>在DownloadThread函数中会持续对www[.]pta[.]gov[.]pk/index[.]php发出请求，并将该页面下载到%temp%目录并存储:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/13.png" alt="病毒分析"><br>当样本感染的机器足够多的时候，这种正常的Url请求就会变成DDoS攻击。<h2 id="五．结束任务管理器"><a href="#五．结束任务管理器" class="headerlink" title="五．结束任务管理器"></a>五．结束任务管理器</h2>除了以上的文件加密和DDoS行为，样本还会创建一个Timer，每隔500ms将“taskmgr”进程杀掉:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/勒索木马FireCrypt分析/14.png" alt="病毒分析"><h2 id="六．木马生成器与变种"><a href="#六．木马生成器与变种" class="headerlink" title="六．木马生成器与变种"></a>六．木马生成器与变种</h2>此类通过生成器生成的木马样本，每次生成的样本的哈希值都会发生变化，可以通过不停变种绕过一些仅凭哈希值进行判定的防护措施。不过，此木马并未采取强烈的混淆手段，大多数情况下仍然可以通过静态特征或者动态行为，识别该类生成器产生的木马。</li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：&lt;a href=&quot;http://www.freebuf.com/arti
      
    
    </summary>
    
      <category term="病毒分析" scheme="http://yoursite.com/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
      <category term="病毒分析" scheme="http://yoursite.com/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第二章-寄存器</title>
    <link href="http://yoursite.com/2016/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/14/汇编语言学习第二章-寄存器/</id>
    <published>2016-04-14T01:56:50.000Z</published>
    <updated>2018-09-17T17:19:37.007Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><p>&ensp;&ensp;&ensp;&ensp;在CPU中，有四种主要的部件。运算器，控制器，寄存器，内部总线。这里的内部总线用于CPU内部进行各种信息的传递，与第一章所讲的控制总线，数据总线，地址总线不同，第一章所描述的总线属于外部总线，作为CPU与外部期间进行信息传递的通路。运算器用于各种信息的处理，寄存器用于信息的处理，控制器用于控制信息的处理。对于利用汇编编程来说，寄存器是主要操作的部件，不同的CPU中寄存器的个数和种类是不同的，8086CPU寄存器个数为14个AX,BX,CX,DX,CS,SS,DS,ES,SI,DI,SP,BP,IP,PSW。</p><h2 id="2-1-通用寄存器和字在寄存器中的存储"><a href="#2-1-通用寄存器和字在寄存器中的存储" class="headerlink" title="2.1 通用寄存器和字在寄存器中的存储"></a>2.1 通用寄存器和字在寄存器中的存储</h2><p>&ensp;&ensp;&ensp;&ensp;8086CPU所有的寄存器均为16位，其中AX,BX,CX,DX这四个寄存器一般作为通用的寄存器使用，用于存储一般的数据。16位寄存器能存储的最大值为2^16=65536，在8086CPU寄存器之前有很多8位的寄存器的CPU，为了和以前在8位寄存器下写的程序相兼容，8086CPU将16位寄存器可分为高八位和低八位的寄存器使用。</p><p>&ensp;&ensp;&ensp;&ensp;以AX寄存器为例，其逻辑结构如下图所示，从做到右依次为高位到低位。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/1.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;比如我们存储一个数据2000H(后缀H,hex代表16进制)，其二进制位10000000000000B(B,binary代表二进制),我们将该数据存入AX中为:</p><pre><code>0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0</code></pre> <p>&ensp;&ensp;&ensp;&ensp;当我们将AX分为两个8位寄存器的时候为:AH(AX High 8-BIT),AL(AX Low-BIT)。<br>&ensp;&ensp;&ensp;&ensp;类似的BX,CX,DX分成8位寄存器为:BH和BL，CH和CL，DH和DL<br>&ensp;&ensp;&ensp;&ensp;一个字节代表8位二进制位，一个字代表两个字节即16位二进制位。当存储一个字节的时候可以将其存储在寄存器的高8位或者低8位，当存储一个字的时候需要将该字的高字节存储在寄存器的高8位，将该字的低字节存储在寄存器的低8位。</p><h2 id="2-2-一些汇编指令和物理地址"><a href="#2-2-一些汇编指令和物理地址" class="headerlink" title="2.2 一些汇编指令和物理地址"></a>2.2 一些汇编指令和物理地址</h2><ol><li>mov ax,12h与MOV AX,12H是一样的效果，汇编指令不区分大小写</li><li><p>若ax和bx当前存储的值都是8226H，当执行add ax,bx的时候其结果应该为1044CH，但是存储结果的寄存器ax为16位而1044CH位20位，所以进位的1不能存储(当可以影响进位标识寄存器)，相加后的ax存储的值为044CH</p></li><li><p>指令add al,93h,执行器al中的数据为C5H，相加之后为158H。但是你会以为在al中存储58H，同时将最高位的1存储在ah中，那么这样理解你就错了，因为当汇编指令使用8位寄存器的时候，是作为独立的寄存器使用与其高位寄存器是无关的。所以ax中的值为0058h.</p></li><li>在进行运算和数据传送的时候。寄存器的位数必须一致，不能出现mov ax,bl或者add bh,ax之类的指令。</li><li>在第一章已经介绍过，计算机内的所有存储区都是通过进行统一进行编制的，其寻址是通过地址总线进行寻址，每个存储区单元都有唯一的地址进行寻址，这个地址我们称为物理地址。</li></ol><h2 id="2-3-16位机和8086进行寻址的方法"><a href="#2-3-16位机和8086进行寻址的方法" class="headerlink" title="2.3 16位机和8086进行寻址的方法"></a>2.3 16位机和8086进行寻址的方法</h2><p>&ensp;&ensp;&ensp;&ensp;16位机代表CPU内部进行运算和寄存的位数为16位，即CPU内部的运算器一次性能进行16位数据的运算，CPU内部的寄存器最大能存储16位数据单元。8086CPU有20条地址总线进行寻址，那么问题来了，CPU在进行寻址的时候地址信息会先存储在CPU内部，但是8086CPU内部最大可以存储16位地址信息，那么怎么来对20位地址进行存储呢。</p><p>&ensp;&ensp;&ensp;&ensp;其解决办法是在内部通过一个加法器将两个16位地址合成20位地址来进行存储区寻址。其示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/2.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;8086CPU内部的寄存器提供两个16位的地址，通过地址加法器合成一个20位的地址，进而通过输入输出电路将20位地址经由地址总线传送到外部存储区进行寻址。<br>&ensp;&ensp;&ensp;&ensp;两个16位地址通过地址加法器合成20位地址的示意图如下：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/3.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;地址加法器计算公式:<font color="#0099ff">20位物理地址=16位段地址<em>16+16位偏移地址</em></font>。这里简单解释一下，对于二进制数据来讲当进行移位操作的时候，左移动一位相当于2, 地址1230H*16即向左移位4位，变为12300H。这时候再加上偏移地址00C8H，结果为123C8H，该地址即为我们合成后的20位物理地址。<br>&ensp;&ensp;&ensp;&ensp;举个例子来说明这一问题,学校，体育馆，图书馆位于一条直线上，学校位于这条线的起点。示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/4.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;如果路人问路，图书馆在哪儿，那么可以有如下两种方式回答:</p><ol><li>从学校直走2826m即可达到图书馆</li><li>从学校直走2000m到达体育馆，再直走826m达到图书馆<br>第一种方法是直接给出图书馆的物理地址(直接地址)，第二种方式是通过体育馆作为中介间隔告诉图书馆的位置。</li></ol><p>&ensp;&ensp;&ensp;&ensp;进一步来想，如果只能通过纸条告诉路人图书馆得位置。但是只有两张可以写三位数的纸条，此时怎么办呢，那么我们可以在第一张纸条上写上200作为段地址，第二张纸条写上826作为偏移地址。那么我们可以通过:段地址200*10+偏移地址826=2826来获知图书馆的位置。</p><h2 id="2-4-段的概念和段寄存器"><a href="#2-4-段的概念和段寄存器" class="headerlink" title="2.4 段的概念和段寄存器"></a>2.4 段的概念和段寄存器</h2><p>&ensp;&ensp;&ensp;&ensp;首先要明确一个概念，内存并没有分段，是CPU在寻址的时候进行分段的，如图所示：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/5.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;我们可以认为10000H-100FFH组成一个段，该段的起始地址为10000H，段地址为1000H,大小为100H,我们也可以认为10000H-1007FH和10080H-100FFH位两个段，两个段的起始地址分别为10000H和10080H，段地址为1000H和1008H，段的大小为80H。如果一个段的偏移地址长度为N位，那么这个段的大小为2^N。</p><p>&ensp;&ensp;&ensp;&ensp;前面讲过CPU内部提供两个16位的地址通过加法器合成20位物理地址，那么提供16位段地址的部件是什么呢，显然是CPU内部的寄存器啦，8086CPU内部有四个段寄存器分别为CS,SS,DS,ES</p><h2 id="2-5-CS和IP"><a href="#2-5-CS和IP" class="headerlink" title="2.5 CS和IP"></a>2.5 CS和IP</h2><p>&ensp;&ensp;&ensp;&ensp;CS和IP作为两个非常重要寄存器，其中CS为代码段寄存器，IP为偏移量，通过公式CS<em>16+IP便可合成CPU当前要读取指令的物理地址。比如当前CS中存储为M，IP存储为N，那么CPU将从M</em>16+N的合成地址中取一条指令执行。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/6.png" alt="汇编语言学习第二章-寄存器"><br>通过CS和IP合成当前指令并取指令的逻辑图如上图所示。主要步骤如下:</p><ol><li>将CS和IP送入地址加法器合成20位物理地址为2000H*16+0000H=20000H</li><li>通过输入输出控制电路将20位物理地址送到地址总线进行寻址</li><li>将寻址到的汇编指令mov ax,0123H对应的机器码0123B8H依次通过数据总线传输到CPU中的指令缓冲器中。</li><li>执行指令，此时IP=IP+执行指令的长度，跳转步骤1.<br><strong><table><tr><td bgcolor="BlueViolet">说明一点，8086CPU加点复位后，CS和IP分别被设置为CS=FFFFH，IP=0000H，即开机后的第一条执行指令地址为FFFF0H。</td></tr></table></strong></li></ol><h2 id="2-6-修改CS和IP，代码段的介绍"><a href="#2-6-修改CS和IP，代码段的介绍" class="headerlink" title="2.6 修改CS和IP，代码段的介绍"></a>2.6 修改CS和IP，代码段的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;CS与IP组成CPU当前执行指令的位置，可以通过修改CS与IP改变CPU执行指令的顺序。然而问题来了，如何改变CS与IP 的值呢，这里要注意的是不能使用MOV指令改变CS和IP寄存器的值，因为8086CPU没有提供这样的功能。其实修改CS与IP的值方式有很多种，这里仅介绍jmp。 jmp 段地址:偏移地址 可改变CS与IP寄存器中的值，从而完成CPU执行指令顺序的跳转。比如jmp 12:34 这里CS=0012H IP=0034H 执行jmp 12:34之后将直接跳转到00154H处取指令执行。若仅仅想改变IP的值不改变CS的值，可以使用jmp 某一个合法寄存器  </p><ul><li>代码段为存放代码的一段内存区域，比如如下一段汇编代码：<pre><code>mov ax,0000add ax,123Hmov bx,axjmp bx</code></pre></li></ul><p>以上一段代码段存储在内存为123B0H-123B9H这段内存区域中，共十个字节，那么我们可以成为这段内存区域为代码段，前面已经介绍过要执行这段代码要把CS：IP指向mov ax，0000的内存区域即可。</p><h2 id="本章完结"><a href="#本章完结" class="headerlink" title="本章完结"></a>本章完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第一章-基础知识</title>
    <link href="http://yoursite.com/2016/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/04/13/汇编语言学习第一章-基础知识/</id>
    <published>2016-04-13T08:26:04.000Z</published>
    <updated>2018-09-17T17:19:57.343Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>&ensp;&ensp;&ensp;&ensp;所谓机器语言则是直接能被机器理解和执行的语言。计算机的核心处理部件为CPU，然而CPU往往只能直接识别机器语言，机器语言为一系列用二进制0,1码代表的机器指令。当然指令集合的差别与具体的CPU有关，AMD与Intel的指令集显然是不同的。然而要直接用二进制的机器语言去描述一段程序或者解决一个问题往往是很困难的。<br>比如说，我们要做这样一个运算s=768+12288-1280:<br><br>&ensp;&ensp;&ensp;&ensp;那么在8086cpu中其用机器语言表述的二进制代码为(机器码):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101110000000000000000011</span></span><br><span class="line"><span class="number">000001010000000000110000</span></span><br><span class="line"><span class="number">001011010000000000000101</span></span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;就这样一个简单的算术运算其机器码就让人头晕目眩，可想而知，如果直接用机器语言进行更为复杂程序的编写，其难度和对视力都是一个极大的考验。    </p><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><p>&ensp;&ensp;&ensp;&ensp;所以为了减轻程序员编程的难度，后来又相继发展了很多语言，比如汇编语言，C语言，C++以及java等语言。其中汇编语言属于低级语言，除此之外均为高级语言。汇编语言将机器语言中晦涩难懂的二进制代码用一些指令助记符进行表示，这样大大降低了程序员编写程序的难度。<br><br>&ensp;&ensp;&ensp;&ensp;比如，机器指令1000100111011000表示将寄存器BX的内容送到寄存器AX中，用汇编语言表述即为mov ax,bx 这样的表示方法不仅清晰易懂而且简洁。那么问题来了，计算机是不能识别mov指令的，那么在汇编程序与CPU之间就需要一个转化的工具，将简洁易懂的汇编语言转换为机器可以理解并执行的机器语言。这个转化工具即为汇编编译器。<br><br>&ensp;&ensp;&ensp;&ensp;用汇编语言编写程序的过程如下:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/1.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul><li>汇编指令:对应机器指令的助记符(核心)</li><li>伪指令：由汇编编译器识别，没有对应的机器指令</li><li>其他符号:如+-*/等，由编译器识别，没有对应的机器指令</li></ul><h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>&ensp;&ensp;&ensp;&ensp;CPU要完成一系列规定的操作，需要两个重要的元素，一是指令(做什么操作)，另外一个是数据(对什么做操作) 。计算机中的很多地方都存储有我们需要的处理的数据，比如内存，比如硬盘，比如寄存器。但是这里要注意的是，CPU要取得需要处理的数据需要将硬盘上的传入内存才能拱CPU调用。</p><h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>&ensp;&ensp;&ensp;&ensp;指令和数据都是在内存上的二进制信息，CPU赋予不同的二进制于数据或者指令的意义。例如：内存中二进制信息1000100111011000,计算机可以把它看作大小为89D8H的数据来处理，也可以理解为mov ax,bx.这里我们要明白一个概念就是内存上的指令和数据的区别是又计算机识别的，就其表现形式来说都是二进制代码，无差。</p><h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的信息是按字节存储的，每个字节代表8位二进制位。对于128个存储单元的存储器来说，我们可以认为其容量为128字节。当然大容量的存储器还有以下一些换算关系：</p><pre><code>1KB=1024B 1M=1024KB 1G=1024MB 1TB=1024GB</code></pre><h2 id="1-7-CPU对存储单元的读写"><a href="#1-7-CPU对存储单元的读写" class="headerlink" title="1.7 CPU对存储单元的读写"></a>1.7 CPU对存储单元的读写</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的存储单元都是从零编号，每个存储单元都有自己的编号，我们可以称之为地址。这个地址唯一标识一个存储单元。CPU想要从某个存储单元中读取数据，那么就要通过该地址进行寻址。<br>计算机中包括三类总线：地址总线，数据总线，控制总线。CPU通过这三类总线与外部存储设备进行数据交互和控制。其中地址总线用于传输寻址存储器的地址，数据总线用于从寻址到的存储器进行读写数据，控制总线进行器件的选择和读写命令的控制。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/2.png" alt="汇编语言学习第一章-基础知识"><br>&ensp;&ensp;&ensp;&ensp;图中地址总线传输三号地址进行寻址，控制总线发送内存读取命令对三号地址存储器中的信息进行读取，数据总线将三号地址存储器中的08传送的CPU。<br>对于8086CPU，下面的机器码，能够完成从三号内存地址单元读取数据。<br>机器码:<pre><code>101000010000001100000000</code></pre>  <br>含义：从三号地址内存单元读取数据到寄存器AX<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编指令：<span class="keyword">mov</span> AX,[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了寻址空间的大小，比如16位地址总线，每位地址总线代表高低电平两个状态，那么16为地址总线代表了2^16种状态，2^16=65536byte 即65536/1024=64kB<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/3.png" alt="汇编语言学习第一章-基础知识"><br>上图为对地址为1101000000的内存单元寻址示意。</p><p>##1.9 数据总线<br>&ensp;&ensp;&ensp;&ensp;CPU通过数据总线和外部存储器进行数据传递，数据总线的大小决定了传输的速度，比如8位数据总线一次性可传输8位数据，16位数据总线一次性可传输16位数据。8088CPU数据总线为8位，8086CPU数据总线为16位。<br>举个例子，分别以8位和16位数据总线向内存中写入89D8如图所示:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/4.png" alt="汇编语言学习第一章-基础知识"><br><img src="/2016/04/13/汇编语言学习第一章-基础知识/5.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>&ensp;&ensp;&ensp;&ensp;cpu通过控制总线对外部器件进行控制，有多少根控制总线就可以有多少总控制，比如对内存的读写代表两种控制命令。</p><h2 id="1-11-内存空间概述，主板，接口卡"><a href="#1-11-内存空间概述，主板，接口卡" class="headerlink" title="1.11 内存空间概述，主板，接口卡"></a>1.11 内存空间概述，主板，接口卡</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了内存寻址空间的大小，比如10位地址总线，可寻址2^10=1024byte的地址。每台计算机都有主板，主板上的各种器件(CPU，内存，外围芯片，扩展槽)通过地址总线，控制总线和数据总线链接。在计算机中，CPU不能直接对外部设备进行控制，对外部设备直接控制的是接口卡，接口卡插在扩展槽上，扩展槽与CPU通过总线相连，进而CPU通过对扩展槽上的接口卡控制达到对外设控制的目的。</p><p>##1.12 各类存储器芯片<br>&ensp;&ensp;&ensp;&ensp;存储器包括两大类随机存储器(RAM)和只读存储器(ROM).其中随机存储器用于存储CPU运行所需的程序和数据，不过掉电之后，RAM存储器中的数据和程序会丢失。只读存储器只能读取其中的数据不能改写其中的数据。<br>其中RAM包括主板上的RAM，扩展槽上的RAM和接口卡上的RAM(比如显存)<br>另外装有BIOS的ROM，例如主板上的ROM，显卡上的ROM等。<br>计算机中各类存储器的逻辑连接情况。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/6.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-13-内存地址空间"><a href="#1-13-内存地址空间" class="headerlink" title="1.13 内存地址空间"></a>1.13 内存地址空间</h2><p>&ensp;&ensp;&ensp;&ensp;虽然在1.12中介绍了很多存储器，但是他们都是通过地址总线与CPU相连的，另外CPU这些存储器读写的时候都是通过控制总线发送读写命令。很重要的一点是，CPU将对这些存储器统一编址，这样就可以在一个地址空间里对计算机中的所有存储器进行寻址。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/7.png" alt="汇编语言学习第一章-基础知识"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题32.从1到n整数中1出现的次数</title>
    <link href="http://yoursite.com/2015/09/14/%E9%9D%A2%E8%AF%95%E9%A2%9832-%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2015/09/14/面试题32-从1到n整数中1出现的次数/</id>
    <published>2015-09-14T07:45:32.000Z</published>
    <updated>2018-09-30T14:35:58.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字中1，10，11和12,1一共出现了5次</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题可以直接变量1到n的n个数然后分别计算每个数中1的个数，然而这种方法是效率很低下的书上给出了一共方法，去找数n各个位置上出现1的规律，在这里我就不再描述具体的规律推倒过程，只是给出这样一个普遍性的规律。</p><p>1.对每一位上面的数字，当该数字等于零时，该位上1的个数等于 高位*该位的位数<br>2.对每一位上面的数字，当该数字等于1时，该位上1的个数等于  高位*该位的位数+低位数加1<br>3.对每一位上面的数字，当该数字等于非0非1时，该位上1的个数等于  （高位+1）*该位的位数</p><p>例如52014<br>该数字十位数为1，那么十位上1的个数=（520）*10+（4+1）=5205<br>该数字百位数为0，那么百位上1的个数=(52)*100=5200<br>该数字千位数为2，那么千位上1的个数=（5+1）*1000=6000<br>该数字个位数为4，那么个位上1的个数=(5201+1)*1=5202<br>该数字万位上为5，那么万位上1的个数=(0+1)*10000=10000</p><p>那么1-52014中所有1的个数为:5205+5200+6000+5202+10000=31607</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int CountOneSum(int Number)</span><br><span class="line">&#123;</span><br><span class="line">    int HighPos=0;</span><br><span class="line">    int LowPos=0;</span><br><span class="line">    int count=0;</span><br><span class="line">    int CurrPos=0;</span><br><span class="line"></span><br><span class="line">    int k=1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Number/k!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        LowPos=Number-(Number/k)*k;</span><br><span class="line">        CurrPos=(Number/k)%10;</span><br><span class="line">        HighPos=Number/(k*10);</span><br><span class="line"></span><br><span class="line">        switch(CurrPos)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> 0:</span><br><span class="line">            count+=(HighPos*k);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 1:</span><br><span class="line">            count+=(HighPos*k+LowPos+1);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        default:</span><br><span class="line">            count+=((HighPos+1)*k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k=k*10;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the number you want to count '1': "</span>;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    int OneCount=0;</span><br><span class="line">    OneCount=CountOneSum(num);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The Count of '1' is: "</span>&lt;&lt;OneCount&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/09/14/面试题32-从1到n整数中1出现的次数/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字中1，10，11和12,
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题31.连续子数组的最大和</title>
    <link href="http://yoursite.com/2015/09/13/%E9%9D%A2%E8%AF%95%E9%A2%9831-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://yoursite.com/2015/09/13/面试题31-连续子数组的最大和/</id>
    <published>2015-09-13T09:03:32.000Z</published>
    <updated>2018-09-30T14:32:15.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一个整型数组，数组里有正数也有负数。数组中一个或者连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度O(n)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题可以把所有子数组全部找出来再求其和的最大值便可以得出，但是这样会导致算法的时间复杂度为0(n^2)，所以有两种方法来解决这个问题。</p><p>方法1.数组扫描<br>我们扫描一遍数组并且累加数组元素的和，当遇到累加和为负数的时候，我们从数组中下一个元素开始重新累加。直到遍历完成。</p><p>方法2.动态规划的方法<br>有这样一个公式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　  &#123; pdata[i]         <span class="keyword">if</span> f(i-1)&lt;=0</span><br><span class="line"></span><br><span class="line">f(i)&#123; </span><br><span class="line"></span><br><span class="line">    &#123;f(x-i)+pdata[i]   <span class="keyword">if</span> f(i-1)&gt;0</span><br></pre></td></tr></table></figure></p><p>怎么理解呢，f(i)是一个数组，其代表数组中第1-i个子数组的最大和，当f(i-1)为负的时候，此时加上一个pdata[i]会更小所以f(i)=pdata[i]当f(i-1)为正的时候，此时加上一个pdata[i]会更大，所以f(i)=f(i-1)+pdata[i];</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面我们分别实现两种方法:</p><p>第一种扫描法(如果只想找最大的则不必找出最大子数组到底是哪些元素，复杂度0(n))<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int FindSerialMaxSum(int* pData,int nLength)</span><br><span class="line">&#123;</span><br><span class="line">    int CurrSum=0;</span><br><span class="line">    int MaxSum=0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pData==NULL||nLength==0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    int *ChildArray=new int[nLength];</span><br><span class="line">    <span class="keyword">for</span>(int k=0;k&lt;nLength;k++)</span><br><span class="line">        ChildArray[k]=0;</span><br><span class="line"></span><br><span class="line">    int index=0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;nLength;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CurrSum&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            CurrSum=pData[i];</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;nLength;j++)</span><br><span class="line">                ChildArray[j]=0;</span><br><span class="line">            index=0;</span><br><span class="line">            ChildArray[index]=pData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CurrSum+=pData[i];</span><br><span class="line">            index++;</span><br><span class="line">            ChildArray[index]=pData[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CurrSum&gt;MaxSum)</span><br><span class="line">            MaxSum=CurrSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Temp=0;</span><br><span class="line">    cout&lt;&lt;<span class="string">"The Child Array is : "</span>;</span><br><span class="line">    <span class="keyword">for</span>(int l=0;pData[l]!=0;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Temp==MaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Temp+=ChildArray[l];</span><br><span class="line">        cout&lt;&lt;ChildArray[l]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> MaxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc ,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int pdata[]=&#123;1,-2,3,10,-4,7,2,-5&#125;;</span><br><span class="line">    int nLength=8;</span><br><span class="line">    int SerivalSum=FindSerialMaxSum(pdata,nLength);</span><br><span class="line">    <span class="keyword">if</span>(SerivalSum!=0)</span><br><span class="line">        cout&lt;&lt;<span class="string">"The Serial Max Sum = "</span>&lt;&lt;SerivalSum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"Input error!"</span>&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><img src="/2015/09/13/面试题31-连续子数组的最大和/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一个整型数组，数组里有正数也有负数。数组中一个或者连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度O(n)&lt;/
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题30.最小的k个数</title>
    <link href="http://yoursite.com/2015/09/12/%E9%9D%A2%E8%AF%95%E9%A2%9830-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2015/09/12/面试题30-最小的k个数/</id>
    <published>2015-09-12T09:05:32.000Z</published>
    <updated>2018-09-30T14:28:07.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入n个整数，找出其中最小的k个数，例如输4,5,1,6,2,7,3,8 这8个数字，则最小的四个数字为1,2,3,4，</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是典型的TopK问题，剑指Offer提供了两种方法来实现，一种方法是parition方法，一种方法是建立一个大小为k的堆进行topk求解</p><p>这里我们只解释第一种方法:<br>1.首先随机查找数组中一个元素作为一个基准，然后parition一次使得数组左边的元素小于基本，数组右边的元素大于基准。<br>2.此时将再将基准插入到数组适当的位置并返回该位置的索引。<br>3.如果索引index小于k-1则继续在[index+1,end]范围内进行parition，<br>4.如果索引index大于k-1则继续在[start,index-1]范围内进行pariton<br>5.直到index==k-1时候结束</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Partiton(int array[],int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    int i=start;</span><br><span class="line">    int j=end;</span><br><span class="line">    int k=0;</span><br><span class="line">    int base=array[0];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j&amp;&amp;base&lt;=array[j])</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i]=array[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j&amp;&amp;base&gt;array[i])</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j]=array[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[i]=base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindTopK(int array[],int start,int end,int k)</span><br><span class="line">&#123;</span><br><span class="line">    int startindex=start;</span><br><span class="line">    int endindex=end;</span><br><span class="line">    int index=Partiton(array,startindex,endindex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index!=k-1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k-1)</span><br><span class="line">        &#123;</span><br><span class="line">            endindex=index-1;</span><br><span class="line">            index=Partiton(array,startindex,endindex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            startindex=index+1;</span><br><span class="line">            index=Partiton(array,startindex,endindex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int array[]=&#123;4,5,1,6,2,7,3,8&#125;;</span><br><span class="line">    int len=8;</span><br><span class="line">    int Index;</span><br><span class="line">    int k=4;</span><br><span class="line">    Index=FindTopK(array,0,len-1,k);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"The Top K number is: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;Index+1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;array[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：<br><img src="/2015/09/12/面试题30-最小的k个数/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入n个整数，找出其中最小的k个数，例如输4,5,1,6,2,7,3,8 这8个数字，则最小的四个数字为1,2,3,4，&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题29.数组中出现次数超过一半的数字</title>
    <link href="http://yoursite.com/2015/09/11/%E9%9D%A2%E8%AF%95%E9%A2%9829-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2015/09/11/面试题29-数组中出现次数超过一半的数字/</id>
    <published>2015-09-11T07:56:32.000Z</published>
    <updated>2018-09-30T14:25:41.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:数组中有一个数字出现的次数超过数组长度的一半，请找出整个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在整个数组中出现5次，超过数组长度的一半，输出2.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此题的解法有很多种，剑指offer书中提出了两种，一种是Parition的方法，另外一种是计数的方法。</p><p>这里我们用计数的方法来实现一下。试想当我们遍历数组的时候用一个计数器。当遇到相同的数时计数器加1，遇到不同的数计数器减1，然而数组中有数字超过数组长度的一半,则肯定计数器最后的值是大于等于1，所以超过一半的数肯定是使计数器最后一次设为1的数字。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int FindNumberMuchHalf(int array[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==NULL||length&lt;=0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">    int result=array[0];</span><br><span class="line">    int count=1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count==0)</span><br><span class="line">        &#123;</span><br><span class="line">            result=array[i];</span><br><span class="line">            count=1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result==array[i])</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int array[]=&#123;1,2,3,2,2,2,5,4,2&#125;;</span><br><span class="line">    int len=9;</span><br><span class="line">    int ans;</span><br><span class="line">    ans=FindNumberMuchHalf(array,len);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The Ans is "</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/11/面试题29-数组中出现次数超过一半的数字/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:数组中有一个数字出现的次数超过数组长度的一半，请找出整个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题28.字符串的排列</title>
    <link href="http://yoursite.com/2015/09/10/%E9%9D%A2%E8%AF%95%E9%A2%9828-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2015/09/10/面试题28-字符串的排列/</id>
    <published>2015-09-10T07:27:32.000Z</published>
    <updated>2018-09-30T14:22:54.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此题的主要步骤由如下几步:<br>1.求出所有可能出现在第一个位置的字符<br>2.将第一个字符与后面字符分别交换<br>3.将第一个字符后面的字符递归步骤1,2</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void FunOfString(char* Str,char* Begin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Str||!Begin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*Begin==<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;Str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(char* ch=Begin;*ch!=<span class="string">'\0'</span>;ch++)</span><br><span class="line">        &#123;</span><br><span class="line">            char temp;</span><br><span class="line">            temp=*ch;</span><br><span class="line">            *ch=*Begin;</span><br><span class="line">            *Begin=temp;</span><br><span class="line"></span><br><span class="line">            FunOfString(Str,Begin+1);</span><br><span class="line"></span><br><span class="line">            temp=*ch;</span><br><span class="line">            *ch=*Begin;</span><br><span class="line">            *Begin=temp;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char Str[]=<span class="string">"vpoet"</span>;</span><br><span class="line">    FunOfString(Str,Str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/10/面试题28-字符串的排列/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题27.二叉搜索树与双向链表</title>
    <link href="http://yoursite.com/2015/09/09/%E9%9D%A2%E8%AF%95%E9%A2%9827-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2015/09/09/面试题27-二叉搜索树与双向链表/</id>
    <published>2015-09-09T06:48:32.000Z</published>
    <updated>2018-09-30T14:20:13.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一颗二叉搜索树，将该二叉搜索树转换为一个排序的双向链表。要求不能创建任何新的结点，只能调整树种结点指针的指向。比如输入下图的二叉搜索树，则输出转换后的双向排序链表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">    /    \</span><br><span class="line">  6      14</span><br><span class="line"> /  \    /  \</span><br><span class="line">4   8   12  16</span><br></pre></td></tr></table></figure></p><p>转换后的双向排序链表为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4&lt;---&gt;6&lt;---&gt;8&lt;---&gt;10&lt;---&gt;12&lt;---&gt;14&lt;---&gt;16</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先 要明白二叉搜索树是根结点大于左子结点，小于右子结点 然而要让转换后的双向链表基本有序,则应该中序遍历该二叉树遍历的时候将树看成三部分:值为10的根结点，根结点值为6的左子树，根结点值为14的右子树。根据排序链表的定义。值为10的结点将和左子树的最大的结点链接起来，同时该结点还要和右子树最小的结点链接起来。然而对于左子树和右子树，递归上述步骤即可。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int        m_nValue;</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ConvertNode(BinaryTreeNode* pNode,BinaryTreeNode** pLastNodeInlist)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pCurrent = pNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pCurrent-&gt;m_pLeft!=NULL)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pLeft,pLastNodeInlist);</span><br><span class="line"></span><br><span class="line">    pCurrent-&gt;m_pLeft=*pLastNodeInlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pLastNodeInlist!=NULL)</span><br><span class="line">        (*pLastNodeInlist)-&gt;m_pRight=pCurrent;</span><br><span class="line"></span><br><span class="line">    *pLastNodeInlist=pCurrent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pCurrent-&gt;m_pRight!=NULL)</span><br><span class="line">        ConvertNode(pCurrent-&gt;m_pRight,pLastNodeInlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode *pLastNodeInList = NULL;</span><br><span class="line">    ConvertNode(pRootOfTree,&amp;pLastNodeInList);</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *pHeadOfList = pLastNodeInList;</span><br><span class="line">    <span class="keyword">while</span>(pHeadOfList != NULL&amp;&amp;pHeadOfList-&gt;m_pLeft!=NULL)</span><br><span class="line">        pHeadOfList = pHeadOfList-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> pHeadOfList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateTree(BinaryTreeNode** Root)</span><br><span class="line">&#123;</span><br><span class="line">     int data;</span><br><span class="line">     cin&gt;&gt;data;</span><br><span class="line">     <span class="keyword">if</span>(data==0)</span><br><span class="line">     &#123;</span><br><span class="line">        *Root=NULL;</span><br><span class="line">         <span class="built_in">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         *Root=(BinaryTreeNode*)malloc(sizeof(BinaryTreeNode));</span><br><span class="line">         (*Root)-&gt;m_nValue=data;</span><br><span class="line">         CreateTree(&amp;((*Root)-&gt;m_pLeft));    </span><br><span class="line">         CreateTree(&amp;((*Root)-&gt;m_pRight));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintTreeInOrder(BinaryTreeNode* Root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;Root-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    PrintTreeInOrder(Root-&gt;m_pLeft);</span><br><span class="line">    PrintTreeInOrder(Root-&gt;m_pRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintTheLinkList(BinaryTreeNode *Head)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"从前往后变量该双向链表: "</span>;</span><br><span class="line">    <span class="keyword">while</span>(Head-&gt;m_pRight!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;Head-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        Head=Head-&gt;m_pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;Head-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    BinaryTreeNode *Last=Head;</span><br><span class="line">    cout&lt;&lt;<span class="string">"从后往前变量该双向链表: "</span>;</span><br><span class="line">    <span class="keyword">while</span>(Last!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;Last-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        Last=Last-&gt;m_pLeft;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode* Root;</span><br><span class="line">    CreateTree(&amp;Root);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The InOrderOfTree: "</span>;</span><br><span class="line">    PrintTreeInOrder(Root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    BinaryTreeNode* HeadOfLinkList;</span><br><span class="line">    HeadOfLinkList=Convert(Root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    PrintTheLinkList(HeadOfLinkList);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/09/面试题27-二叉搜索树与双向链表/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一颗二叉搜索树，将该二叉搜索树转换为一个排序的双向链表。要求不能创建任何新的结点，只能调整树种结点指针的指向。比如输入下图的二叉搜
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题26.复杂链表的复制</title>
    <link href="http://yoursite.com/2015/09/07/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9826-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2015/09/07/剑指offer-面试题26-复杂链表的复制/</id>
    <published>2015-09-07T12:09:32.000Z</published>
    <updated>2018-09-30T14:16:34.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:请实现函数ComplexListNode<em> Clone(ComplexListNode</em> pHead),复制一个复杂链表，在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL。<br>结点的C++定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ComplexListNode</span><br><span class="line">&#123;</span><br><span class="line">　　int m_nValue;</span><br><span class="line">　　ComplexListNode* m_pNext;</span><br><span class="line">　　ComplexListNode* m_pSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题以链表:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;3-&gt;5-&gt;7-&gt;9</span><br></pre></td></tr></table></figure></p><p>为例,<br>其中各个元素的Sibling如下:<br>第一个结点的sibling指向结点5<br>第二个结点的sibling指向结点9<br>第三个结点的sibling为NULL<br>第四个结点的sibling为第二个结点<br>第五个结点的sibling为NULL</p><p>此题目的解题步骤分为以下三步:<br>Step 1.将链表中每个结点复制一个链接在其后面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;1-&gt;3-&gt;3-&gt;5-&gt;5-&gt;7-&gt;7-&gt;9-&gt;9</span><br></pre></td></tr></table></figure></p><p>Step 2.解决链表的sibling问题,比如第一个结点的sibling为第三个结点,那么可以遍历链表使<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node-&gt;next-&gt;sibling=Node-&gt;sibling</span><br></pre></td></tr></table></figure></p><p>Step 3.此时将链表的偶数结点取出来即可，取出来即为复制的结点。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ComplexListNode</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue;</span><br><span class="line">    ComplexListNode* m_pNext;</span><br><span class="line">    ComplexListNode* m_pSibling;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ComplexListNode* CreateLinkList()</span><br><span class="line">&#123;</span><br><span class="line">    ComplexListNode* Head;</span><br><span class="line">    Head=new ComplexListNode();</span><br><span class="line">    Head-&gt;m_nValue=1;</span><br><span class="line">    Head-&gt;m_pNext=NULL;</span><br><span class="line">    Head-&gt;m_pSibling=NULL;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* Temp=Head;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* Node2=new ComplexListNode();</span><br><span class="line">    Node2-&gt;m_nValue=3;</span><br><span class="line">    Node2-&gt;m_pNext=NULL;</span><br><span class="line">    Node2-&gt;m_pSibling=NULL;</span><br><span class="line">    ComplexListNode* Node3=new ComplexListNode();</span><br><span class="line">    Node3-&gt;m_nValue=5;</span><br><span class="line">    Node3-&gt;m_pNext=NULL;</span><br><span class="line">    Node3-&gt;m_pSibling=NULL;</span><br><span class="line">    ComplexListNode* Node4=new ComplexListNode();</span><br><span class="line">    Node4-&gt;m_nValue=7;</span><br><span class="line">    Node4-&gt;m_pNext=NULL;</span><br><span class="line">    Node4-&gt;m_pSibling=NULL;</span><br><span class="line">    ComplexListNode* Node5=new ComplexListNode();</span><br><span class="line">    Node5-&gt;m_nValue=9;</span><br><span class="line">    Node5-&gt;m_pNext=NULL;</span><br><span class="line">    Node5-&gt;m_pSibling=NULL;</span><br><span class="line"></span><br><span class="line">    Temp-&gt;m_pNext=Node2;</span><br><span class="line">    Temp=Temp-&gt;m_pNext;</span><br><span class="line">    Temp-&gt;m_pNext=Node3;</span><br><span class="line">    Temp=Temp-&gt;m_pNext;</span><br><span class="line">    Temp-&gt;m_pNext=Node4;</span><br><span class="line">    Temp=Temp-&gt;m_pNext;</span><br><span class="line">    Temp-&gt;m_pNext=Node5;</span><br><span class="line">    Temp=Temp-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* TempNew1=Head;</span><br><span class="line">    TempNew1-&gt;m_pSibling=TempNew1-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* TempNew2=Head;</span><br><span class="line">    TempNew2-&gt;m_pNext-&gt;m_pSibling=TempNew2-&gt;m_pNext-&gt;m_pNext-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* TempNew3=Head;</span><br><span class="line">    TempNew3-&gt;m_pNext-&gt;m_pNext-&gt;m_pNext-&gt;m_pSibling=TempNew3-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* TempNew4=Head;</span><br><span class="line">    TempNew4-&gt;m_pNext-&gt;m_pNext-&gt;m_pSibling=NULL;</span><br><span class="line"></span><br><span class="line">    ComplexListNode* TempNew5=Head;</span><br><span class="line">    TempNew4-&gt;m_pNext-&gt;m_pNext-&gt;m_pNext-&gt;m_pNext-&gt;m_pSibling=NULL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintListLink(ComplexListNode* Head)</span><br><span class="line">&#123;</span><br><span class="line">    ComplexListNode *Temp=Head;</span><br><span class="line">    <span class="keyword">while</span>(Temp!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Node Value: "</span>&lt;&lt;Temp-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(Temp-&gt;m_pSibling!=NULL)</span><br><span class="line">            cout&lt;&lt;<span class="string">"Sibling Value: "</span>&lt;&lt;Temp-&gt;m_pSibling-&gt;m_nValue&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">"Sibling Value:NULL"</span>;</span><br><span class="line">        Temp=Temp-&gt;m_pNext;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ComplexListNode* StepOneCopyAndLink(ComplexListNode* Head)</span><br><span class="line">&#123;</span><br><span class="line">    ComplexListNode* Temp=Head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Temp!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode* NewNode=new ComplexListNode();</span><br><span class="line">        NewNode-&gt;m_nValue=Temp-&gt;m_nValue;</span><br><span class="line">        NewNode-&gt;m_pNext=Temp-&gt;m_pNext;</span><br><span class="line">        Temp-&gt;m_pNext=NewNode;</span><br><span class="line">        Temp=NewNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StepTwoSiblingNode(ComplexListNode* Head)</span><br><span class="line">&#123;</span><br><span class="line">    ComplexListNode* Temp=Head;</span><br><span class="line">    <span class="keyword">while</span>(Temp!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Temp-&gt;m_pSibling!=NULL)</span><br><span class="line">            Temp-&gt;m_pNext-&gt;m_pSibling=Temp-&gt;m_pSibling;</span><br><span class="line"></span><br><span class="line">        Temp=Temp-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ComplexListNode* StepThreeDepartTheCopyLinkList(ComplexListNode* Head)</span><br><span class="line">&#123;</span><br><span class="line">    ComplexListNode* Head1=Head;</span><br><span class="line">    ComplexListNode* Head2=Head-&gt;m_pNext;</span><br><span class="line">    ComplexListNode* CopyHead=Head-&gt;m_pNext;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(Head1-&gt;m_pNext-&gt;m_pNext!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head1-&gt;m_pNext=Head1-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">        Head1=Head1-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">        Head2-&gt;m_pNext=Head2-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">        Head2=Head2-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Head1-&gt;m_pNext=NULL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> CopyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123; </span><br><span class="line">    ComplexListNode* Head;</span><br><span class="line">    Head=CreateLinkList();</span><br><span class="line">    cout&lt;&lt;<span class="string">"Original LinkList:"</span>&lt;&lt;endl;</span><br><span class="line">    PrintListLink(Head);</span><br><span class="line">    ComplexListNode* NewHead;</span><br><span class="line">    NewHead=StepOneCopyAndLink(Head);</span><br><span class="line">    cout&lt;&lt;<span class="string">"Step1:Copy Node After Each Node"</span>&lt;&lt;endl;</span><br><span class="line">    PrintListLink(NewHead);</span><br><span class="line">    StepTwoSiblingNode(NewHead);</span><br><span class="line">    cout&lt;&lt;<span class="string">"Step2:Copy Sibling Of Node"</span>&lt;&lt;endl;</span><br><span class="line">    PrintListLink(NewHead);</span><br><span class="line">    cout&lt;&lt;<span class="string">"Step3:"</span>&lt;&lt;endl;</span><br><span class="line">    ComplexListNode* CopyHead;</span><br><span class="line">    CopyHead=StepThreeDepartTheCopyLinkList(NewHead);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The Old LinkList is:"</span>&lt;&lt;endl;</span><br><span class="line">    PrintListLink(NewHead);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The Copy LinkList is:"</span>&lt;&lt;endl;</span><br><span class="line">    PrintListLink(CopyHead);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/07/剑指offer-面试题26-复杂链表的复制/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:请实现函数ComplexListNode&lt;em&gt; Clone(ComplexListNode&lt;/em&gt; pHead),复制一个复杂链表
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题25.二叉树中和为某一值的路径</title>
    <link href="http://yoursite.com/2015/09/05/%E9%9D%A2%E8%AF%95%E9%A2%9825-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2015/09/05/面试题25-二叉树中和为某一值的路径/</id>
    <published>2015-09-05T02:28:32.000Z</published>
    <updated>2018-09-30T14:11:27.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一颗二叉树和一个整数,打印出二叉树中借点值得和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>二叉树结点定义:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">   int m_nValue;</span><br><span class="line">   BinaryTreeNode* m_pLeft;</span><br><span class="line">   BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　       8</span><br><span class="line">   /  \</span><br><span class="line">  6   10</span><br><span class="line">    　/ \  / \</span><br><span class="line">5  7 9  11</span><br></pre></td></tr></table></figure><p>为例，当我们想要找到值为21的路径的时候。</p><p>步骤如下:<br>1.收到从根元素开始寻找路径，则在二叉树的三种遍历顺序中只有前序遍历满足条件。<br>2.接下来向左子树遍历到元素6，此时8+6=14仍然不等于21<br>3.继续向左子树遍历到元素5，此时8+6+5=19<br>4.发现此时元素5已经是叶子节点了，则退回到元素6，向右节点遍历到<br>元素7，此时8+6+7=21满足条件输出8，6,7<br>5.继续用同样的方式递归该二叉树的右子树即可。</p><p>这里存储路径的数据结构可以是stack可以是vector，用vector的原因是方便输出</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">     int m_nValue;</span><br><span class="line">     BinaryTreeNode* m_pLeft;</span><br><span class="line">     BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void CreateTree(BinaryTreeNode** Root)</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(data==0)</span><br><span class="line">    &#123;</span><br><span class="line">        *Root=NULL;</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *Root=(BinaryTreeNode*)malloc(sizeof(BinaryTreeNode));</span><br><span class="line">        (*Root)-&gt;m_nValue=data;</span><br><span class="line">        CreateTree(&amp;((*Root)-&gt;m_pLeft));    </span><br><span class="line">        CreateTree(&amp;((*Root)-&gt;m_pRight));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void PreOrder(BinaryTreeNode* Root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;Root-&gt;m_nValue&lt;&lt;endl;</span><br><span class="line">    PreOrder(Root-&gt;m_pLeft);</span><br><span class="line">    PreOrder(Root-&gt;m_pRight);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void FindPath(BinaryTreeNode* root,vector&lt;int&gt;&amp; VecPath,int Sum,int NowSum)</span><br><span class="line">&#123;</span><br><span class="line">    NowSum=NowSum+root-&gt;m_nValue;</span><br><span class="line">    VecPath.push_back(root-&gt;m_nValue);</span><br><span class="line"></span><br><span class="line">    bool yezi=root-&gt;m_pLeft==NULL&amp;&amp;root-&gt;m_pRight==NULL;</span><br><span class="line">    <span class="keyword">if</span>(NowSum==Sum&amp;&amp;yezi)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Find Path of Number "</span>&lt;&lt;Sum&lt;&lt;<span class="string">":    "</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;int&gt;::iterator iter=VecPath.begin();iter!=VecPath.end();iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*iter&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;m_pLeft!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;m_pLeft,VecPath,Sum,NowSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;m_pRight!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;m_pRight,VecPath,Sum,NowSum);</span><br><span class="line">    &#125;</span><br><span class="line">    VecPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void FindPathOfNumber(BinaryTreeNode* root,int Sum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; VecPath;</span><br><span class="line">    int NowSum=0;</span><br><span class="line">    FindPath(root,VecPath,Sum,NowSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode* root;</span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the tree node data(0-exit):\n"</span>;</span><br><span class="line">    CreateTree(&amp;root);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The PreOrder of Binary Tree:\n"</span>;</span><br><span class="line">    PreOrder(root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    int num;</span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the path sum you want to find: "</span>;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    FindPathOfNumber(root,num);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/05/面试题25-二叉树中和为某一值的路径/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一颗二叉树和一个整数,打印出二叉树中借点值得和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题24.二叉搜索树的后序遍历序列</title>
    <link href="http://yoursite.com/2015/09/04/%E9%9D%A2%E8%AF%95%E9%A2%9824-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2015/09/04/面试题24-二叉搜索树的后序遍历序列/</id>
    <published>2015-09-04T02:13:32.000Z</published>
    <updated>2018-09-30T14:07:01.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一个整数数组,判断该数组是不是某二叉搜索树的后序，如果是，则返回true，如果不是则返回false,假定输入的数组中任意两个数都不相等。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此题目我们以5,7,6,9,11,10,8为例<br>解题步骤如下:<br>1.先找到序列的最后一个元素8<br>2.按照顺序从序列的从前往后遍历，知道遇到第一个大于8的数即9，<br>3.那么元素9以前为左子树，全部小于跟节点，9以后为右子树，应该全部大于跟节点，可验证9,11,10全部大于根节点<br>4.那么现在又产生了两个后序遍历的子序列，一个为5,7,6 一个为11,10,8<br>5.显然将子序列进行递归1,2,3步骤。递归结束条件是子序列的长度小于等于零。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>代码实现如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool JustifyBSTAfterOrder(int a[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==NULL||length&lt;=0)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int RootValue=a[length-1];</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(RootValue&lt;a[i])</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int j=i;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;length-1;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(RootValue&gt;a[j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;0)</span><br><span class="line">        left=JustifyBSTAfterOrder(a,i);</span><br><span class="line"></span><br><span class="line">    int right=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;length-1)</span><br><span class="line">        right=JustifyBSTAfterOrder(a+i,length-i-1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> (right&amp;&amp;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[]=&#123;5,7,6,9,11,10,8&#125;;</span><br><span class="line">    int b[]=&#123;7,4,6,5&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(JustifyBSTAfterOrder(a,7))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Array a is JustifyBSTAfterOrder"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Array a is not JustifyBSTAfterOrder"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(JustifyBSTAfterOrder(b,4))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Array b is JustifyBSTAfterOrder"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Array b is not JustifyBSTAfterOrder"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图如下:<br><img src="/2015/09/04/面试题24-二叉搜索树的后序遍历序列/1.png" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一个整数数组,判断该数组是不是某二叉搜索树的后序，如果是，则返回true，如果不是则返回false,假定输入的数组中任意两个数都不
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题23.从上往下打印二叉树</title>
    <link href="http://yoursite.com/2015/09/03/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9823-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2015/09/03/剑指offer-面试题23-从上往下打印二叉树/</id>
    <published>2015-09-03T12:25:32.000Z</published>
    <updated>2018-09-30T14:02:56.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:从上往下打印出二叉树的每个结点,同一层的结点按照从左到右的顺序打印。例如输入图中的二叉树,则依次打印出8、6、10、5、7、9、11二叉树结点的定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue;</span><br><span class="line">    BinaryTreeNode*  m_pLeft;</span><br><span class="line">    BinaryTreeNode*  m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们以如下二叉树为例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6   10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7  9 11</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题实际上二叉树层次遍历方法:</p><p>解题步骤如下:<br>1.设置一个deque双端队列,将根节点加入队列<br>2.首先从队头取出根节点,输出根节点的数据值。同时将根节点的左右子结点加入队列，此时队列里面的节点为 6、10<br>3.从队头取出节点6，同时加入节点6的左右节点到队列尾，此时队列节点10、5、7<br>4.从队头取出节点10，同时加入节点10的左右节点到对尾，此时队列节点为5、7、9、11<br>5.此时取出队头节点5，节点5没有左右子节点则输出不必加队列<br>6.重复直到队列中元素全部取出后，层次遍历便完成了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;deque&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue;</span><br><span class="line">    BinaryTreeNode*  m_pLeft;</span><br><span class="line">    BinaryTreeNode*  m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void CreateTree(BinaryTreeNode** Root)</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(data==0)</span><br><span class="line">    &#123;</span><br><span class="line">        *Root=NULL;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *Root=(BinaryTreeNode*)malloc(sizeof(BinaryTreeNode));</span><br><span class="line">        (*Root)-&gt;m_nValue=data;</span><br><span class="line">        CreateTree(&amp;((*Root)-&gt;m_pLeft));    </span><br><span class="line">        CreateTree(&amp;((*Root)-&gt;m_pRight));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void PreOrder(BinaryTreeNode* Root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    </span><br><span class="line">    PreOrder(Root-&gt;m_pLeft);</span><br><span class="line">    cout&lt;&lt;Root-&gt;m_nValue&lt;&lt;endl;</span><br><span class="line">    PreOrder(Root-&gt;m_pRight);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LevelOrder(BinaryTreeNode* Root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    </span><br><span class="line">    deque&lt;BinaryTreeNode*&gt; D;</span><br><span class="line">    </span><br><span class="line">    D.push_back(Root);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!D.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* TempNode=D.front();</span><br><span class="line">        D.pop_front();</span><br><span class="line">        cout&lt;&lt;TempNode-&gt;m_nValue&lt;&lt;<span class="string">","</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(TempNode-&gt;m_pLeft!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            D.push_back(TempNode-&gt;m_pLeft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(TempNode-&gt;m_pRight!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            D.push_back(TempNode-&gt;m_pRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode* root;</span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the tree node data(0-exit):\n"</span>;</span><br><span class="line">    CreateTree(&amp;root);</span><br><span class="line">    cout&lt;&lt;<span class="string">"The PreOrder of Binary Tree:\n"</span>;</span><br><span class="line">    PreOrder(root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"The LevelOrder Of Binary Tree: "</span>;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图:<br><img src="/2015/09/03/剑指offer-面试题23-从上往下打印二叉树/1.jpg" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:从上往下打印出二叉树的每个结点,同一层的结点按照从左到右的顺序打印。例如输入图中的二叉树,则依次打印出8、6、10、5、7、9、11二
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题22.栈的压入,弹出序列</title>
    <link href="http://yoursite.com/2015/09/02/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9822-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2015/09/02/剑指offer-面试题22-栈的压入-弹出序列/</id>
    <published>2015-09-02T13:35:32.000Z</published>
    <updated>2018-09-30T13:59:12.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入两个整数序列,第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该该压栈序列的弹出序列。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这种判断其实只要掌握栈的先进后出原则,则不难解决。</p><p>本题的题解步骤如下:<br>1.设置一个辅助栈S,用于模拟出栈入栈顺序,设入栈顺序序列为pPush，出栈顺序序列为pPop<br>2.设置两个索引或指针分别指向入栈序列和出栈序列的第一个元素<br>3.顺序索引入栈元素，当入栈元素不等于出栈元素的时候，将入栈元素依次压入辅助栈S<br>4.当两者相等的时候,压入该元素到辅助栈S中同时将栈顶元素出栈，出栈入栈序列的索引均向后移动一个位置<br>5.当入栈序列索引结束之后，pPush剩余的元素全部已压入栈S<br>6.依次索引pPop如果pPop与辅助栈顶元素比较如果相等这将辅助栈顶弹出<br>7.当栈中所有的元素均弹出的时候则说明出栈顺序序列与正好是入栈顺序序列对应的出栈顺序。否则出栈顺序与入栈顺序不匹配。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>代码实现如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool IsPopOrder(const int* pPush,const int* pPop,int nLength)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;int&gt; S;</span><br><span class="line">    int p1=0,p2=0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1&lt;nLength)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pPush[p1]!=pPop[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            S.push(pPush[p1]);</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            S.push(pPush[p1]);</span><br><span class="line">            S.pop();</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2&lt;nLength)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pPop[p2]==S.top())</span><br><span class="line">        &#123;</span><br><span class="line">            S.pop();</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pPush[5]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    int pPop[5];</span><br><span class="line">    int len=5;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the sequence of Out stack:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int data=0;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        pPop[i]=data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(IsPopOrder(pPush,pPop,len))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"The out sequence is right."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"The out sequence is wrong."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/09/02/剑指offer-面试题22-栈的压入-弹出序列/1.jpg" alt="剑指offer(C/C++)"><br><img src="/2015/09/02/剑指offer-面试题22-栈的压入-弹出序列/2.jpg" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入两个整数序列,第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题21.包含min函数的栈</title>
    <link href="http://yoursite.com/2015/09/01/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9821-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://yoursite.com/2015/09/01/剑指offer-面试题21-包含min函数的栈/</id>
    <published>2015-09-01T12:12:32.000Z</published>
    <updated>2018-09-30T13:56:49.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:定义栈的数据结构,请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min,push及pop的时间复杂度都是O(1).</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这一题实际上需要一个辅助栈存储最小值:<br>1.在模板类定义两个栈类型私有成员变量,一个为保存数据的栈另外一个为保存最小值的栈<br>2.当栈为空的时候直接将数据同时压入数据栈和最小值栈<br>3.当栈不为空的时候，将数据先压入数据栈同时比较该数据和最小值栈栈顶元素的大小若大于最小值栈栈顶元素，则向最小值栈压入其栈顶元素，否则压入该数据到最小值栈栈顶<br>4.当我们使用方法的时候直接取最小值的栈顶即为栈中的最小值<br>5.当我们要pop栈的时候应同时pop最小值栈的栈顶元素</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>MinStack.h<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef _MINSTACK_H</span></span><br><span class="line"><span class="comment">#define _MINSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stack&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class StackWithMin</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(T data);</span><br><span class="line">    void pop();</span><br><span class="line">    T min();</span><br><span class="line">private:</span><br><span class="line">    stack&lt;T&gt; DataStack;</span><br><span class="line">    stack&lt;T&gt; MinStack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void StackWithMin&lt;T&gt;::push(T data)</span><br><span class="line">&#123;</span><br><span class="line">    DataStack.push(data);</span><br><span class="line">    <span class="keyword">if</span>(MinStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        MinStack.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data&gt;=MinStack.top())</span><br><span class="line">        &#123;</span><br><span class="line">            MinStack.push(MinStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            MinStack.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void StackWithMin&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    MinStack.pop();</span><br><span class="line">    DataStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; T StackWithMin&lt;T&gt;::min()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!DataStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> MinStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"不好意思栈空!"</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p><p>测试函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "MinStack.h"</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    StackWithMin&lt;int&gt; MinStack;</span><br><span class="line">    cout&lt;&lt;<span class="string">"请输入依次压入栈的数据(0-exit): "</span>&lt;&lt;endl;</span><br><span class="line">    int data;</span><br><span class="line">    <span class="keyword">while</span>(data!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(data!=0)</span><br><span class="line">            MinStack.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"栈的最小值为: "</span>&lt;&lt;MinStack.min()&lt;&lt;endl;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/09/01/剑指offer-面试题21-包含min函数的栈/1.jpg" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:定义栈的数据结构,请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min,push及pop的时间复杂度都是O(1)
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>关于在函数中返回动态分配的内存</title>
    <link href="http://yoursite.com/2015/08/31/%E5%85%B3%E4%BA%8E%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2015/08/31/关于在函数中返回动态分配的内存/</id>
    <published>2015-08-31T08:50:17.000Z</published>
    <updated>2018-09-17T18:13:10.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.有以下题目:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char* p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们期望的输出是:ThunderDownloader,然而当我们运行此段代码的时候发现，程序崩溃了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们深入分析下不难发现，当我们传入str到GetMemeory()函数中的时候，该函数我们创建了一个临时的指针变量片p，然后将其指向NULL。然后我们为临时指针变量p动态分配内存，注意，当我们在返回的时候整个临时指针变量是释放掉的，因为其内存是在栈内存中分配的。但是我们之前传入的str的内存地址与临时变量的内存地址是不相同的。所以此时str不能获取在函数GetMemmory分配的内存，因此后面的字符串复制和链接操作都将造成程序崩溃。</p><p>我们可以用下面的图形更加生动的这一过程:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/1.jpg" alt="C++"></p><p>假设str本身内存为0x123  临时指针变量p的内存为0x456  动态分配的内存起始地址为0x789当GetMemory函数结束的时候p被释放，而再也无指针指向这块动态分配的内存了。另外str也不可能获取这段动态分配的内存的地址。所以也造成了内存泄露。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我们可以用如下两种方法解决这一问题:</p><p>一种是二级指针:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char** p)</span><br><span class="line">&#123;</span><br><span class="line">    (*p)=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(&amp;str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图为:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/2.png" alt="C++"><br>关于二级指针的方法可以参考如下的流程图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/3.jpg" alt="C++"></p><p>另一种是指针的引用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char*&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/4.png" alt="C++"><br>关于指针引用方法的流程图如下:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/5.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.有以下题目:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcat函数的坑点</title>
    <link href="http://yoursite.com/2015/08/30/strcat%E5%87%BD%E6%95%B0%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>http://yoursite.com/2015/08/30/strcat函数的坑点/</id>
    <published>2015-08-30T13:11:12.000Z</published>
    <updated>2018-09-18T16:37:54.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们先看下面这样一段代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1= <span class="string">"123"</span>;</span><br><span class="line">    char *p2= <span class="string">"ABC"</span>;</span><br><span class="line">    char str[50]= <span class="string">"xyz"</span>;</span><br><span class="line">    strcat(p1,p2);</span><br><span class="line">    strcpy(str+2,p1);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>乍一看，这段代码的原意是将p2链接到p1的后面，p1为123ABC,然后将str字符数组向后移动两个位置，将p1拷贝到从该位置开始之后的内存中。结果为xy123ABC</p><p>然而我们运行一下这段代码发现程序崩溃了，我们调用堆栈发现函数定位在这一行:<br><img src="/2015/08/30/strcat函数的坑点/1.png" alt="C++"></p><p>这是怎么回事</p><p>赶紧再查查strcat函数的用法，发现当链接p1和p2字符串的时候，将链接的字符串一起存入p1中，那么就隐含了这么个意思，就是说P1的大小必须要容得下链接后的字符串。但是本质上是字符串”123”是保存在程序中的常量区，而常量区只能进行读操作不能进行写操作</p><p>那么我们在栈区定义一个较大的数组来保存连接后的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p1[20]=<span class="string">"123"</span>;</span><br></pre></td></tr></table></figure></p><p>现在我们再运行下看看结果:<br><img src="/2015/08/30/strcat函数的坑点/2.png" alt="C++"><br>这下果然正确了</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们先看下面这样一段代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题20.顺时针打印矩阵</title>
    <link href="http://yoursite.com/2015/08/29/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9820-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2015/08/29/剑指offer-面试题20-顺时针打印矩阵/</id>
    <published>2015-08-29T09:30:32.000Z</published>
    <updated>2018-09-30T13:54:08.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入一个矩阵,按照从外向里以顺时针的顺序依次打印出每一个数字。例如:<br>输入一个矩阵如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2    3    4</span><br><span class="line">5   6    7    8</span><br><span class="line">9   10   11  12</span><br><span class="line">13  14   15  16</span><br></pre></td></tr></table></figure></p><p>则依次打印出数字:1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实主要还是考察我们对二维数组的循环操作:<br>代码实现如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void PrintMatrixClockwisely(int** numbers,int columns,int rows)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">"The Matrix is: "</span>&lt;&lt;endl;;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;columns;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;numbers[i][j]&lt;&lt;<span class="string">"   "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">"The Output Array of Matrix is: "</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int count=0;</span><br><span class="line">    int left=0;</span><br><span class="line">    int top=0;</span><br><span class="line">    int bottom=rows-1;</span><br><span class="line">    int right=columns-1;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;(columns*rows))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=left;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;numbers[left][i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=top;i&lt;=bottom;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;numbers[i][right]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=right;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;numbers[bottom][i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=bottom;i&gt;=top;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;numbers[i][left]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int **nums;</span><br><span class="line">    int cols;</span><br><span class="line">    int rows;</span><br><span class="line">    int i,j;</span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the rows: "</span>;</span><br><span class="line">    cin&gt;&gt;rows;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"Please input the cols: "</span>;</span><br><span class="line">    cin&gt;&gt;cols;</span><br><span class="line"></span><br><span class="line">    nums=new int*[rows];</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;rows;i++)</span><br><span class="line">        nums[i]=new int[cols];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Please input the "</span>&lt;&lt;i+1&lt;&lt;<span class="string">"th"</span>&lt;&lt;<span class="string">" rows: "</span>&lt;&lt;endl;;</span><br><span class="line">        <span class="keyword">for</span>(j=0;j&lt;cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int data;</span><br><span class="line">            cin&gt;&gt;data;</span><br><span class="line">            nums[i][j]=data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    PrintMatrixClockwisely(nums,cols,rows);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;rows;i++)</span><br><span class="line">        delete[] nums[i];</span><br><span class="line">    delete[] nums;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/08/29/剑指offer-面试题20-顺时针打印矩阵/1.jpg" alt="剑指offer(C/C++)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入一个矩阵,按照从外向里以顺时针的顺序依次打印出每一个数字。例如:&lt;br&gt;输入一个矩阵如下:&lt;br&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题19.二叉树的镜像</title>
    <link href="http://yoursite.com/2015/08/27/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9819-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2015/08/27/剑指offer-面试题19-二叉树的镜像/</id>
    <published>2015-08-27T08:33:32.000Z</published>
    <updated>2018-09-30T13:51:07.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:请完成一个函数,输入一个二叉树,该函数输出它的镜像。<br>二叉树节点定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strcut BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    strcut BinaryTreeNode* m_pleft;</span><br><span class="line">    strcut BinaryTreeNode* m_pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实质是递归交换二叉树的左右节点。<br>比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    10</span><br><span class="line"> / \   / \</span><br><span class="line">5  7  9  11</span><br></pre></td></tr></table></figure></p><p>1.首先查看根节点与左右子节点是否为空,若为空则无需交换<br>2.先交换根节点的左右子节点。<br>3.再交换交换后的左子树的左右节点和右子树的左右节点<br>4.知道到达叶子节点,交换结束。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>递归函数如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void MirrorRecursively(BinaryTreeNode *pNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pleft==NULL&amp;&amp;pNode-&gt;m_pright==NULL)</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    struct BinaryTreeNode *TempNode;</span><br><span class="line">    TempNode=pNode-&gt;m_pleft;</span><br><span class="line">    pNode-&gt;m_pleft=pNode-&gt;m_pright;</span><br><span class="line">    pNode-&gt;m_pright=TempNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pleft)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pleft);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pright)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(pNode-&gt;m_pright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明:注意结束条件,到达叶子结点结束<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pNode-&gt;m_pleft==NULL&amp;&amp;pNode-&gt;m_pright==NULL)</span><br><span class="line">       <span class="built_in">return</span> NULL;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:请完成一个函数,输入一个二叉树,该函数输出它的镜像。&lt;br&gt;二叉树节点定义如下:&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题18.树的子结构</title>
    <link href="http://yoursite.com/2015/08/25/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%9818-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2015/08/25/剑指offer-面试题18-树的子结构/</id>
    <published>2015-08-25T03:12:32.000Z</published>
    <updated>2018-09-30T13:48:04.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目:输入两棵二叉树A和B,判断B是不是A的子结构。<br>二叉树节点定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">     int           m_nValue;</span><br><span class="line">     BinaryTreeNode* m_pLeft;</span><br><span class="line">     BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>求子树的思路大概是这样的:<br>1.判断树A和树B是否有相同的根节点<br>2.如果存在则判断A的子树是是否和B的结构相同</p><ol start="3"><li>如果不存在则A继续向下遍历,重复步骤1,2</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>第一步递归遍历A树,查找与B数的根元素相同的结点:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool HasSubtree(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    bool result=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1!=NULL&amp;&amp;pRoot2!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;m_nValue==pRoot2-&gt;m_nValue)</span><br><span class="line">            result=DoestTree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result=HasSubtree(pRoot1-&gt;m_pLeft,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result=HasSubtree(pRoot1-&gt;m_pRight,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二部同样递归判断A中的以某个节点为根节点的子树是不是和树B具有相同的结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool DoesTree1HaveTree2(BinaryTreeNode* pRoot1,BinaryTreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot2==NULL)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1==NULL)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot1-&gt;m_nValue!=pRoot2-&gt;m_nValue)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> DoesTree1HaveTree2(pRoot1-&gt;m_pLeft,pRoot2-&gt;m_pLeft)&amp;&amp;DoesTree1HaveTree2(m_pRoot1-&gt;m_pRight,pRoot2-&gt;m_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目:输入两棵二叉树A和B,判断B是不是A的子结构。&lt;br&gt;二叉树节点定义如下:&lt;br&gt;&lt;figure class=&quot;highlight b
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
</feed>
