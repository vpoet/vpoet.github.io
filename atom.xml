<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vpoet&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-17T17:19:37.007Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>vpoet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言学习第二章-寄存器</title>
    <link href="http://yoursite.com/2016/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/14/汇编语言学习第二章-寄存器/</id>
    <published>2016-04-14T01:56:50.000Z</published>
    <updated>2018-09-17T17:19:37.007Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><p>&ensp;&ensp;&ensp;&ensp;在CPU中，有四种主要的部件。运算器，控制器，寄存器，内部总线。这里的内部总线用于CPU内部进行各种信息的传递，与第一章所讲的控制总线，数据总线，地址总线不同，第一章所描述的总线属于外部总线，作为CPU与外部期间进行信息传递的通路。运算器用于各种信息的处理，寄存器用于信息的处理，控制器用于控制信息的处理。对于利用汇编编程来说，寄存器是主要操作的部件，不同的CPU中寄存器的个数和种类是不同的，8086CPU寄存器个数为14个AX,BX,CX,DX,CS,SS,DS,ES,SI,DI,SP,BP,IP,PSW。</p><h2 id="2-1-通用寄存器和字在寄存器中的存储"><a href="#2-1-通用寄存器和字在寄存器中的存储" class="headerlink" title="2.1 通用寄存器和字在寄存器中的存储"></a>2.1 通用寄存器和字在寄存器中的存储</h2><p>&ensp;&ensp;&ensp;&ensp;8086CPU所有的寄存器均为16位，其中AX,BX,CX,DX这四个寄存器一般作为通用的寄存器使用，用于存储一般的数据。16位寄存器能存储的最大值为2^16=65536，在8086CPU寄存器之前有很多8位的寄存器的CPU，为了和以前在8位寄存器下写的程序相兼容，8086CPU将16位寄存器可分为高八位和低八位的寄存器使用。</p><p>&ensp;&ensp;&ensp;&ensp;以AX寄存器为例，其逻辑结构如下图所示，从做到右依次为高位到低位。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/1.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;比如我们存储一个数据2000H(后缀H,hex代表16进制)，其二进制位10000000000000B(B,binary代表二进制),我们将该数据存入AX中为:</p><pre><code>0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0</code></pre> <p>&ensp;&ensp;&ensp;&ensp;当我们将AX分为两个8位寄存器的时候为:AH(AX High 8-BIT),AL(AX Low-BIT)。<br>&ensp;&ensp;&ensp;&ensp;类似的BX,CX,DX分成8位寄存器为:BH和BL，CH和CL，DH和DL<br>&ensp;&ensp;&ensp;&ensp;一个字节代表8位二进制位，一个字代表两个字节即16位二进制位。当存储一个字节的时候可以将其存储在寄存器的高8位或者低8位，当存储一个字的时候需要将该字的高字节存储在寄存器的高8位，将该字的低字节存储在寄存器的低8位。</p><h2 id="2-2-一些汇编指令和物理地址"><a href="#2-2-一些汇编指令和物理地址" class="headerlink" title="2.2 一些汇编指令和物理地址"></a>2.2 一些汇编指令和物理地址</h2><ol><li>mov ax,12h与MOV AX,12H是一样的效果，汇编指令不区分大小写</li><li><p>若ax和bx当前存储的值都是8226H，当执行add ax,bx的时候其结果应该为1044CH，但是存储结果的寄存器ax为16位而1044CH位20位，所以进位的1不能存储(当可以影响进位标识寄存器)，相加后的ax存储的值为044CH</p></li><li><p>指令add al,93h,执行器al中的数据为C5H，相加之后为158H。但是你会以为在al中存储58H，同时将最高位的1存储在ah中，那么这样理解你就错了，因为当汇编指令使用8位寄存器的时候，是作为独立的寄存器使用与其高位寄存器是无关的。所以ax中的值为0058h.</p></li><li>在进行运算和数据传送的时候。寄存器的位数必须一致，不能出现mov ax,bl或者add bh,ax之类的指令。</li><li>在第一章已经介绍过，计算机内的所有存储区都是通过进行统一进行编制的，其寻址是通过地址总线进行寻址，每个存储区单元都有唯一的地址进行寻址，这个地址我们称为物理地址。</li></ol><h2 id="2-3-16位机和8086进行寻址的方法"><a href="#2-3-16位机和8086进行寻址的方法" class="headerlink" title="2.3 16位机和8086进行寻址的方法"></a>2.3 16位机和8086进行寻址的方法</h2><p>&ensp;&ensp;&ensp;&ensp;16位机代表CPU内部进行运算和寄存的位数为16位，即CPU内部的运算器一次性能进行16位数据的运算，CPU内部的寄存器最大能存储16位数据单元。8086CPU有20条地址总线进行寻址，那么问题来了，CPU在进行寻址的时候地址信息会先存储在CPU内部，但是8086CPU内部最大可以存储16位地址信息，那么怎么来对20位地址进行存储呢。</p><p>&ensp;&ensp;&ensp;&ensp;其解决办法是在内部通过一个加法器将两个16位地址合成20位地址来进行存储区寻址。其示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/2.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;8086CPU内部的寄存器提供两个16位的地址，通过地址加法器合成一个20位的地址，进而通过输入输出电路将20位地址经由地址总线传送到外部存储区进行寻址。<br>&ensp;&ensp;&ensp;&ensp;两个16位地址通过地址加法器合成20位地址的示意图如下：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/3.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;地址加法器计算公式:<font color="#0099ff">20位物理地址=16位段地址<em>16+16位偏移地址</em></font>。这里简单解释一下，对于二进制数据来讲当进行移位操作的时候，左移动一位相当于2, 地址1230H*16即向左移位4位，变为12300H。这时候再加上偏移地址00C8H，结果为123C8H，该地址即为我们合成后的20位物理地址。<br>&ensp;&ensp;&ensp;&ensp;举个例子来说明这一问题,学校，体育馆，图书馆位于一条直线上，学校位于这条线的起点。示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/4.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;如果路人问路，图书馆在哪儿，那么可以有如下两种方式回答:</p><ol><li>从学校直走2826m即可达到图书馆</li><li>从学校直走2000m到达体育馆，再直走826m达到图书馆<br>第一种方法是直接给出图书馆的物理地址(直接地址)，第二种方式是通过体育馆作为中介间隔告诉图书馆的位置。</li></ol><p>&ensp;&ensp;&ensp;&ensp;进一步来想，如果只能通过纸条告诉路人图书馆得位置。但是只有两张可以写三位数的纸条，此时怎么办呢，那么我们可以在第一张纸条上写上200作为段地址，第二张纸条写上826作为偏移地址。那么我们可以通过:段地址200*10+偏移地址826=2826来获知图书馆的位置。</p><h2 id="2-4-段的概念和段寄存器"><a href="#2-4-段的概念和段寄存器" class="headerlink" title="2.4 段的概念和段寄存器"></a>2.4 段的概念和段寄存器</h2><p>&ensp;&ensp;&ensp;&ensp;首先要明确一个概念，内存并没有分段，是CPU在寻址的时候进行分段的，如图所示：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/5.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;我们可以认为10000H-100FFH组成一个段，该段的起始地址为10000H，段地址为1000H,大小为100H,我们也可以认为10000H-1007FH和10080H-100FFH位两个段，两个段的起始地址分别为10000H和10080H，段地址为1000H和1008H，段的大小为80H。如果一个段的偏移地址长度为N位，那么这个段的大小为2^N。</p><p>&ensp;&ensp;&ensp;&ensp;前面讲过CPU内部提供两个16位的地址通过加法器合成20位物理地址，那么提供16位段地址的部件是什么呢，显然是CPU内部的寄存器啦，8086CPU内部有四个段寄存器分别为CS,SS,DS,ES</p><h2 id="2-5-CS和IP"><a href="#2-5-CS和IP" class="headerlink" title="2.5 CS和IP"></a>2.5 CS和IP</h2><p>&ensp;&ensp;&ensp;&ensp;CS和IP作为两个非常重要寄存器，其中CS为代码段寄存器，IP为偏移量，通过公式CS<em>16+IP便可合成CPU当前要读取指令的物理地址。比如当前CS中存储为M，IP存储为N，那么CPU将从M</em>16+N的合成地址中取一条指令执行。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/6.png" alt="汇编语言学习第二章-寄存器"><br>通过CS和IP合成当前指令并取指令的逻辑图如上图所示。主要步骤如下:</p><ol><li>将CS和IP送入地址加法器合成20位物理地址为2000H*16+0000H=20000H</li><li>通过输入输出控制电路将20位物理地址送到地址总线进行寻址</li><li>将寻址到的汇编指令mov ax,0123H对应的机器码0123B8H依次通过数据总线传输到CPU中的指令缓冲器中。</li><li>执行指令，此时IP=IP+执行指令的长度，跳转步骤1.<br><strong><table><tr><td bgcolor="BlueViolet">说明一点，8086CPU加点复位后，CS和IP分别被设置为CS=FFFFH，IP=0000H，即开机后的第一条执行指令地址为FFFF0H。</td></tr></table></strong></li></ol><h2 id="2-6-修改CS和IP，代码段的介绍"><a href="#2-6-修改CS和IP，代码段的介绍" class="headerlink" title="2.6 修改CS和IP，代码段的介绍"></a>2.6 修改CS和IP，代码段的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;CS与IP组成CPU当前执行指令的位置，可以通过修改CS与IP改变CPU执行指令的顺序。然而问题来了，如何改变CS与IP 的值呢，这里要注意的是不能使用MOV指令改变CS和IP寄存器的值，因为8086CPU没有提供这样的功能。其实修改CS与IP的值方式有很多种，这里仅介绍jmp。 jmp 段地址:偏移地址 可改变CS与IP寄存器中的值，从而完成CPU执行指令顺序的跳转。比如jmp 12:34 这里CS=0012H IP=0034H 执行jmp 12:34之后将直接跳转到00154H处取指令执行。若仅仅想改变IP的值不改变CS的值，可以使用jmp 某一个合法寄存器  </p><ul><li>代码段为存放代码的一段内存区域，比如如下一段汇编代码：<pre><code>mov ax,0000add ax,123Hmov bx,axjmp bx</code></pre></li></ul><p>以上一段代码段存储在内存为123B0H-123B9H这段内存区域中，共十个字节，那么我们可以成为这段内存区域为代码段，前面已经介绍过要执行这段代码要把CS：IP指向mov ax，0000的内存区域即可。</p><h2 id="本章完结"><a href="#本章完结" class="headerlink" title="本章完结"></a>本章完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第一章-基础知识</title>
    <link href="http://yoursite.com/2016/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/04/13/汇编语言学习第一章-基础知识/</id>
    <published>2016-04-13T08:26:04.000Z</published>
    <updated>2018-09-17T17:19:57.343Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>&ensp;&ensp;&ensp;&ensp;所谓机器语言则是直接能被机器理解和执行的语言。计算机的核心处理部件为CPU，然而CPU往往只能直接识别机器语言，机器语言为一系列用二进制0,1码代表的机器指令。当然指令集合的差别与具体的CPU有关，AMD与Intel的指令集显然是不同的。然而要直接用二进制的机器语言去描述一段程序或者解决一个问题往往是很困难的。<br>比如说，我们要做这样一个运算s=768+12288-1280:<br><br>&ensp;&ensp;&ensp;&ensp;那么在8086cpu中其用机器语言表述的二进制代码为(机器码):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101110000000000000000011</span></span><br><span class="line"><span class="number">000001010000000000110000</span></span><br><span class="line"><span class="number">001011010000000000000101</span></span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;就这样一个简单的算术运算其机器码就让人头晕目眩，可想而知，如果直接用机器语言进行更为复杂程序的编写，其难度和对视力都是一个极大的考验。    </p><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><p>&ensp;&ensp;&ensp;&ensp;所以为了减轻程序员编程的难度，后来又相继发展了很多语言，比如汇编语言，C语言，C++以及java等语言。其中汇编语言属于低级语言，除此之外均为高级语言。汇编语言将机器语言中晦涩难懂的二进制代码用一些指令助记符进行表示，这样大大降低了程序员编写程序的难度。<br><br>&ensp;&ensp;&ensp;&ensp;比如，机器指令1000100111011000表示将寄存器BX的内容送到寄存器AX中，用汇编语言表述即为mov ax,bx 这样的表示方法不仅清晰易懂而且简洁。那么问题来了，计算机是不能识别mov指令的，那么在汇编程序与CPU之间就需要一个转化的工具，将简洁易懂的汇编语言转换为机器可以理解并执行的机器语言。这个转化工具即为汇编编译器。<br><br>&ensp;&ensp;&ensp;&ensp;用汇编语言编写程序的过程如下:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/1.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul><li>汇编指令:对应机器指令的助记符(核心)</li><li>伪指令：由汇编编译器识别，没有对应的机器指令</li><li>其他符号:如+-*/等，由编译器识别，没有对应的机器指令</li></ul><h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>&ensp;&ensp;&ensp;&ensp;CPU要完成一系列规定的操作，需要两个重要的元素，一是指令(做什么操作)，另外一个是数据(对什么做操作) 。计算机中的很多地方都存储有我们需要的处理的数据，比如内存，比如硬盘，比如寄存器。但是这里要注意的是，CPU要取得需要处理的数据需要将硬盘上的传入内存才能拱CPU调用。</p><h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>&ensp;&ensp;&ensp;&ensp;指令和数据都是在内存上的二进制信息，CPU赋予不同的二进制于数据或者指令的意义。例如：内存中二进制信息1000100111011000,计算机可以把它看作大小为89D8H的数据来处理，也可以理解为mov ax,bx.这里我们要明白一个概念就是内存上的指令和数据的区别是又计算机识别的，就其表现形式来说都是二进制代码，无差。</p><h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的信息是按字节存储的，每个字节代表8位二进制位。对于128个存储单元的存储器来说，我们可以认为其容量为128字节。当然大容量的存储器还有以下一些换算关系：</p><pre><code>1KB=1024B 1M=1024KB 1G=1024MB 1TB=1024GB</code></pre><h2 id="1-7-CPU对存储单元的读写"><a href="#1-7-CPU对存储单元的读写" class="headerlink" title="1.7 CPU对存储单元的读写"></a>1.7 CPU对存储单元的读写</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的存储单元都是从零编号，每个存储单元都有自己的编号，我们可以称之为地址。这个地址唯一标识一个存储单元。CPU想要从某个存储单元中读取数据，那么就要通过该地址进行寻址。<br>计算机中包括三类总线：地址总线，数据总线，控制总线。CPU通过这三类总线与外部存储设备进行数据交互和控制。其中地址总线用于传输寻址存储器的地址，数据总线用于从寻址到的存储器进行读写数据，控制总线进行器件的选择和读写命令的控制。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/2.png" alt="汇编语言学习第一章-基础知识"><br>&ensp;&ensp;&ensp;&ensp;图中地址总线传输三号地址进行寻址，控制总线发送内存读取命令对三号地址存储器中的信息进行读取，数据总线将三号地址存储器中的08传送的CPU。<br>对于8086CPU，下面的机器码，能够完成从三号内存地址单元读取数据。<br>机器码:<pre><code>101000010000001100000000</code></pre>  <br>含义：从三号地址内存单元读取数据到寄存器AX<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编指令：<span class="keyword">mov</span> AX,[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了寻址空间的大小，比如16位地址总线，每位地址总线代表高低电平两个状态，那么16为地址总线代表了2^16种状态，2^16=65536byte 即65536/1024=64kB<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/3.png" alt="汇编语言学习第一章-基础知识"><br>上图为对地址为1101000000的内存单元寻址示意。</p><p>##1.9 数据总线<br>&ensp;&ensp;&ensp;&ensp;CPU通过数据总线和外部存储器进行数据传递，数据总线的大小决定了传输的速度，比如8位数据总线一次性可传输8位数据，16位数据总线一次性可传输16位数据。8088CPU数据总线为8位，8086CPU数据总线为16位。<br>举个例子，分别以8位和16位数据总线向内存中写入89D8如图所示:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/4.png" alt="汇编语言学习第一章-基础知识"><br><img src="/2016/04/13/汇编语言学习第一章-基础知识/5.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>&ensp;&ensp;&ensp;&ensp;cpu通过控制总线对外部器件进行控制，有多少根控制总线就可以有多少总控制，比如对内存的读写代表两种控制命令。</p><h2 id="1-11-内存空间概述，主板，接口卡"><a href="#1-11-内存空间概述，主板，接口卡" class="headerlink" title="1.11 内存空间概述，主板，接口卡"></a>1.11 内存空间概述，主板，接口卡</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了内存寻址空间的大小，比如10位地址总线，可寻址2^10=1024byte的地址。每台计算机都有主板，主板上的各种器件(CPU，内存，外围芯片，扩展槽)通过地址总线，控制总线和数据总线链接。在计算机中，CPU不能直接对外部设备进行控制，对外部设备直接控制的是接口卡，接口卡插在扩展槽上，扩展槽与CPU通过总线相连，进而CPU通过对扩展槽上的接口卡控制达到对外设控制的目的。</p><p>##1.12 各类存储器芯片<br>&ensp;&ensp;&ensp;&ensp;存储器包括两大类随机存储器(RAM)和只读存储器(ROM).其中随机存储器用于存储CPU运行所需的程序和数据，不过掉电之后，RAM存储器中的数据和程序会丢失。只读存储器只能读取其中的数据不能改写其中的数据。<br>其中RAM包括主板上的RAM，扩展槽上的RAM和接口卡上的RAM(比如显存)<br>另外装有BIOS的ROM，例如主板上的ROM，显卡上的ROM等。<br>计算机中各类存储器的逻辑连接情况。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/6.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-13-内存地址空间"><a href="#1-13-内存地址空间" class="headerlink" title="1.13 内存地址空间"></a>1.13 内存地址空间</h2><p>&ensp;&ensp;&ensp;&ensp;虽然在1.12中介绍了很多存储器，但是他们都是通过地址总线与CPU相连的，另外CPU这些存储器读写的时候都是通过控制总线发送读写命令。很重要的一点是，CPU将对这些存储器统一编址，这样就可以在一个地址空间里对计算机中的所有存储器进行寻址。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/7.png" alt="汇编语言学习第一章-基础知识"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于在函数中返回动态分配的内存</title>
    <link href="http://yoursite.com/2015/08/31/%E5%85%B3%E4%BA%8E%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2015/08/31/关于在函数中返回动态分配的内存/</id>
    <published>2015-08-31T08:50:17.000Z</published>
    <updated>2018-09-17T18:13:10.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.有以下题目:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char* p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们期望的输出是:ThunderDownloader,然而当我们运行此段代码的时候发现，程序崩溃了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们深入分析下不难发现，当我们传入str到GetMemeory()函数中的时候，该函数我们创建了一个临时的指针变量片p，然后将其指向NULL。然后我们为临时指针变量p动态分配内存，注意，当我们在返回的时候整个临时指针变量是释放掉的，因为其内存是在栈内存中分配的。但是我们之前传入的str的内存地址与临时变量的内存地址是不相同的。所以此时str不能获取在函数GetMemmory分配的内存，因此后面的字符串复制和链接操作都将造成程序崩溃。</p><p>我们可以用下面的图形更加生动的这一过程:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/1.jpg" alt="C++"></p><p>假设str本身内存为0x123  临时指针变量p的内存为0x456  动态分配的内存起始地址为0x789当GetMemory函数结束的时候p被释放，而再也无指针指向这块动态分配的内存了。另外str也不可能获取这段动态分配的内存的地址。所以也造成了内存泄露。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我们可以用如下两种方法解决这一问题:</p><p>一种是二级指针:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char** p)</span><br><span class="line">&#123;</span><br><span class="line">    (*p)=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(&amp;str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图为:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/2.png" alt="C++"><br>关于二级指针的方法可以参考如下的流程图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/3.jpg" alt="C++"></p><p>另一种是指针的引用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char*&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/4.png" alt="C++"><br>关于指针引用方法的流程图如下:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/5.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.有以下题目:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C艹对象模型浅析</title>
    <link href="http://yoursite.com/2015/07/28/C%E8%89%B9%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2015/07/28/C艹对象模型浅析/</id>
    <published>2015-07-28T03:39:09.000Z</published>
    <updated>2018-09-17T18:03:54.860Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"><a href="#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。" class="headerlink" title="本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"></a>本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。</h5><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp;&ensp;&ensp;&ensp;就如<strong>《深度探索C++对象模型》</strong>一书中介绍的C++的封装并没有给C++带来过多的开销。然而面向对象的编程方法却给广大的编程者提供了一种更为开阔的编程思路。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;好，我们主要看看前面一句。开销是什么，这里的开销主要指C++类所占内存的空间。首先,我们看这样一个例子，我们定义一个结构体和类，结构体和类中含有相同的数据成员。除此之外再无其他。我们看看这个结构体和类的大小是多少:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/1.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">看来只要数据成员相同,那么就算声明为类,也不会带来额外的内存开销。</td></tr></table></strong></p><p>&ensp;&ensp;&ensp;&ensp;现在我们再看一个例子，我们让类B更加复杂一下，我们添加一个静态成员变量和，一个静态成员函数，一个非静态成员函数，一个虚函数:我们再看看这个例子的结果将是什么样的结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">    static int d;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static void fun1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a static fun1."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void fun2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is ordinary fun2."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void fun3()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a virtual fun3."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/2.jpg" alt="C++"><br>在这里我们增加了一个静态数据成员d，一个静态成员函数fun1，非静态的成员函数fun2一个虚函数fun3.不难发现就类的代码规模来说，的确增加了不少，然而结果仅仅比之前增加了四个字节的开销。<table><tr><td bgcolor="red">《深度探索C++对象模型》中有这样一句话说C++封装所带来的开销主要来源于虚函数。</td></tr></table></p><p>那么我们可以先看看结构体A的内存分布:可以产生结构体A的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *a;</span><br><span class="line">a=new A;</span><br></pre></td></tr></table></figure></p><p>对象a的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/3.jpg" alt="C++"><br>显然a中有三个整型数据元素a,b,c刚好12个字节</p><p>现在我们看看类B的内存分布</p><p>可以产生类B的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B *b;</span><br><span class="line">b=new B;</span><br></pre></td></tr></table></figure></p><p>对象B的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/4.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">可以看到尽管类B封装的很多的内容，但是较之A而言仅仅多了一个__vfptr，我们不禁回忆起前面的一句话，C++的封装的开销主要来自于虚函数。其实如果对C++有一定了解的同学都不难猜出，这个ptr其实就是一个虚表指针。正因为这个虚表指针给封装带来了额外的4个字节的开销。</td></tr></table></strong></p><p>那么虚表指针是什么呢，虚表指针其实就是指向虚函数表的一个指针。当一个类中有虚函数的时候，类会自动生成一个指针，该指针保存的是该类中第一个虚函数的地址。所以就算有多个虚函数仍然只需要保存一个虚表指针，然后通过这个指针逐个遍历就可以取得各个虚函数的地址。然而关于虚函数在C++中功能特性我们留待下次一起学习了。<br><img src="/2015/07/28/C艹对象模型浅析/5.jpg" alt="C++"></p><p><br><br>这下一目了然了吧。<br>那么我们可以总结一下影响类的内存开销主要有以下几个方面:</p><table><tr><td bgcolor="BlueViolet">1. 非静态的数据成员<br>2. 虚函数表指针<br>3. 当然既然类也是要考虑内存对齐的。 </td></tr></table><p>还有几点需要注意:<br><strong>1.类的静态数据成员存储在全局变量区，不带来C++内存开销,该静态数据成员属于整个类的不属于具体某个对象，其初始化要在类外进行。<br>2.类的静态成员函数是属于整个类的，不属于某个对象，不会带来内存开销。注意类的静态成员函数中不能调用非静态的成员变量。<br>3.类的普通成员函数始终在程序的代码区中保存一份，不带来内存开销.</strong></p><p>最后再通过一张图片只管展示结构体A和类B的内存布局:<br><img src="/2015/07/28/C艹对象模型浅析/6.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot;&gt;&lt;a href=&quot;#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot; class=&quot;headerlink&quot; title=&quot;本文仅代
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题3.二维数组中的查找</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%983-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题3-二维数组中的查找/</id>
    <published>2015-07-20T14:35:32.000Z</published>
    <updated>2018-09-17T17:49:58.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断该数组中是否有该整数。</p><p>算法流程如下:<br>比如一个二维数组array:</p><pre><code>1 2 8 92 4 9 124 7 10 136 8 11 15</code></pre><p>1.这个二维数组的左上角是最小的数据,右下角为最大的数，首先判断查找的数是否number&lt;array[0][0]或number&gt;array[1][1]<br>2.当number的大小在数组范围内再开始查找,找数组的右上角或者左下角开始作为比较的基准,当选择左上角的时候，假设我们查找的为number=7<br>3.如果numbe&lt;9，说明number比最后一列都小,再比较无意义<br>这时候数组为:</p><p><pre><code>1 1 2 8<br>2 2 4 9<br>3 4 7 10<br>4 6 8 11<br></code></pre><br>4.我们再取右上角的8作为基准，8大于7,再去掉最后一列</p><p><pre><code>1 2<br>2 4<br>4 7<br>6 8</code></pre><br>5.我们再取右上角的2作为基准，2&lt;7那么，说明第一行再比较无意义，去掉第一行</p><p><pre><code>2 4<br>4 7<br>6 8</code></pre><br>6.我们再把右上角的4作为基准，4&lt;7那么,去掉第一行</p><p><pre><code>4 7<br> 6 8<br></code></pre><br>7.现在我们再比较右上角元素，7==7 恩 找到了。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool Find(int* matrix,int rows,int columns,int number)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(number&gt;matrix[rows*columns-1]||number&lt;matrix[0])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    i=0;</span><br><span class="line">    j=columns-1;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(number&gt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j&lt;0||i&lt;0||i&gt;3||j&gt;3)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点注意:</p><p><strong> <table><tr><td bgcolor="BlueViolet">1.查找的时候有的同学可能会问能不能不从右上角开始作为基准。答案是肯定的，但是只能从右上角和左下角作为基准，为什么？因为我们选择的基准必须在某个维度上是最大的在某个维度上是最小的，不然我们就不能根据比较的结果决定是否去掉一行或者去掉一列<br>2.查找的结束条件是，当我们的右上角元素索引值只要有一个维度的索引值不在二维数组的正常索引范围内就说明需要查找的元素不在这个数组中。<br><br>尤其是第一点,希望读者好好理解。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题2.实例Singleton模式</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%982-%E5%AE%9E%E4%BE%8BSingleton%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题2-实例Singleton模式/</id>
    <published>2015-07-20T13:16:21.000Z</published>
    <updated>2018-09-17T17:39:31.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个类,我们只能生成该类的一个实例</p><p>这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只能生成一个类的实例。那么我们不难考虑到下面几点:</p><ol><li>不能new多个对象，那么必然该类的构造函数是私有的</li><li>类对象只有一个，那么必然该对象只能有一个私有的静态成员变量，该成员变量为类实例或者类实例的指针。</li><li>但是我们同时还要考虑到如果获取这个唯一对象实例,那么该类必然有一个公有的成员函数来获取这个唯一的类实例然    而由于不允许new对象,那么必须提供一种类操作该接口的方式,很显然就是静态成员函数。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>至此不难写设计出这样一个类:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingle</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    CSingle()  //私有构造函数,禁止new对象实例</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static CSingle *m_pInstance;  //私有静态全局变量,保证唯一性</span><br><span class="line">public:</span><br><span class="line">    static CSingle * GetInstance()  //提供一个共有接口获取该唯一类实例</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance == NULL)</span><br><span class="line">            m_pInstance = new CSingle();</span><br><span class="line">        <span class="built_in">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>那么我们构造这个唯一实例是这样的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSingle *Single=CSingle::GetInstance();//当该唯一实例不存在时,这是唯一获取类实例的方法。</span><br><span class="line">CSingle *Single1=Single-&gt;GetInstance();//当上一步执行后便可用此方法获取唯一类实例</span><br><span class="line">CSingle &amp; Single1=Single-&gt;GetInstance();//当然也可以这样</span><br></pre></td></tr></table></figure></p><p><strong> <table><tr><td bgcolor="BlueViolet">上面的做法对于单线程来说可以表现的很好了，但是对于多线程来说，就可能有问题了。当两个线程同时创建实例的时候，这时候实例不存在，这时候就可能产生两个类实例，于是我们就需要用同步的方法保证创建的时候只有一个线程。线程同步的方法很多，可以是临界区，可以是互斥等。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;设计一个类,我们只能生成该类的一个实例&lt;/p&gt;
&lt;p&gt;这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题1:赋值运算符函数</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%981-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题1-赋值运算符函数/</id>
    <published>2015-07-20T12:37:08.000Z</published>
    <updated>2018-09-17T17:39:08.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CMyString</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CMyString(char *pData=NULL);</span><br><span class="line">    CMyString(const CMyString &amp; str);</span><br><span class="line">    ~CMyString(void);</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    char * m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>首先在解答这道题目之前,先要作一些说明:</p><ol><li><p>任何类都是默认的重载赋值操作符。</p></li><li><p>类一旦被声明并且编译后就会为该类的实例分配内存。</p></li><li><p>如果类的成员变量没有在堆(动态分配)中分配内存，那么无需重载赋值操作符也可。因为这样的赋值只是为每个成员变量赋值而已。</p></li></ol><p>比如:对象A有成员变量int a1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.a1=1;</span><br><span class="line">A b;</span><br><span class="line">b.a1=2; </span><br><span class="line">a=b;</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>当执行到a=b;这一步的时候其实即使我们没有重载赋值操作符,也会调用类A的对象a的默认赋值函数</p><p>至此,对象a中的a1成功赋值为b1即2，没有问题的。</p><p>接下来我们要考虑另外一种情况</p><p>假如类A中有一个指针成员变量int *ptr;该ptr在构造函数中new了一块内存。那么我们重新考虑类A的两个对象a,b。对象a,b分别有一个指针ptr，并且该指针在构造函数中分别new了一块内存我们分别以mema和memb表示。在a的ptr中new的内存mema中的值我们设为1,在b的ptr中new的内存memb中的值我们设为2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;/在构造函数new ptr(mema)</span><br><span class="line">A b;/在构造函数new ptr(memb)</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure></p><p>当我们执行到a=b这一步的时候,我们如果没有重载赋值操作符。那么<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void A::operate = (A b)</span><br><span class="line">&#123;</span><br><span class="line">     this.ptr=b.ptr;5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><table><tr><td bgcolor="">乍看好像也没什么错,是的<br>this.ptr=b.ptr这句是将对象b.ptr的所指向的内推地址memb赋值给了a.ptr所指向的对象。好了问题来了,那么a.ptr所指向的那块内推是分配在堆中的也就所如果我们没有主动释放它是不会自动释放的。然而a.ptr已经指向了memb，这样很明显对象a出现了内存泄露。当然问题还不止于此,现在a.ptr和b.ptr都同时指向了memb.那么如果当对象a或者b结束后必然会释放掉memb，比如说a先结束释放memb，那么b.ptr是不是就成了野指针了呢,如果b先结束,那么a.ptr便成为了野指针,同时对象a还出现了内存泄露.</td></tr></table></strong></p><p>那么你会问为什么之前直接赋值就可以而这里直接赋值就不行呢,这就涉及一个内存管理的问题,分配在堆的内存是需要我们用户自己释放的,而分配在栈的内存是由程序自己管理，程序结束后会自动释放。</p><p>现在明白重载赋值操作符的场景了吧，</p><p>那么还有几点需要说明:</p><ol><li>赋值操作符重载通常形参我们是引用,引用可以减少直接传值带来的构造开销.</li><li>赋值操作符重载通常形参是常量,这是为了防止在赋值过程中操作符右值被修改。</li><li>如果为了连续赋值应该把返回值类型声明为该类型的引用,否则函数的返回值为void,不能连续赋值。</li><li>当然为我们还应该考虑传入的对象是否和被赋值对象是否相等。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>综合以上因素，这道题结果如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::operator = (const CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(this==&amp;str)</span><br><span class="line">        <span class="built_in">return</span> *this;</span><br><span class="line"> </span><br><span class="line">    delete []m_pData;</span><br><span class="line">    m_pData=NULL;</span><br><span class="line"> </span><br><span class="line">    m_pData=new char[strlen(str.m_pData)+1];</span><br><span class="line"> </span><br><span class="line">    strcpy(m_pData,str.m_pData);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如下为类型CMyString的声明，请为该类型添加赋值运算符函数&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>VC++6.0下通过opencv读入图像并反色</title>
    <link href="http://yoursite.com/2015/01/06/VC-6-0%E4%B8%8B%E9%80%9A%E8%BF%87opencv%E8%AF%BB%E5%85%A5%E5%9B%BE%E5%83%8F%E5%B9%B6%E5%8F%8D%E8%89%B2/"/>
    <id>http://yoursite.com/2015/01/06/VC-6-0下通过opencv读入图像并反色/</id>
    <published>2015-01-06T12:19:43.000Z</published>
    <updated>2018-09-17T18:22:16.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>第一个opencv测试程序:不多说,直接上代码,代码注释很详尽:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">////////////////////////////////////////////////////////////////////////</span><br><span class="line">//</span><br><span class="line">// 该程序从文件中读入一幅图像，将之反色，然后显示出来. </span><br><span class="line">//</span><br><span class="line">////////////////////////////////////////////////////////////////////////</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;math.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cv.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;highgui.h&gt; </span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    IplImage* img = 0;    //定义图像文件指针,指向载入的原始图像</span><br><span class="line">    IplImage* pDstImg = 0; //定义图像文件指针,指向反色后的图像</span><br><span class="line">    //定位图像的长度(像素),宽带(像素),通道数(指每个像素用多少个字节表示)   </span><br><span class="line">    int height,width,channels;  </span><br><span class="line">    uchar *data;      //存储图像具体的像素数据</span><br><span class="line"></span><br><span class="line">    char Image_Filename[20];  //输入图像文件的文件名</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the filename of image:\n"</span>);</span><br><span class="line">    scanf(<span class="string">"%s"</span>,Image_Filename);</span><br><span class="line"> </span><br><span class="line">   //载入图像函数,第一个参数为图像名称.第二个参数为辅助参数，</span><br><span class="line">   //有正,零,负三种值.正数表示以三通道图像载入(三通道即一个像素用3个字节表示),0表示</span><br><span class="line">   //以单通道载入图像，负数代表载入图像的通道数由图像本身决定.</span><br><span class="line">    img=cvLoadImage(Image_Filename,0);  </span><br><span class="line">                         </span><br><span class="line">                        </span><br><span class="line">    <span class="keyword">if</span>(!img)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not load image file: %s\n"</span>,argv[1]);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    height    = img-&gt;height;  //获取图像高度(像素)</span><br><span class="line">    width     = img-&gt;width;        //获取图像宽度(像素)</span><br><span class="line">    channels  = img-&gt;nChannels; //获取图像通道数</span><br><span class="line">    data      = (uchar *)img-&gt;imageData;  //获取图像像素数据</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Processing a %dx%d image with %d channels\n"</span>,height,width,channels); </span><br><span class="line">    </span><br><span class="line">    //创建一个名称为mainWin的窗口,用于显示图像.CV_WINDOW_AUTOSIZE值为1</span><br><span class="line">    //表示固定窗口大小,若第二个参数为0表示窗口大小可变,图像也会随着窗口的大小而改变</span><br><span class="line">    cvNamedWindow(<span class="string">"mainWin"</span>, 0);   </span><br><span class="line">                </span><br><span class="line">    //设置窗口的位置,第一个参数为窗口的名字,后面两个参数为窗口显示的位置,(0,0)表示显示在桌面的左上角.    </span><br><span class="line">    cvMoveWindow(<span class="string">"mainWin"</span>, 0, 0); </span><br><span class="line">    </span><br><span class="line">    //cvCreateImage函数返回指向一个图像文件指针,第一个参数指定图像</span><br><span class="line">    //的大小,第二个参数制定 像素的位深度，主要有以下支持格式：</span><br><span class="line">    //IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,IPL_DEPTH_16S, IPL_DEPTH_32S,</span><br><span class="line">    //最后一个参数制定图像的通道数</span><br><span class="line">    pDstImg = cvCreateImage(cvGetSize(img),img-&gt;depth,img-&gt;nChannels); </span><br><span class="line">                                     </span><br><span class="line">                                           </span><br><span class="line">                                    </span><br><span class="line">    //cvNot(IplImage* src,IplImage* dest)将src图像的每个像素数据的每一位取反赋值给dest图像对应像素点数据</span><br><span class="line">    cvNot(img, pDstImg);   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cvShowImage(<span class="string">"mainWin"</span>, img ); //在之前创建的mainWin窗口中显示图像</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    cvWaitKey(0);     //等待敲击键盘,结束程序    </span><br><span class="line">    </span><br><span class="line">    cvReleaseImage(&amp;img );  //释放图像文件指针</span><br><span class="line">    cvReleaseImage(&amp;pDstImg ); </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2015/01/06/VC-6-0下通过opencv读入图像并反色/1.png" alt="OpenCV"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;第一个opencv测试程序:不多说,直接上代码,代码注释很详尽:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>套接字基础</title>
    <link href="http://yoursite.com/2014/08/03/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2014/08/03/套接字基础/</id>
    <published>2014-08-03T06:28:11.000Z</published>
    <updated>2018-09-18T14:40:02.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字原理"><a href="#套接字原理" class="headerlink" title="套接字原理"></a>套接字原理</h2><p>本文是续上文关于基于TCP套接字实现的简单Demo后进行套接字基本知识的讲解.<br>可能文中有一些术语使用不太准确,但作为我自己的理解,尽量以通俗的语言为大家讲解.</p><p>套接字即Socket.用于在进程之间进行通信.当然进程通信的方式多种多样,但是Socket在进程通信的使用却十分广泛.</p><p>当然这里有几个概念需要区分.http,socket,tcp/ip之间的关系.大家都知道,现在互联网中广泛使用TCP/IP协议,如果你想要在当前的网络中传输数据,那么就必须遵守TCP/IP协议准则,而http是属于应用层面的协议,与FTP,Telnet等协议类似,当然还有用户自定义的一些协议.这些协议的目的是对TCP/IP传输的数据进行解析.而Socket作为进程通信的手段也是基于TCP/IP协议的,然而我们要实现应用层协议或者实现自己的协议,我们必须使用Socket提供的借口才能使这些协议数据是通过TCP/IP协议准则传输的.</p><p>总之,TCP/IP是根本的准则.通过Socket我们才能利用TCP/IP协议.而应用层协议则提供我们对Socket传输的数据进行封包和解析的标准.</p><p>对于一个套接字,我们可以看做是一条电话线路,而这条线路的建立则是基于TCP/IP标准的,而电话线两端就是我们通信的双方.</p><p>那么一个套接字如何标识一个链接或者说如何识别通信的双方呢.</p><p><strong> <table><tr><td bgcolor="green">那就是套接字三元组:    套接字=协议+端口+IP</td></tr></table></strong></p><h2 id="套接字分类"><a href="#套接字分类" class="headerlink" title="套接字分类"></a>套接字分类</h2><p>根据使用的协议类型不同,套接字分为三类.</p><ol><li>TCP套接字</li><li>UDP套接字</li><li>原始套接字.</li></ol><p>其中使用较为广泛的是TCP套接字和UDP套接字.而原始套接字是基于数据链路层协议.这里不作介绍.</p><p>了解TCP协议都知道,TCP是面向链接的协议,在通信之前在通信双方要先进行“三次握手”成功建立连接后才能进行通信,所以其传输数据时可靠的,然而正是因为此原因,使得TCP的套接字传输效率要低一些.</p><p>而UDP套接字是面向无连接，但是不提供可靠的数据传输.这点说明在传输的过程中有可能出现数据丢失,但是正是在传输之前不需要建议连接,这种数据传输的方式要高于TCP传输方式.</p><p>原始套接字在这里也不作介绍,因为我也很少接触.</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>关于Socket字的方式 有两类</p><ol><li>阻塞方式</li><li>非阻塞方式.</li></ol><p>我们可以简单的这样理解,阻塞方式是当建立多个套接字连接后,多个套接字同时传输和接受数据的方式可以成为非阻塞方式.而相反,当多个套接字进行连接后,只有只有当一个套接字完成接或者发数据的方式后才能进行下一个套接字的收或者发数据的动作成为阻塞方式.显然阻塞方式要比非阻塞方式复杂.但是在实际应用中大多使用阻塞方式进行数据传输.阻塞方式大多使用多线程的方式实现.</p><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">short sin_family;//AF_INET</span><br><span class="line">u_short sin_port;//16位端口号，网络字节顺序</span><br><span class="line">struct in_addr sin_addr;//32位IP地址，网络字节顺序</span><br><span class="line">char sin_zero[8];//保留</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个套接字地址结构就将套接字三元组完整的定义了.</p><h2 id="TCP套接字的流程"><a href="#TCP套接字的流程" class="headerlink" title="TCP套接字的流程"></a>TCP套接字的流程</h2><p><img src="/2014/08/03/套接字基础/1.png" alt="网络编程"></p><p>不难看出我们可以对TCP套接字的服务器端和客户端用到的API进行总结：</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server:"></a>Server:</h2><ul><li>加载套接字库,进行套接字库初始化.这样我们才能使用需要的套接字.</li><li><p>创建套接字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：SOCKET PASCAL FAR socket(int af,int <span class="built_in">type</span>,int procotol);</span><br><span class="line">参数：af: 通信发生的区域</span><br><span class="line"><span class="built_in">type</span>: 要建立的套接字类型</span><br><span class="line">procotol: 使用的特定协议</span><br></pre></td></tr></table></figure></li><li><p>初始化服务器端套接字地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line">addrSrv.sin_port = htons(6000)</span><br></pre></td></tr></table></figure></li><li><p>将套接字号和服务器端套接字进行绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能：将套接字地址与所创建的套接字号联系起来。格式：int PASCAL FAR <span class="built_in">bind</span>(SOCKET s,const struct sockaddr FAR * name,int namelen);</span><br><span class="line">参数：s: 是由socket()调用返回的并且未作连接的套接字描述符（套接字号）。</span><br><span class="line">其它：没有错误，<span class="built_in">bind</span>()返回0，否则SOCKET_ERROR</span><br></pre></td></tr></table></figure></li><li><p>接受来自客户端的连接请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOCKET PASCAL FAR accept(SOCKET s,struct sockaddr FAR * name,int FAR * addrlen);</span><br><span class="line">参数：同上</span><br></pre></td></tr></table></figure></li><li><p>数据发送和接受</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：数据的发送与接收</span><br><span class="line">格式：int PASCAL FAR send(SOCKET s,const char FAR * buf,int len,int flags);</span><br><span class="line">int PASCAL FAR recv(SOCKET s,const char FAR * buf,int len,int flags);</span><br><span class="line">参数：buf:指向存有传输数据的缓冲区的指针</span><br></pre></td></tr></table></figure></li><li><p>传输结束，关闭套接字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭套接字――closesocket()</span><br><span class="line">功能：关闭套接字s</span><br><span class="line">格式：BOOL PASCAL FAR closesocket(SOCKET s);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h2><ol><li>建立客户端套接字同上</li><li>将客户端套接字和服务器端地址接受绑定同上</li><li><p>连接服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int PASCAL FAR connect(SOCKET s,const struct sockaddr FAR * name,int namelen);</span><br></pre></td></tr></table></figure></li><li><p>进行数据发送和接受同上</p></li><li>关闭套接字同上</li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>至此,关于Window套接字就介绍完了,虽然不尽详尽,但是我尽可能给大家讲清楚一些基本概念,和一些基本流程.在完全理解后,读者可以参照基于TCP套接字实现的简单Demo一文写一些自己的套接字小Demo.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;套接字原理&quot;&gt;&lt;a href=&quot;#套接字原理&quot; class=&quot;headerlink&quot; title=&quot;套接字原理&quot;&gt;&lt;/a&gt;套接字原理&lt;/h2&gt;&lt;p&gt;本文是续上文关于基于TCP套接字实现的简单Demo后进行套接字基本知识的讲解.&lt;br&gt;可能文中有一些术语使用不太准确
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于最大最小距离的分类数目上限K确定的聚类方法</title>
    <link href="http://yoursite.com/2014/07/20/%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%88%86%E7%B1%BB%E6%95%B0%E7%9B%AE%E4%B8%8A%E9%99%90K%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/</id>
    <published>2014-07-20T14:17:33.000Z</published>
    <updated>2018-09-17T18:35:01.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>聚类是数据挖掘很重要的组成部分.而大多数聚类算法都需要事先确定分类数目K.而本文是在实际情况下确定分类数目K的上限.进而对数据样本进行自动分类.</p><h2 id="原始算法流程"><a href="#原始算法流程" class="headerlink" title="原始算法流程"></a>原始算法流程</h2><p>设样本集为X{x(1),x(2)…….}</p><ol><li>选取任意一个样本作为第一个聚类中心 如z(1)=x(1)</li><li>选取距离z(1)最远的样本点作为第二个聚类中心,设为z(2)</li><li>计算每个样本到z(1),z(2)的距离D(i,1),D(i,2);并选出其中最小的距离T(i)=min(D(i,1),D(i,2))</li><li>在所有样本最小值中选择最大值即max(T);</li><li>若max(T(i))&gt;=θ|z(1)-z(2)|,(θ为事先给定,|z(1)-z(2)|为两聚类中心的距离),则z(3)=x(i),否则无新的聚类中心.则找聚类中心结束,θ可用试探法,只要能将想要的类别识别即可.这里设z(3)=x(7)</li><li>若z(3)存在,则继续步骤3,计算每个样本到z(1),z(2),z(3)的距离D(i,1),D(i,2),D(i,3);并选出其中最小的距离T(i)=min(D(i,1),D(i,2),D(i,3))</li><li>重复步骤4,5直到不满足5的条件,聚类结束.</li><li>假设一共只要三个聚类中心.那么比较每个样本点到三个聚类中心的距离.距离最小者即符合该类,属于该类.</li></ol><h2 id="优化后算法流程"><a href="#优化后算法流程" class="headerlink" title="优化后算法流程"></a>优化后算法流程</h2><p>设样本集为X{x(1),x(2)……..},此样本集最多分为3类,即k=1或k=2或k=3</p><ol><li>首先将样本集合的数据进行升序排序Y(y(1),y(2)…….y(N))</li><li>如果样本集至少存在一个数据,则说明至少存在一类.取排序后的第一个数为第一个聚类中心z(1)=y(1);避免了随机选取带来的不稳定性</li><li>如果排序后的样本集合最后一个元素的值减去第一个元素值&gt;5 即认为存在两类,这里取最后一个元素为第二个聚类中心.z(2)=y(N)<strong><td bgcolor="BlueViolet">这也符合前两个聚类中心距离最远的条件.</td></strong></li><li>再根据最大最小距离判定法则对剩下的聚类中心进行判定.</li></ol><h2 id="matlab仿真："><a href="#matlab仿真：" class="headerlink" title="matlab仿真："></a>matlab仿真：</h2><h5 id="代码历史悠久-不保证能跑起来"><a href="#代码历史悠久-不保证能跑起来" class="headerlink" title="代码历史悠久 不保证能跑起来"></a>代码历史悠久 不保证能跑起来</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">%   load Data1.mat  %加载数据</span><br><span class="line"> ClomStatic=[7,1,3,5,1,56,57,53,24,16,20,21];</span><br><span class="line">len=length(ClomStatic);%求向量ClomStatic的长度</span><br><span class="line"></span><br><span class="line">%如果存在非零长度,则至少为一类.</span><br><span class="line"><span class="keyword">if</span>(len&gt;0)</span><br><span class="line">    k=1;</span><br><span class="line">    Z(k)=ClomStatic(1);         %取第一个位置为第一个聚类中心</span><br><span class="line">    TempZ=ClomStatic(len);</span><br><span class="line"></span><br><span class="line">    %如果最大最小数值差值大于20,则至少存在两类</span><br><span class="line">     <span class="keyword">if</span>(TempZ-Z(1)&gt;=5)</span><br><span class="line">            k=k+1;</span><br><span class="line">            Z(k)=ClomStatic(len);       %取第最后个位置为第二个聚类中心</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        %逐个求出各个样本和聚类中心Z(1),Z(2)之间的距离选出每个点到聚类中心中的较小值</span><br><span class="line">        D=zeros(len,2);</span><br><span class="line">        M=zeros(1,len);</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            D(i,1)=abs(ClomStatic(i)-Z(1));</span><br><span class="line">            D(i,2)=abs(ClomStatic(i)-Z(2));</span><br><span class="line">            M(i)=min(D(i,:));</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        %在M中找出最大值和20(20为聚类间隔,自定义设定),若大于,则产生新的聚类中心,否则无新的聚类中心,判断是否存在第三类</span><br><span class="line">        [m indexm]=max(M);</span><br><span class="line">            <span class="keyword">if</span>(m&gt;0.32*abs(Z(1)-Z(2)))</span><br><span class="line">                k=k+1;      %如果k&lt;3则聚类结束</span><br><span class="line">                Z(k)=ClomStatic(indexm);</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">        %若Z(3)存在</span><br><span class="line">        <span class="keyword">if</span>(k==3)</span><br><span class="line">            %将样本按最近距离分到最近的聚类中心 k=3</span><br><span class="line">            TempDistance=zeros(len,k);</span><br><span class="line">            p1=1;</span><br><span class="line">            p2=1;</span><br><span class="line">            p3=1;</span><br><span class="line">            <span class="keyword">for</span> i=1:len</span><br><span class="line">                <span class="keyword">for</span> j=1:k</span><br><span class="line">                    TempDistance(i,j)=abs(ClomStatic(i)-Z(j));</span><br><span class="line">                end</span><br><span class="line">                [Dis GroupIndex]=min(TempDistance(i,:));</span><br><span class="line">                <span class="keyword">if</span>(GroupIndex==1)%Group保存最终的分类结果</span><br><span class="line">                     Group1(p1)=ClomStatic(i);</span><br><span class="line">                     p1=p1+1;</span><br><span class="line">                 elseif(GroupIndex==2)</span><br><span class="line">                     Group2(p2)=ClomStatic(i);</span><br><span class="line">                      p2=p2+1;</span><br><span class="line">                 elseif(GroupIndex==3)</span><br><span class="line">                     Group3(p3)=ClomStatic(i);</span><br><span class="line">                     p3=p3+1;</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            %求类中心</span><br><span class="line">            ClassCenter=zeros(1,3);</span><br><span class="line">            ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">            ClassCenter(2)=floor(sum(Group2)/length(Group2));</span><br><span class="line">            ClassCenter(3)=floor(sum(Group3)/length(Group3));</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         %将样本按最近距离分到最近的聚类中心 k=2</span><br><span class="line">        TempDistance=zeros(len,k);</span><br><span class="line">        p1=1;</span><br><span class="line">        p2=1;</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            <span class="keyword">for</span> j=1:k</span><br><span class="line">                TempDistance(i,j)=abs(ClomStatic(i)-Z(j));</span><br><span class="line">            end</span><br><span class="line">            [Dis GroupIndex]=min(TempDistance(i,:));</span><br><span class="line">            <span class="keyword">if</span>(GroupIndex==1)                       %Group保存最终的分类结果</span><br><span class="line">                 Group1(p1)=ClomStatic(i);</span><br><span class="line">                p1=p1+1;</span><br><span class="line">             elseif(GroupIndex==2)</span><br><span class="line">                 Group2(p2)=ClomStatic(i);</span><br><span class="line">                p2=p2+1;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        %求类中心</span><br><span class="line">        ClassCenter=zeros(1,2);</span><br><span class="line">               </span><br><span class="line">        ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">        ClassCenter(2)=floor(sum(Group2)/length(Group2));</span><br><span class="line">     end</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">       %k=1;</span><br><span class="line">         j=1;</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            Group1(j)=ClomStatic(i);</span><br><span class="line">            j=j+1;</span><br><span class="line">        end</span><br><span class="line">       %求类中心</span><br><span class="line">        ClassCenter=zeros(1,1);</span><br><span class="line">               </span><br><span class="line">        ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">     end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="仿真结果三类划分："><a href="#仿真结果三类划分：" class="headerlink" title="仿真结果三类划分："></a>仿真结果三类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/1.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/2.png" alt="分类聚类"></p><h2 id="仿真结果二类划分："><a href="#仿真结果二类划分：" class="headerlink" title="仿真结果二类划分："></a>仿真结果二类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/3.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/4.png" alt="分类聚类"></p><h2 id="仿真结果一类划分："><a href="#仿真结果一类划分：" class="headerlink" title="仿真结果一类划分："></a>仿真结果一类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/5.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/6.png" alt="分类聚类"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;聚类是数据挖掘很重要的组成部分.而大多数聚类算法都需要事先确定分类数目K.而本文是在实际情况下确定分类数目K的上限.进而对数据样本进行自动分
      
    
    </summary>
    
      <category term="分类聚类" scheme="http://yoursite.com/categories/%E5%88%86%E7%B1%BB%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="分类聚类" scheme="http://yoursite.com/tags/%E5%88%86%E7%B1%BB%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>基于TCP套接字实现的简单Demo</title>
    <link href="http://yoursite.com/2014/07/18/%E5%9F%BA%E4%BA%8ETCP%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95Demo/"/>
    <id>http://yoursite.com/2014/07/18/基于TCP套接字实现的简单Demo/</id>
    <published>2014-07-18T14:34:29.000Z</published>
    <updated>2018-09-18T14:18:55.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>由于代码的注释已经很详尽了,所以这里不再作过多说明.仅仅贴出代码和结果图.<br>值得注意的是必须先启动server程序再启动client.</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;WINSOCK2.H&gt;    //套接字库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT       6000 //服务器端口</span></span><br><span class="line"><span class="comment">#define MSGSIZE    1024 //收发缓冲区的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma comment(lib, "ws2_32.lib") //链接静态库</span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI FunThread(LPVOID); //创建一个线程，专门用来接收数据</span><br><span class="line"></span><br><span class="line">SOCKET      sClient; //连接所用套节字</span><br><span class="line">SOCKET      sListen; //监听套接字</span><br><span class="line">SOCKADDR_IN client; //保存客户的地址信息</span><br><span class="line">int         iaddrSize = sizeof(SOCKADDR_IN);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    WSADATA     wsaData;        //WSADATA结构体中主要包含了系统所支持的Winsock版本信息</span><br><span class="line">    SOCKADDR_IN <span class="built_in">local</span>;        //定义本地套接字地址</span><br><span class="line">    char        s_Message[MSGSIZE]; //收发缓冲区</span><br><span class="line"></span><br><span class="line">    WSAStartup(0x0202, &amp;wsaData); //初始化套接字库</span><br><span class="line">    </span><br><span class="line">    sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//创建服务器监听套节字。TCP协议</span><br><span class="line">    </span><br><span class="line">    local.sin_family = AF_INET; //AF_INET指明使用TCP/IP协议族</span><br><span class="line">    local.sin_port = htons(PORT);//指明连接服务器的端口号</span><br><span class="line">    local.sin_addr.s_addr = htonl(INADDR_ANY);//自动获取本机地址</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sListen, (struct sockaddr *)&amp;<span class="built_in">local</span>, sizeof(SOCKADDR_IN));//地址绑定到套接字</span><br><span class="line">    </span><br><span class="line">    listen(sListen, 1);//开始监听</span><br><span class="line">    </span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);//建立连接,返回用于连接的套接字</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepte client:%s:%d\n"</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));//输出客户端的IP地址和端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HANDLE hThread=CreateThread(NULL,0,FunThread,0,0,0);//运行至此创建专门的接收线程用于接收客户端发送</span><br><span class="line">                                //的数据,在监听主线程上创建一个新的数据接收线程</span><br><span class="line">    CloseHandle(hThread);//关闭线程句柄</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用于从服务器端向客户端发送数据</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server Send:"</span>);</span><br><span class="line">        //从键盘输入</span><br><span class="line">        gets(s_Message);                        </span><br><span class="line">        //发送数据</span><br><span class="line">        send(sClient, s_Message, strlen(s_Message), 0); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当接收数据时调用此线程函数</span><br><span class="line">DWORD WINAPI FunThread(LPVOID)</span><br><span class="line">&#123;   </span><br><span class="line">    char c_Message[MSGSIZE]; //接收数据缓冲区</span><br><span class="line">    int ret; //接收字节的个数</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;  </span><br><span class="line">        ret = recv(sClient, c_Message, MSGSIZE, 0);//接收数据到缓冲区</span><br><span class="line">        </span><br><span class="line">        //判断是否成功接收,如果未成功接收则重启监听,将原缓冲区的数据归零</span><br><span class="line">        <span class="keyword">if</span>(ret==SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nclient is closed!"</span>);</span><br><span class="line">            </span><br><span class="line">            sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);//重新开始监听</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nAccepte new client:%s:%d"</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line">            memset(c_Message,0,1024);//将原来的client message归零</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c_Message[ret] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nReceived: %s\n"</span>, c_Message); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125;&lt;strong&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;WINSOCK2.H&gt; //套接字库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SERVER_ADDRESS "127.0.0.1" //服务器端IP地址,由于服务也在本地机器上所以用环回地址127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT           6000    //客户端绑定端口     </span></span><br><span class="line"><span class="comment">#define MSGSIZE        1024        //客户端接收数据缓冲区大小    </span></span><br><span class="line"><span class="comment">#pragma comment(lib, "ws2_32.lib") </span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI FunThread(LPVOID); //对于客户端接收数据的线程函数   </span><br><span class="line"></span><br><span class="line">SOCKET      sClient;         //客户端套接字      </span><br><span class="line">SOCKADDR_IN server;           //服务器端套接字</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    WSADATA     wsaData; </span><br><span class="line">    char        c_Message[MSGSIZE]; //数据缓冲区</span><br><span class="line">    </span><br><span class="line">    WSAStartup(0x0202, &amp;wsaData); //初始化套接字库</span><br><span class="line">    </span><br><span class="line">    sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    //创建客户端套接字</span><br><span class="line">    </span><br><span class="line">    memset(&amp;server, 0, sizeof(SOCKADDR_IN));               //先将保存地址的server置为全0</span><br><span class="line">    server.sin_family = PF_INET;                           //声明地址格式是TCP/IP地址格式</span><br><span class="line">    server.sin_port = htons(PORT);                         //指明连接服务器的端口号</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    //指明连接服务器的IP地址</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    connect(sClient, (struct sockaddr *)&amp;server, sizeof(SOCKADDR_IN)); //连到刚才指明的服务器上</span><br><span class="line"></span><br><span class="line">    HANDLE hThread=CreateThread(NULL,0,FunThread,0,0,0);;//客户端开辟接收数据线程</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">    //客户端向服务器发送数据</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client Send:"</span>);</span><br><span class="line">        gets(c_Message);   </span><br><span class="line">        </span><br><span class="line">        send(sClient, c_Message, strlen(c_Message), 0); </span><br><span class="line">        <span class="keyword">if</span>(!strcmp(c_Message,<span class="string">"exit"</span>))//client自身退出</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放连接和进行结束工作</span><br><span class="line">    closesocket(sClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收线程函数</span><br><span class="line">DWORD WINAPI FunThread(LPVOID)</span><br><span class="line">&#123;</span><br><span class="line">    char   s_Message[MSGSIZE];//定义接收缓冲区</span><br><span class="line">    int    ret; </span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = recv(sClient, s_Message, MSGSIZE, 0);//接收服务器端的数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        //判断是否接收</span><br><span class="line">        <span class="keyword">if</span>(ret==SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nServer is closed!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        s_Message[ret] = <span class="string">'\0'</span>;  </span><br><span class="line">        //显示接收数据</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nReceived: %s\n"</span>, s_Message);</span><br><span class="line">        </span><br><span class="line">        //如果服务器端发送<span class="built_in">exit</span>则client退出</span><br><span class="line">        <span class="keyword">if</span>(!strcmp(s_Message,<span class="string">"exit"</span>))//server让client退出</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;&lt;strong&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2014/07/18/基于TCP套接字实现的简单Demo/1.png" alt="网络编程"><br><img src="/2014/07/18/基于TCP套接字实现的简单Demo/2.png" alt="网络编程"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;由于代码的注释已经很详尽了,所以这里不再作过多说明.仅仅贴出代码和结果图.&lt;br&gt;值得注意的是必须先启动server程序再启动client.
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TLV----Demo讲解</title>
    <link href="http://yoursite.com/2014/07/10/TLV-Demo%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2014/07/10/TLV-Demo讲解/</id>
    <published>2014-07-10T10:26:00.000Z</published>
    <updated>2018-09-18T14:14:05.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>接触过网络协议的人对TLV一定或多或少的知道.作为一种自定义应用层标准.TLV使用十分广泛.他对数据封包有着很好的定义,简单实用.</p><p>TLV示意图如下：<br><img src="/2014/07/10/TLV-Demo讲解/1.png" alt="网络编程"></p><p>大家首先要区分数据包和数据报.本文的实例仅仅针对TLV数据包.而并未添加注册一些控制信令和报头形成数据报,而其中实际的数据有TLV包组成.</p><p>TLV数据包和数据报的关系可由下图表示:<br><img src="/2014/07/10/TLV-Demo讲解/2.png" alt="网络编程"></p><p>此外,TLV本身有两种结构,一种是基本TLV结构,另外一种是嵌套TLV结构.而本文使用的是嵌套TLV结构.</p><p>基本TLV包:<br><img src="/2014/07/10/TLV-Demo讲解/3.png" alt="网络编程"></p><p>嵌套TLV包：<br><img src="/2014/07/10/TLV-Demo讲解/4.png" alt="网络编程"></p><p>本文使用嵌套TLV包.<br><img src="/2014/07/10/TLV-Demo讲解/5.png" alt="网络编程"></p><h2 id="编码方法："><a href="#编码方法：" class="headerlink" title="编码方法："></a>编码方法：</h2><ol><li>将类型type用htonl转换为网络字节顺序，指针偏移+4</li><li>将长度length用htonl转换为网络字节顺序，指针偏移+4</li><li>若值value数据类型为int、char、short，则将其转换为网络字节顺序，指针偏移+4；若值为字符串类型，写进后，指针偏移+length</li></ol><h2 id="解码方法："><a href="#解码方法：" class="headerlink" title="解码方法："></a>解码方法：</h2><ol><li>读取type 用ntohl转换为主机字节序得到类型，指针偏移+4</li><li>读取lengh用ntohl转换为主机字节序得到长度；指针偏移+4</li><li>根据得到的长度读取value，若value数据类型为int、char、short，用ntohl转换为主机字节序，指针偏移+4；若value数据类型为字符串类型，指针偏移+length</li></ol><p><strong> <table><tr><td bgcolor="BlueViolet">Type和Length的长度固定，一般那是2、4个字节（这里统一采用4个字节）；Value的长度有Length指定</td></tr></table></strong></p><h2 id="Demo如下-C-实现"><a href="#Demo如下-C-实现" class="headerlink" title="Demo如下(C++实现):"></a>Demo如下(C++实现):</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;WinSock2.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma comment(lib, "WS2_32")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义枚举类型常量，来填充Tpye字段,其中emTlvNRoot填充根TLV包的Type</span><br><span class="line">//emTlvName字段用于填充子TLV字段中名字的Type字段.emTlvAge,emTlvColor类似</span><br><span class="line">//此类型字段是为了TLV包解码时识别到底是哪个TLV包.进而解析出对应的数据.</span><br><span class="line">enum emTLVNodeType</span><br><span class="line">&#123;</span><br><span class="line">    emTlvNNone = 0,</span><br><span class="line">    emTlvNRoot,            //根节点</span><br><span class="line">    emTlvName,            //名字</span><br><span class="line">    emTlvAge,            //年龄</span><br><span class="line">    emTlvColor            //颜色 1 白色 2 黑色</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义要封装成TLV包的数据,包括名字,年龄,颜色。</span><br><span class="line">typedef struct _CAT_INFO</span><br><span class="line">&#123;</span><br><span class="line">    char szName[12];</span><br><span class="line">    int    iAge;</span><br><span class="line">    int iColor;</span><br><span class="line">&#125;CAT_INFO,*LPCAT_INFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//此类为TLC类,其中有四个成员函数,WriteInt和Write是用于</span><br><span class="line">//把原始数据封装为TLV包然后存入内存区块.即TLV包编码过程</span><br><span class="line">//而ReadInt和Read用于把内存区块的TLV包解析出来.即为TLV包的解码过程</span><br><span class="line">class CTlvPacket</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    CTlvPacket(char *pBuf,unsigned int len):</span><br><span class="line">      m_pData(pBuf),m_uiLength(len),m_pEndData(m_pData+len),</span><br><span class="line">          m_pWritePtr(m_pData),m_pReadPtr(m_pData) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="function"><span class="title">CTlvPacket</span></span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool WriteInt(int data,bool bMovePtr = <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = htonl(data);</span><br><span class="line">        <span class="built_in">return</span> Write(&amp;tmp,sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool Write(const void *pDst,unsigned int uiCount)</span><br><span class="line">    &#123;</span><br><span class="line">        ::memcpy(m_pWritePtr,pDst,uiCount);</span><br><span class="line">        m_pWritePtr += uiCount;</span><br><span class="line">        <span class="built_in">return</span> m_pWritePtr &lt; m_pEndData ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool ReadInt(int *data,bool bMovePtr = <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Read(data,sizeof(int));</span><br><span class="line">        *data = ntohl(*data);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool Read(void *pDst,unsigned int uiCount)</span><br><span class="line">    &#123;</span><br><span class="line">        ::memcpy(pDst,m_pReadPtr,uiCount);</span><br><span class="line">        m_pReadPtr += uiCount;</span><br><span class="line">        <span class="built_in">return</span> m_pReadPtr &lt; m_pEndData ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    char *m_pData;</span><br><span class="line"></span><br><span class="line">    unsigned int m_uiLength;</span><br><span class="line"></span><br><span class="line">    char *m_pEndData;</span><br><span class="line"></span><br><span class="line">    char *m_pWritePtr;</span><br><span class="line"></span><br><span class="line">    char *m_pReadPtr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    root L1 V</span><br><span class="line">        T L V T L V T L V</span><br><span class="line"></span><br><span class="line">    L1 的长度即为“T L V T L V T L V”的长度</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//此函数实现TLV编码过程</span><br><span class="line">int TLV_EncodeCat(LPCAT_INFO pCatInfo, char *pBuf, int &amp;iLen)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pCatInfo || !pBuf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CTlvPacket enc(pBuf,iLen);</span><br><span class="line">    enc.WriteInt(emTlvNRoot);</span><br><span class="line">    enc.WriteInt(20+12+12); //length</span><br><span class="line"></span><br><span class="line">    enc.WriteInt(emTlvName);</span><br><span class="line">    enc.WriteInt(12);</span><br><span class="line">    enc.Write(pCatInfo-&gt;szName,12);</span><br><span class="line"></span><br><span class="line">    enc.WriteInt(emTlvAge);</span><br><span class="line">    enc.WriteInt(4);</span><br><span class="line">    enc.WriteInt(pCatInfo-&gt;iAge);</span><br><span class="line"></span><br><span class="line">    enc.WriteInt(emTlvColor);</span><br><span class="line">    enc.WriteInt(4);</span><br><span class="line">    enc.WriteInt(pCatInfo-&gt;iColor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    iLen = 8+20+12+12;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此函数实现TLV解码过程</span><br><span class="line">int TLV_DecodeCat(char *pBuf, int iLen, LPCAT_INFO pCatInfo)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pCatInfo || !pBuf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CTlvPacket encDec(pBuf,iLen);</span><br><span class="line">    int iType;</span><br><span class="line">    int iSum,iLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    encDec.ReadInt(&amp;iType);</span><br><span class="line">    <span class="keyword">if</span> (emTlvNRoot != iType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -2;</span><br><span class="line">    &#125;</span><br><span class="line">    encDec.ReadInt(&amp;iSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //通过判断Type头字段对TLV包进行解析</span><br><span class="line">    <span class="keyword">while</span> (iSum &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        encDec.ReadInt(&amp;iType);//读取主TLV包的<span class="built_in">type</span>头</span><br><span class="line">        encDec.ReadInt(&amp;iLength);//读取主TLV包的length头</span><br><span class="line"></span><br><span class="line">        switch(iType)        //此时buff指针移动到子TLV包.并解析子TLV的<span class="built_in">type</span>头字段</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> emTlvName:</span><br><span class="line">            encDec.Read(pCatInfo-&gt;szName,12);</span><br><span class="line">            iSum -= 20;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> emTlvAge:</span><br><span class="line">            encDec.ReadInt(&amp;pCatInfo-&gt;iAge);</span><br><span class="line">            iSum -= 12;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> emTlvColor:</span><br><span class="line">            encDec.ReadInt(&amp;pCatInfo-&gt;iColor);</span><br><span class="line">            iSum -= 12;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"TLV_DecodeCat unkonwn error. \n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int iRet, iLen;</span><br><span class="line">    char buf[256] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CAT_INFO cat;  //cat为定义的原始数据包括name,age,color</span><br><span class="line">    memset(&amp;cat,0,sizeof(cat));//cat结构体初始化</span><br><span class="line"></span><br><span class="line">    //对cat对象赋值</span><br><span class="line">    strcpy(cat.szName,<span class="string">"Tom"</span>);</span><br><span class="line">    cat.iAge = 5;</span><br><span class="line">    cat.iColor = 2;</span><br><span class="line"></span><br><span class="line">    //实现对cat对象的编码,编码结果存储在buf中.</span><br><span class="line">    iRet = TLV_EncodeCat(&amp;cat,buf,iLen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //TLV编码成功与否的判断</span><br><span class="line">    <span class="keyword">if</span> ( 0 == iRet )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLV_EncodeCat ok, iLen = %d. \n"</span>,iLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLV_EncodeCat error \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将cat结构置为0</span><br><span class="line">    memset(&amp;cat,0,sizeof(cat));</span><br><span class="line"></span><br><span class="line">   //TLV包解码过程,将解包后的数据存入cat结构体对象</span><br><span class="line">    iRet = TLV_DecodeCat(buf,iLen,&amp;cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //输出解包后的结构体数据</span><br><span class="line">    <span class="keyword">if</span> ( 0 == iRet )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLV_DecodeCat ok, cat name = %s, age = %d, color = %d. \n"</span>,cat.szName,cat.iAge,cat.iColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLV_DecodeCat error, code = %d. \n"</span>, iRet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int iWait = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/2014/07/10/TLV-Demo讲解/6.png" alt="网络编程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong> <table><tr><td bgcolor="green">这里要对TLV包长：iLen = 8+20+12+12; 进行说明.为什么是这样呢.<br>因为一个完整的TLV包的主包包含Type字段和Length字段,每个字段占用4个字节所以共八个字节.而主TLV包的Value字段包含三个子TLV包.第一个子TLV包为name，而char szName[12]，加之子包Type和子包Length，所以一共20个字节同理,对于age子包共计八个字节,color子包共计八个字节.所以整个TLV包的长度就为8+20+12+12</td></tr></table></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;接触过网络协议的人对TLV一定或多或少的知道.作为一种自定义应用层标准.TLV使用十分广泛.他对数据封包有着很好的定义,简单实用.&lt;/p&gt;

      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
