<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vpoet&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-18T17:50:34.044Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>vpoet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>能DDoS的勒索木马FireCrypt进一步分析</title>
    <link href="http://yoursite.com/2017/01/05/%E8%83%BDDDoS%E7%9A%84%E5%8B%92%E7%B4%A2%E6%9C%A8%E9%A9%ACFireCrypt%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/</id>
    <published>2017-01-05T03:37:20.000Z</published>
    <updated>2018-09-18T17:50:34.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：<a href="http://www.freebuf.com/articles/system/124618.html" target="_blank" rel="noopener">流氓会武功：这款勒索软件不仅能勒索，还能DDoS</a>。本文进行后续分析。</p><p>经分析，该类样本通过木马生成器自定义生成，运行该样本会对特定文件类型进行AES加密，同时伴随着持续但微弱的DDoS行为(请求特定网站下载文件)。以下是详细的样本分析结果。</p><h2 id="一．样本运行效果"><a href="#一．样本运行效果" class="headerlink" title="一．样本运行效果"></a>一．样本运行效果</h2><p>该样本运行后会加密系统所有盘符下的特定文件类型的文件，加密后会在文件名后加上firecrypt后缀，如下图所示:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/1.png" alt="病毒分析"></p><p>在加密结束后，样本会在桌面生成两个文件分别为xxxx-READ_ME.html和xxxx-filesencrypted.html，xxxx-READ_ME.html是加密后提示给受害用户的解密提示，xxxx-filesencrypted.html是当前受害者电脑所有被加密文件的路径位置信息，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/2.png" alt="病毒分析"><br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/3.png" alt="病毒分析"></p><p>该解密提示界面警告受害者AES密钥的销毁时间，用户需要在密钥销毁之前向特定比特币地址支付500美元赎金以获得AES密钥和解密程序。木马会在每台被加密的机器上生成一个唯一的USER ID用于识别受害机器。</p><p>此外，在文件加密完成后，该木马会创建数个后台线程去固定的某个网站上下载文件到%Temp%目录下，如下图所示：<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/4.png" alt="病毒分析"></p><h2 id="二．样本运行流程"><a href="#二．样本运行流程" class="headerlink" title="二．样本运行流程"></a>二．样本运行流程</h2><p>此木马是基于.NET环境开发，依赖.NET Framework 4.0及以上。通过reflector工具可以对木马进行反编译，从而分析出该木马大致运行流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/5.png" alt="病毒分析"></p><h2 id="三．文件加密分析"><a href="#三．文件加密分析" class="headerlink" title="三．文件加密分析"></a>三．文件加密分析</h2><ol><li>样本首先查找受害电脑的所有盘符:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/6.png" alt="病毒分析"></li></ol><p>然后递归遍历所有系统盘符下的所有文件，查找符合如下后缀名的文件，将这些文件的路径信息加入%AppData%\SysWin32\files.txt，加密文件类型如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/7.png" alt="病毒分析"></p><ol start="2"><li>样本会产生一个32个字符的随机字符串，该随机字符串用于后续AES256密钥的生成:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/8.png" alt="病毒分析"><br>其中随机数产生的算法如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/9.png" alt="病毒分析"></li><li>AES256加密流程如下,Encrypt_Fun方法中调用的AES256_Encrypt为加密的主要函数:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/10.png" alt="病毒分析"><br>AES256_Encrypt方法传入带加密的数据和用于加密的密码，此密码再与一些其它的参数生成真正的密钥，具体流程如下:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/11.png" alt="病毒分析"><br>至此，文件完整的加密流程已经完结了。该样本在加密每个文件的时候都会产生一个32个字符的随机字符串，然后通过该随机字符串去生成AES加密密钥。这样每次加密的密钥都是不同的，但是在整个加密流程前后并未发现木马通过网络将密钥发送给远端的服务器，一旦用户的电脑被此类木马感染后，即使向作者给出的比特币地址支付赎金，仍然无法获取需要解密的AES密钥。<h2 id="四．木马的DDoS行为"><a href="#四．木马的DDoS行为" class="headerlink" title="四．木马的DDoS行为"></a>四．木马的DDoS行为</h2>当加密行为完成后，样本将在后台创建多个线程:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/12.png" alt="病毒分析"><br>在DownloadThread函数中会持续对www[.]pta[.]gov[.]pk/index[.]php发出请求，并将该页面下载到%temp%目录并存储:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/13.png" alt="病毒分析"><br>当样本感染的机器足够多的时候，这种正常的Url请求就会变成DDoS攻击。<h2 id="五．结束任务管理器"><a href="#五．结束任务管理器" class="headerlink" title="五．结束任务管理器"></a>五．结束任务管理器</h2>除了以上的文件加密和DDoS行为，样本还会创建一个Timer，每隔500ms将“taskmgr”进程杀掉:<br><img src="/2017/01/05/能DDoS的勒索木马FireCrypt进一步分析/14.png" alt="病毒分析"><h2 id="六．木马生成器与变种"><a href="#六．木马生成器与变种" class="headerlink" title="六．木马生成器与变种"></a>六．木马生成器与变种</h2>此类通过生成器生成的木马样本，每次生成的样本的哈希值都会发生变化，可以通过不停变种绕过一些仅凭哈希值进行判定的防护措施。不过，此木马并未采取强烈的混淆手段，大多数情况下仍然可以通过静态特征或者动态行为，识别该类生成器产生的木马。</li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日，FreeBuf上对于一类FireCrypt木马做了相关的报道：&lt;a href=&quot;http://www.freebuf.com/arti
      
    
    </summary>
    
      <category term="病毒分析" scheme="http://yoursite.com/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
      <category term="病毒分析" scheme="http://yoursite.com/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第二章-寄存器</title>
    <link href="http://yoursite.com/2016/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/14/汇编语言学习第二章-寄存器/</id>
    <published>2016-04-14T01:56:50.000Z</published>
    <updated>2018-09-17T17:19:37.007Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><p>&ensp;&ensp;&ensp;&ensp;在CPU中，有四种主要的部件。运算器，控制器，寄存器，内部总线。这里的内部总线用于CPU内部进行各种信息的传递，与第一章所讲的控制总线，数据总线，地址总线不同，第一章所描述的总线属于外部总线，作为CPU与外部期间进行信息传递的通路。运算器用于各种信息的处理，寄存器用于信息的处理，控制器用于控制信息的处理。对于利用汇编编程来说，寄存器是主要操作的部件，不同的CPU中寄存器的个数和种类是不同的，8086CPU寄存器个数为14个AX,BX,CX,DX,CS,SS,DS,ES,SI,DI,SP,BP,IP,PSW。</p><h2 id="2-1-通用寄存器和字在寄存器中的存储"><a href="#2-1-通用寄存器和字在寄存器中的存储" class="headerlink" title="2.1 通用寄存器和字在寄存器中的存储"></a>2.1 通用寄存器和字在寄存器中的存储</h2><p>&ensp;&ensp;&ensp;&ensp;8086CPU所有的寄存器均为16位，其中AX,BX,CX,DX这四个寄存器一般作为通用的寄存器使用，用于存储一般的数据。16位寄存器能存储的最大值为2^16=65536，在8086CPU寄存器之前有很多8位的寄存器的CPU，为了和以前在8位寄存器下写的程序相兼容，8086CPU将16位寄存器可分为高八位和低八位的寄存器使用。</p><p>&ensp;&ensp;&ensp;&ensp;以AX寄存器为例，其逻辑结构如下图所示，从做到右依次为高位到低位。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/1.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;比如我们存储一个数据2000H(后缀H,hex代表16进制)，其二进制位10000000000000B(B,binary代表二进制),我们将该数据存入AX中为:</p><pre><code>0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0</code></pre> <p>&ensp;&ensp;&ensp;&ensp;当我们将AX分为两个8位寄存器的时候为:AH(AX High 8-BIT),AL(AX Low-BIT)。<br>&ensp;&ensp;&ensp;&ensp;类似的BX,CX,DX分成8位寄存器为:BH和BL，CH和CL，DH和DL<br>&ensp;&ensp;&ensp;&ensp;一个字节代表8位二进制位，一个字代表两个字节即16位二进制位。当存储一个字节的时候可以将其存储在寄存器的高8位或者低8位，当存储一个字的时候需要将该字的高字节存储在寄存器的高8位，将该字的低字节存储在寄存器的低8位。</p><h2 id="2-2-一些汇编指令和物理地址"><a href="#2-2-一些汇编指令和物理地址" class="headerlink" title="2.2 一些汇编指令和物理地址"></a>2.2 一些汇编指令和物理地址</h2><ol><li>mov ax,12h与MOV AX,12H是一样的效果，汇编指令不区分大小写</li><li><p>若ax和bx当前存储的值都是8226H，当执行add ax,bx的时候其结果应该为1044CH，但是存储结果的寄存器ax为16位而1044CH位20位，所以进位的1不能存储(当可以影响进位标识寄存器)，相加后的ax存储的值为044CH</p></li><li><p>指令add al,93h,执行器al中的数据为C5H，相加之后为158H。但是你会以为在al中存储58H，同时将最高位的1存储在ah中，那么这样理解你就错了，因为当汇编指令使用8位寄存器的时候，是作为独立的寄存器使用与其高位寄存器是无关的。所以ax中的值为0058h.</p></li><li>在进行运算和数据传送的时候。寄存器的位数必须一致，不能出现mov ax,bl或者add bh,ax之类的指令。</li><li>在第一章已经介绍过，计算机内的所有存储区都是通过进行统一进行编制的，其寻址是通过地址总线进行寻址，每个存储区单元都有唯一的地址进行寻址，这个地址我们称为物理地址。</li></ol><h2 id="2-3-16位机和8086进行寻址的方法"><a href="#2-3-16位机和8086进行寻址的方法" class="headerlink" title="2.3 16位机和8086进行寻址的方法"></a>2.3 16位机和8086进行寻址的方法</h2><p>&ensp;&ensp;&ensp;&ensp;16位机代表CPU内部进行运算和寄存的位数为16位，即CPU内部的运算器一次性能进行16位数据的运算，CPU内部的寄存器最大能存储16位数据单元。8086CPU有20条地址总线进行寻址，那么问题来了，CPU在进行寻址的时候地址信息会先存储在CPU内部，但是8086CPU内部最大可以存储16位地址信息，那么怎么来对20位地址进行存储呢。</p><p>&ensp;&ensp;&ensp;&ensp;其解决办法是在内部通过一个加法器将两个16位地址合成20位地址来进行存储区寻址。其示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/2.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;8086CPU内部的寄存器提供两个16位的地址，通过地址加法器合成一个20位的地址，进而通过输入输出电路将20位地址经由地址总线传送到外部存储区进行寻址。<br>&ensp;&ensp;&ensp;&ensp;两个16位地址通过地址加法器合成20位地址的示意图如下：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/3.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;地址加法器计算公式:<font color="#0099ff">20位物理地址=16位段地址<em>16+16位偏移地址</em></font>。这里简单解释一下，对于二进制数据来讲当进行移位操作的时候，左移动一位相当于2, 地址1230H*16即向左移位4位，变为12300H。这时候再加上偏移地址00C8H，结果为123C8H，该地址即为我们合成后的20位物理地址。<br>&ensp;&ensp;&ensp;&ensp;举个例子来说明这一问题,学校，体育馆，图书馆位于一条直线上，学校位于这条线的起点。示意图如下:<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/4.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;如果路人问路，图书馆在哪儿，那么可以有如下两种方式回答:</p><ol><li>从学校直走2826m即可达到图书馆</li><li>从学校直走2000m到达体育馆，再直走826m达到图书馆<br>第一种方法是直接给出图书馆的物理地址(直接地址)，第二种方式是通过体育馆作为中介间隔告诉图书馆的位置。</li></ol><p>&ensp;&ensp;&ensp;&ensp;进一步来想，如果只能通过纸条告诉路人图书馆得位置。但是只有两张可以写三位数的纸条，此时怎么办呢，那么我们可以在第一张纸条上写上200作为段地址，第二张纸条写上826作为偏移地址。那么我们可以通过:段地址200*10+偏移地址826=2826来获知图书馆的位置。</p><h2 id="2-4-段的概念和段寄存器"><a href="#2-4-段的概念和段寄存器" class="headerlink" title="2.4 段的概念和段寄存器"></a>2.4 段的概念和段寄存器</h2><p>&ensp;&ensp;&ensp;&ensp;首先要明确一个概念，内存并没有分段，是CPU在寻址的时候进行分段的，如图所示：<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/5.png" alt="汇编语言学习第二章-寄存器"><br>&ensp;&ensp;&ensp;&ensp;我们可以认为10000H-100FFH组成一个段，该段的起始地址为10000H，段地址为1000H,大小为100H,我们也可以认为10000H-1007FH和10080H-100FFH位两个段，两个段的起始地址分别为10000H和10080H，段地址为1000H和1008H，段的大小为80H。如果一个段的偏移地址长度为N位，那么这个段的大小为2^N。</p><p>&ensp;&ensp;&ensp;&ensp;前面讲过CPU内部提供两个16位的地址通过加法器合成20位物理地址，那么提供16位段地址的部件是什么呢，显然是CPU内部的寄存器啦，8086CPU内部有四个段寄存器分别为CS,SS,DS,ES</p><h2 id="2-5-CS和IP"><a href="#2-5-CS和IP" class="headerlink" title="2.5 CS和IP"></a>2.5 CS和IP</h2><p>&ensp;&ensp;&ensp;&ensp;CS和IP作为两个非常重要寄存器，其中CS为代码段寄存器，IP为偏移量，通过公式CS<em>16+IP便可合成CPU当前要读取指令的物理地址。比如当前CS中存储为M，IP存储为N，那么CPU将从M</em>16+N的合成地址中取一条指令执行。<br><img src="/2016/04/14/汇编语言学习第二章-寄存器/6.png" alt="汇编语言学习第二章-寄存器"><br>通过CS和IP合成当前指令并取指令的逻辑图如上图所示。主要步骤如下:</p><ol><li>将CS和IP送入地址加法器合成20位物理地址为2000H*16+0000H=20000H</li><li>通过输入输出控制电路将20位物理地址送到地址总线进行寻址</li><li>将寻址到的汇编指令mov ax,0123H对应的机器码0123B8H依次通过数据总线传输到CPU中的指令缓冲器中。</li><li>执行指令，此时IP=IP+执行指令的长度，跳转步骤1.<br><strong><table><tr><td bgcolor="BlueViolet">说明一点，8086CPU加点复位后，CS和IP分别被设置为CS=FFFFH，IP=0000H，即开机后的第一条执行指令地址为FFFF0H。</td></tr></table></strong></li></ol><h2 id="2-6-修改CS和IP，代码段的介绍"><a href="#2-6-修改CS和IP，代码段的介绍" class="headerlink" title="2.6 修改CS和IP，代码段的介绍"></a>2.6 修改CS和IP，代码段的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;CS与IP组成CPU当前执行指令的位置，可以通过修改CS与IP改变CPU执行指令的顺序。然而问题来了，如何改变CS与IP 的值呢，这里要注意的是不能使用MOV指令改变CS和IP寄存器的值，因为8086CPU没有提供这样的功能。其实修改CS与IP的值方式有很多种，这里仅介绍jmp。 jmp 段地址:偏移地址 可改变CS与IP寄存器中的值，从而完成CPU执行指令顺序的跳转。比如jmp 12:34 这里CS=0012H IP=0034H 执行jmp 12:34之后将直接跳转到00154H处取指令执行。若仅仅想改变IP的值不改变CS的值，可以使用jmp 某一个合法寄存器  </p><ul><li>代码段为存放代码的一段内存区域，比如如下一段汇编代码：<pre><code>mov ax,0000add ax,123Hmov bx,axjmp bx</code></pre></li></ul><p>以上一段代码段存储在内存为123B0H-123B9H这段内存区域中，共十个字节，那么我们可以成为这段内存区域为代码段，前面已经介绍过要执行这段代码要把CS：IP指向mov ax，0000的内存区域即可。</p><h2 id="本章完结"><a href="#本章完结" class="headerlink" title="本章完结"></a>本章完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习第一章-基础知识</title>
    <link href="http://yoursite.com/2016/04/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/04/13/汇编语言学习第一章-基础知识/</id>
    <published>2016-04-13T08:26:04.000Z</published>
    <updated>2018-09-17T17:19:57.343Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽"><a href="#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽" class="headerlink" title="本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽"></a>本博文系列参考自&lt;&lt;汇编语言&gt;&gt;第三版，作者:王爽</h5><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>&ensp;&ensp;&ensp;&ensp;所谓机器语言则是直接能被机器理解和执行的语言。计算机的核心处理部件为CPU，然而CPU往往只能直接识别机器语言，机器语言为一系列用二进制0,1码代表的机器指令。当然指令集合的差别与具体的CPU有关，AMD与Intel的指令集显然是不同的。然而要直接用二进制的机器语言去描述一段程序或者解决一个问题往往是很困难的。<br>比如说，我们要做这样一个运算s=768+12288-1280:<br><br>&ensp;&ensp;&ensp;&ensp;那么在8086cpu中其用机器语言表述的二进制代码为(机器码):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101110000000000000000011</span></span><br><span class="line"><span class="number">000001010000000000110000</span></span><br><span class="line"><span class="number">001011010000000000000101</span></span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;就这样一个简单的算术运算其机器码就让人头晕目眩，可想而知，如果直接用机器语言进行更为复杂程序的编写，其难度和对视力都是一个极大的考验。    </p><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><p>&ensp;&ensp;&ensp;&ensp;所以为了减轻程序员编程的难度，后来又相继发展了很多语言，比如汇编语言，C语言，C++以及java等语言。其中汇编语言属于低级语言，除此之外均为高级语言。汇编语言将机器语言中晦涩难懂的二进制代码用一些指令助记符进行表示，这样大大降低了程序员编写程序的难度。<br><br>&ensp;&ensp;&ensp;&ensp;比如，机器指令1000100111011000表示将寄存器BX的内容送到寄存器AX中，用汇编语言表述即为mov ax,bx 这样的表示方法不仅清晰易懂而且简洁。那么问题来了，计算机是不能识别mov指令的，那么在汇编程序与CPU之间就需要一个转化的工具，将简洁易懂的汇编语言转换为机器可以理解并执行的机器语言。这个转化工具即为汇编编译器。<br><br>&ensp;&ensp;&ensp;&ensp;用汇编语言编写程序的过程如下:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/1.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul><li>汇编指令:对应机器指令的助记符(核心)</li><li>伪指令：由汇编编译器识别，没有对应的机器指令</li><li>其他符号:如+-*/等，由编译器识别，没有对应的机器指令</li></ul><h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>&ensp;&ensp;&ensp;&ensp;CPU要完成一系列规定的操作，需要两个重要的元素，一是指令(做什么操作)，另外一个是数据(对什么做操作) 。计算机中的很多地方都存储有我们需要的处理的数据，比如内存，比如硬盘，比如寄存器。但是这里要注意的是，CPU要取得需要处理的数据需要将硬盘上的传入内存才能拱CPU调用。</p><h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>&ensp;&ensp;&ensp;&ensp;指令和数据都是在内存上的二进制信息，CPU赋予不同的二进制于数据或者指令的意义。例如：内存中二进制信息1000100111011000,计算机可以把它看作大小为89D8H的数据来处理，也可以理解为mov ax,bx.这里我们要明白一个概念就是内存上的指令和数据的区别是又计算机识别的，就其表现形式来说都是二进制代码，无差。</p><h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的信息是按字节存储的，每个字节代表8位二进制位。对于128个存储单元的存储器来说，我们可以认为其容量为128字节。当然大容量的存储器还有以下一些换算关系：</p><pre><code>1KB=1024B 1M=1024KB 1G=1024MB 1TB=1024GB</code></pre><h2 id="1-7-CPU对存储单元的读写"><a href="#1-7-CPU对存储单元的读写" class="headerlink" title="1.7 CPU对存储单元的读写"></a>1.7 CPU对存储单元的读写</h2><p>&ensp;&ensp;&ensp;&ensp;计算机中的存储单元都是从零编号，每个存储单元都有自己的编号，我们可以称之为地址。这个地址唯一标识一个存储单元。CPU想要从某个存储单元中读取数据，那么就要通过该地址进行寻址。<br>计算机中包括三类总线：地址总线，数据总线，控制总线。CPU通过这三类总线与外部存储设备进行数据交互和控制。其中地址总线用于传输寻址存储器的地址，数据总线用于从寻址到的存储器进行读写数据，控制总线进行器件的选择和读写命令的控制。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/2.png" alt="汇编语言学习第一章-基础知识"><br>&ensp;&ensp;&ensp;&ensp;图中地址总线传输三号地址进行寻址，控制总线发送内存读取命令对三号地址存储器中的信息进行读取，数据总线将三号地址存储器中的08传送的CPU。<br>对于8086CPU，下面的机器码，能够完成从三号内存地址单元读取数据。<br>机器码:<pre><code>101000010000001100000000</code></pre>  <br>含义：从三号地址内存单元读取数据到寄存器AX<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编指令：<span class="keyword">mov</span> AX,[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了寻址空间的大小，比如16位地址总线，每位地址总线代表高低电平两个状态，那么16为地址总线代表了2^16种状态，2^16=65536byte 即65536/1024=64kB<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/3.png" alt="汇编语言学习第一章-基础知识"><br>上图为对地址为1101000000的内存单元寻址示意。</p><p>##1.9 数据总线<br>&ensp;&ensp;&ensp;&ensp;CPU通过数据总线和外部存储器进行数据传递，数据总线的大小决定了传输的速度，比如8位数据总线一次性可传输8位数据，16位数据总线一次性可传输16位数据。8088CPU数据总线为8位，8086CPU数据总线为16位。<br>举个例子，分别以8位和16位数据总线向内存中写入89D8如图所示:<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/4.png" alt="汇编语言学习第一章-基础知识"><br><img src="/2016/04/13/汇编语言学习第一章-基础知识/5.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>&ensp;&ensp;&ensp;&ensp;cpu通过控制总线对外部器件进行控制，有多少根控制总线就可以有多少总控制，比如对内存的读写代表两种控制命令。</p><h2 id="1-11-内存空间概述，主板，接口卡"><a href="#1-11-内存空间概述，主板，接口卡" class="headerlink" title="1.11 内存空间概述，主板，接口卡"></a>1.11 内存空间概述，主板，接口卡</h2><p>&ensp;&ensp;&ensp;&ensp;地址总线的位数决定了内存寻址空间的大小，比如10位地址总线，可寻址2^10=1024byte的地址。每台计算机都有主板，主板上的各种器件(CPU，内存，外围芯片，扩展槽)通过地址总线，控制总线和数据总线链接。在计算机中，CPU不能直接对外部设备进行控制，对外部设备直接控制的是接口卡，接口卡插在扩展槽上，扩展槽与CPU通过总线相连，进而CPU通过对扩展槽上的接口卡控制达到对外设控制的目的。</p><p>##1.12 各类存储器芯片<br>&ensp;&ensp;&ensp;&ensp;存储器包括两大类随机存储器(RAM)和只读存储器(ROM).其中随机存储器用于存储CPU运行所需的程序和数据，不过掉电之后，RAM存储器中的数据和程序会丢失。只读存储器只能读取其中的数据不能改写其中的数据。<br>其中RAM包括主板上的RAM，扩展槽上的RAM和接口卡上的RAM(比如显存)<br>另外装有BIOS的ROM，例如主板上的ROM，显卡上的ROM等。<br>计算机中各类存储器的逻辑连接情况。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/6.png" alt="汇编语言学习第一章-基础知识"></p><h2 id="1-13-内存地址空间"><a href="#1-13-内存地址空间" class="headerlink" title="1.13 内存地址空间"></a>1.13 内存地址空间</h2><p>&ensp;&ensp;&ensp;&ensp;虽然在1.12中介绍了很多存储器，但是他们都是通过地址总线与CPU相连的，另外CPU这些存储器读写的时候都是通过控制总线发送读写命令。很重要的一点是，CPU将对这些存储器统一编址，这样就可以在一个地址空间里对计算机中的所有存储器进行寻址。<br><img src="/2016/04/13/汇编语言学习第一章-基础知识/7.png" alt="汇编语言学习第一章-基础知识"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot;&gt;&lt;a href=&quot;#本博文系列参考自-lt-lt-汇编语言-gt-gt-第三版，作者-王爽&quot; class=&quot;headerlink&quot; title=&quot;本博文系列参考自&amp;lt;&amp;lt;汇编语言&amp;g
      
    
    </summary>
    
      <category term="汇编语言学习" scheme="http://yoursite.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="汇编语言学习" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于在函数中返回动态分配的内存</title>
    <link href="http://yoursite.com/2015/08/31/%E5%85%B3%E4%BA%8E%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2015/08/31/关于在函数中返回动态分配的内存/</id>
    <published>2015-08-31T08:50:17.000Z</published>
    <updated>2018-09-17T18:13:10.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.有以下题目:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char* p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们期望的输出是:ThunderDownloader,然而当我们运行此段代码的时候发现，程序崩溃了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们深入分析下不难发现，当我们传入str到GetMemeory()函数中的时候，该函数我们创建了一个临时的指针变量片p，然后将其指向NULL。然后我们为临时指针变量p动态分配内存，注意，当我们在返回的时候整个临时指针变量是释放掉的，因为其内存是在栈内存中分配的。但是我们之前传入的str的内存地址与临时变量的内存地址是不相同的。所以此时str不能获取在函数GetMemmory分配的内存，因此后面的字符串复制和链接操作都将造成程序崩溃。</p><p>我们可以用下面的图形更加生动的这一过程:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/1.jpg" alt="C++"></p><p>假设str本身内存为0x123  临时指针变量p的内存为0x456  动态分配的内存起始地址为0x789当GetMemory函数结束的时候p被释放，而再也无指针指向这块动态分配的内存了。另外str也不可能获取这段动态分配的内存的地址。所以也造成了内存泄露。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>我们可以用如下两种方法解决这一问题:</p><p>一种是二级指针:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char** p)</span><br><span class="line">&#123;</span><br><span class="line">    (*p)=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(&amp;str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图为:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/2.png" alt="C++"><br>关于二级指针的方法可以参考如下的流程图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/3.jpg" alt="C++"></p><p>另一种是指针的引用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GetMemeory(char*&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    p=(char*)malloc(sizeof(char)*100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str=NULL;</span><br><span class="line">    GetMemeory(str);</span><br><span class="line">    strcpy(str,<span class="string">"Thunder"</span>);</span><br><span class="line">    strcat(str,<span class="string">"Downloader"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行截图:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/4.png" alt="C++"><br>关于指针引用方法的流程图如下:<br><img src="/2015/08/31/关于在函数中返回动态分配的内存/5.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1.有以下题目:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcat函数的坑点</title>
    <link href="http://yoursite.com/2015/08/30/strcat%E5%87%BD%E6%95%B0%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>http://yoursite.com/2015/08/30/strcat函数的坑点/</id>
    <published>2015-08-30T13:11:12.000Z</published>
    <updated>2018-09-18T16:37:54.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们先看下面这样一段代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1= <span class="string">"123"</span>;</span><br><span class="line">    char *p2= <span class="string">"ABC"</span>;</span><br><span class="line">    char str[50]= <span class="string">"xyz"</span>;</span><br><span class="line">    strcat(p1,p2);</span><br><span class="line">    strcpy(str+2,p1);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>乍一看，这段代码的原意是将p2链接到p1的后面，p1为123ABC,然后将str字符数组向后移动两个位置，将p1拷贝到从该位置开始之后的内存中。结果为xy123ABC</p><p>然而我们运行一下这段代码发现程序崩溃了，我们调用堆栈发现函数定位在这一行:<br><img src="/2015/08/30/strcat函数的坑点/1.png" alt="C++"></p><p>这是怎么回事</p><p>赶紧再查查strcat函数的用法，发现当链接p1和p2字符串的时候，将链接的字符串一起存入p1中，那么就隐含了这么个意思，就是说P1的大小必须要容得下链接后的字符串。但是本质上是字符串”123”是保存在程序中的常量区，而常量区只能进行读操作不能进行写操作</p><p>那么我们在栈区定义一个较大的数组来保存连接后的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p1[20]=<span class="string">"123"</span>;</span><br></pre></td></tr></table></figure></p><p>现在我们再运行下看看结果:<br><img src="/2015/08/30/strcat函数的坑点/2.png" alt="C++"><br>这下果然正确了</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们先看下面这样一段代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C与C++中的const</title>
    <link href="http://yoursite.com/2015/07/30/C%E4%B8%8EC%E8%89%B9%E4%B8%AD%E7%9A%84const/"/>
    <id>http://yoursite.com/2015/07/30/C与C艹中的const/</id>
    <published>2015-07-30T14:07:54.000Z</published>
    <updated>2018-09-18T16:44:41.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同样，有下面一段代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int i = 0; </span><br><span class="line">    int *j = (int *) &amp;i; </span><br><span class="line">    *j = 1; </span><br><span class="line">    cout&lt;&lt;<span class="string">"i address = 0x"</span>&lt;&lt;hex&lt;&lt;&amp;i&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="string">"j address = 0x"</span>&lt;&lt;hex&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"i value = "</span>&lt;&lt;i&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="string">"j value = "</span>&lt;&lt;*j&lt;&lt;endl;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在C++编译器中运行如下:<br><img src="/2015/07/30/C与C艹中的const/1.png" alt="C++"></p><p>我们发现const关键字严格遵守了其关于常量的定义。然而疑问出来了为什么相同的地址会输出不同的值。</p><p>同样的代码我们放入C编译器中运行会发现输出结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i value = 1,j value =1</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是为什么呢？</p><p>以下是我自己的一点理解:</p><ol><li>C语言中const为不可改变的变量，其实质仍然是变量，仍然会在编译期间分配内存，那么我们可以获取该内存并修改该内存处的值。这样虽然不允许直接对const 变量修改，但是间接修改该内存位置的值达到修改该变量的效果。</li><li>C++中const关键字定义的是常量类型，在编译的期间直接确定了其值，比如我们<br>可进行如下操作在C++中 编译是可以通过的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const int size=5;</span><br><span class="line">2 int array[size];</span><br></pre></td></tr></table></figure></li></ol><p>表明在编译的时候size是已经确定了。然而这种情况在C语言的情况下是绝对不可以编译通过的，其实我猜，当我们在c++中定义一个const类型的变量的时候，编译器也是要为其分配内存的，只不过在编译阶段遇到时候直接替换，在运行的时候，该常量的值是直接存在某个寄存器中，这样运行代码中需要用到该值时直接可从寄存器中索取，而非在内存中索取。</p><p>那么，我们可以作这样一种测试，我们把const前面加上volatile关键字防止编译器直接从寄存器中取常量值，而是从内存中取，代码如下:<br><img src="/2015/07/30/C与C艹中的const/2.png" alt="C++"></p><p>我们发现此时，const类型变量i的值是已经被改变了，则证明我猜想的思路也许是对的，又或许编译器用了更复杂的方式处理，但是大概思路应该是这样吧!</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>前面说了那么多无非有以下两点:</p><table><tr><td bgcolor="green">1. C C++中的const变量是都要分配内存的。<br>2. C++只不过在编译的时候直接进行变量替换，同时在运行过程中直接在寄存器中取const变量的值，这是C++编译器优化的结果。<br>3. 而对于C语言而言每次const使用都是直接从内存中取值，这样每次const变量的间接改变都能得到反映。</td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;同样，有下面一段代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C艹对象模型浅析</title>
    <link href="http://yoursite.com/2015/07/28/C%E8%89%B9%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2015/07/28/C艹对象模型浅析/</id>
    <published>2015-07-28T03:39:09.000Z</published>
    <updated>2018-09-17T18:03:54.860Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"><a href="#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。" class="headerlink" title="本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。"></a>本文仅代表博主自己对C++内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。</h5><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp;&ensp;&ensp;&ensp;就如<strong>《深度探索C++对象模型》</strong>一书中介绍的C++的封装并没有给C++带来过多的开销。然而面向对象的编程方法却给广大的编程者提供了一种更为开阔的编程思路。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;好，我们主要看看前面一句。开销是什么，这里的开销主要指C++类所占内存的空间。首先,我们看这样一个例子，我们定义一个结构体和类，结构体和类中含有相同的数据成员。除此之外再无其他。我们看看这个结构体和类的大小是多少:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/1.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">看来只要数据成员相同,那么就算声明为类,也不会带来额外的内存开销。</td></tr></table></strong></p><p>&ensp;&ensp;&ensp;&ensp;现在我们再看一个例子，我们让类B更加复杂一下，我们添加一个静态成员变量和，一个静态成员函数，一个非静态成员函数，一个虚函数:我们再看看这个例子的结果将是什么样的结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">    static int d;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static void fun1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a static fun1."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void fun2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is ordinary fun2."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void fun3()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"This is a virtual fun3."</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(A)="</span>&lt;&lt;sizeof(A)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"sizeof(B)="</span>&lt;&lt;sizeof(B)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果:<br><img src="/2015/07/28/C艹对象模型浅析/2.jpg" alt="C++"><br>在这里我们增加了一个静态数据成员d，一个静态成员函数fun1，非静态的成员函数fun2一个虚函数fun3.不难发现就类的代码规模来说，的确增加了不少，然而结果仅仅比之前增加了四个字节的开销。<table><tr><td bgcolor="red">《深度探索C++对象模型》中有这样一句话说C++封装所带来的开销主要来源于虚函数。</td></tr></table></p><p>那么我们可以先看看结构体A的内存分布:可以产生结构体A的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *a;</span><br><span class="line">a=new A;</span><br></pre></td></tr></table></figure></p><p>对象a的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/3.jpg" alt="C++"><br>显然a中有三个整型数据元素a,b,c刚好12个字节</p><p>现在我们看看类B的内存分布</p><p>可以产生类B的一个对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B *b;</span><br><span class="line">b=new B;</span><br></pre></td></tr></table></figure></p><p>对象B的内存结构如下:<br><img src="/2015/07/28/C艹对象模型浅析/4.jpg" alt="C++"><br><strong> <table><tr><td bgcolor="BlueViolet">可以看到尽管类B封装的很多的内容，但是较之A而言仅仅多了一个__vfptr，我们不禁回忆起前面的一句话，C++的封装的开销主要来自于虚函数。其实如果对C++有一定了解的同学都不难猜出，这个ptr其实就是一个虚表指针。正因为这个虚表指针给封装带来了额外的4个字节的开销。</td></tr></table></strong></p><p>那么虚表指针是什么呢，虚表指针其实就是指向虚函数表的一个指针。当一个类中有虚函数的时候，类会自动生成一个指针，该指针保存的是该类中第一个虚函数的地址。所以就算有多个虚函数仍然只需要保存一个虚表指针，然后通过这个指针逐个遍历就可以取得各个虚函数的地址。然而关于虚函数在C++中功能特性我们留待下次一起学习了。<br><img src="/2015/07/28/C艹对象模型浅析/5.jpg" alt="C++"></p><p><br><br>这下一目了然了吧。<br>那么我们可以总结一下影响类的内存开销主要有以下几个方面:</p><table><tr><td bgcolor="BlueViolet">1. 非静态的数据成员<br>2. 虚函数表指针<br>3. 当然既然类也是要考虑内存对齐的。 </td></tr></table><p>还有几点需要注意:<br><strong>1.类的静态数据成员存储在全局变量区，不带来C++内存开销,该静态数据成员属于整个类的不属于具体某个对象，其初始化要在类外进行。<br>2.类的静态成员函数是属于整个类的，不属于某个对象，不会带来内存开销。注意类的静态成员函数中不能调用非静态的成员变量。<br>3.类的普通成员函数始终在程序的代码区中保存一份，不带来内存开销.</strong></p><p>最后再通过一张图片只管展示结构体A和类B的内存布局:<br><img src="/2015/07/28/C艹对象模型浅析/6.jpg" alt="C++"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot;&gt;&lt;a href=&quot;#本文仅代表博主自己对C-内存对象模型的一点理解，本博文只对博主自己负责，不对任何人负责。&quot; class=&quot;headerlink&quot; title=&quot;本文仅代
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题3.二维数组中的查找</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%983-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题3-二维数组中的查找/</id>
    <published>2015-07-20T14:35:32.000Z</published>
    <updated>2018-09-17T17:49:58.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断该数组中是否有该整数。</p><p>算法流程如下:<br>比如一个二维数组array:</p><pre><code>1 2 8 92 4 9 124 7 10 136 8 11 15</code></pre><p>1.这个二维数组的左上角是最小的数据,右下角为最大的数，首先判断查找的数是否number&lt;array[0][0]或number&gt;array[1][1]<br>2.当number的大小在数组范围内再开始查找,找数组的右上角或者左下角开始作为比较的基准,当选择左上角的时候，假设我们查找的为number=7<br>3.如果numbe&lt;9，说明number比最后一列都小,再比较无意义<br>这时候数组为:</p><p><pre><code>1 1 2 8<br>2 2 4 9<br>3 4 7 10<br>4 6 8 11<br></code></pre><br>4.我们再取右上角的8作为基准，8大于7,再去掉最后一列</p><p><pre><code>1 2<br>2 4<br>4 7<br>6 8</code></pre><br>5.我们再取右上角的2作为基准，2&lt;7那么，说明第一行再比较无意义，去掉第一行</p><p><pre><code>2 4<br>4 7<br>6 8</code></pre><br>6.我们再把右上角的4作为基准，4&lt;7那么,去掉第一行</p><p><pre><code>4 7<br> 6 8<br></code></pre><br>7.现在我们再比较右上角元素，7==7 恩 找到了。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool Find(int* matrix,int rows,int columns,int number)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(number&gt;matrix[rows*columns-1]||number&lt;matrix[0])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    i=0;</span><br><span class="line">    j=columns-1;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(1)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(number&gt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;matrix[i*4+j])</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(number==matrix[i*columns+j])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j&lt;0||i&lt;0||i&gt;3||j&gt;3)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点注意:</p><p><strong> <table><tr><td bgcolor="BlueViolet">1.查找的时候有的同学可能会问能不能不从右上角开始作为基准。答案是肯定的，但是只能从右上角和左下角作为基准，为什么？因为我们选择的基准必须在某个维度上是最大的在某个维度上是最小的，不然我们就不能根据比较的结果决定是否去掉一行或者去掉一列<br>2.查找的结束条件是，当我们的右上角元素索引值只要有一个维度的索引值不在二维数组的正常索引范围内就说明需要查找的元素不在这个数组中。<br><br>尤其是第一点,希望读者好好理解。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题2.实例Singleton模式</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%982-%E5%AE%9E%E4%BE%8BSingleton%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题2-实例Singleton模式/</id>
    <published>2015-07-20T13:16:21.000Z</published>
    <updated>2018-09-17T17:39:31.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个类,我们只能生成该类的一个实例</p><p>这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只能生成一个类的实例。那么我们不难考虑到下面几点:</p><ol><li>不能new多个对象，那么必然该类的构造函数是私有的</li><li>类对象只有一个，那么必然该对象只能有一个私有的静态成员变量，该成员变量为类实例或者类实例的指针。</li><li>但是我们同时还要考虑到如果获取这个唯一对象实例,那么该类必然有一个公有的成员函数来获取这个唯一的类实例然    而由于不允许new对象,那么必须提供一种类操作该接口的方式,很显然就是静态成员函数。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>至此不难写设计出这样一个类:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingle</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    CSingle()  //私有构造函数,禁止new对象实例</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static CSingle *m_pInstance;  //私有静态全局变量,保证唯一性</span><br><span class="line">public:</span><br><span class="line">    static CSingle * GetInstance()  //提供一个共有接口获取该唯一类实例</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance == NULL)</span><br><span class="line">            m_pInstance = new CSingle();</span><br><span class="line">        <span class="built_in">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>那么我们构造这个唯一实例是这样的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSingle *Single=CSingle::GetInstance();//当该唯一实例不存在时,这是唯一获取类实例的方法。</span><br><span class="line">CSingle *Single1=Single-&gt;GetInstance();//当上一步执行后便可用此方法获取唯一类实例</span><br><span class="line">CSingle &amp; Single1=Single-&gt;GetInstance();//当然也可以这样</span><br></pre></td></tr></table></figure></p><p><strong> <table><tr><td bgcolor="BlueViolet">上面的做法对于单线程来说可以表现的很好了，但是对于多线程来说，就可能有问题了。当两个线程同时创建实例的时候，这时候实例不存在，这时候就可能产生两个类实例，于是我们就需要用同步的方法保证创建的时候只有一个线程。线程同步的方法很多，可以是临界区，可以是互斥等。</td></tr></table></strong></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;设计一个类,我们只能生成该类的一个实例&lt;/p&gt;
&lt;p&gt;这道题显然是对设计模式的考察,很明显是单例模式。什么是单例模式呢,就是就像题目所说的只
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-面试题1:赋值运算符函数</title>
    <link href="http://yoursite.com/2015/07/20/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%981-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2015/07/20/剑指offer-面试题1-赋值运算符函数/</id>
    <published>2015-07-20T12:37:08.000Z</published>
    <updated>2018-09-17T17:39:08.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CMyString</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CMyString(char *pData=NULL);</span><br><span class="line">    CMyString(const CMyString &amp; str);</span><br><span class="line">    ~CMyString(void);</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    char * m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>首先在解答这道题目之前,先要作一些说明:</p><ol><li><p>任何类都是默认的重载赋值操作符。</p></li><li><p>类一旦被声明并且编译后就会为该类的实例分配内存。</p></li><li><p>如果类的成员变量没有在堆(动态分配)中分配内存，那么无需重载赋值操作符也可。因为这样的赋值只是为每个成员变量赋值而已。</p></li></ol><p>比如:对象A有成员变量int a1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.a1=1;</span><br><span class="line">A b;</span><br><span class="line">b.a1=2; </span><br><span class="line">a=b;</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>当执行到a=b;这一步的时候其实即使我们没有重载赋值操作符,也会调用类A的对象a的默认赋值函数</p><p>至此,对象a中的a1成功赋值为b1即2，没有问题的。</p><p>接下来我们要考虑另外一种情况</p><p>假如类A中有一个指针成员变量int *ptr;该ptr在构造函数中new了一块内存。那么我们重新考虑类A的两个对象a,b。对象a,b分别有一个指针ptr，并且该指针在构造函数中分别new了一块内存我们分别以mema和memb表示。在a的ptr中new的内存mema中的值我们设为1,在b的ptr中new的内存memb中的值我们设为2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;/在构造函数new ptr(mema)</span><br><span class="line">A b;/在构造函数new ptr(memb)</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure></p><p>当我们执行到a=b这一步的时候,我们如果没有重载赋值操作符。那么<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void A::operate = (A b)</span><br><span class="line">&#123;</span><br><span class="line">     this.ptr=b.ptr;5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><table><tr><td bgcolor="">乍看好像也没什么错,是的<br>this.ptr=b.ptr这句是将对象b.ptr的所指向的内推地址memb赋值给了a.ptr所指向的对象。好了问题来了,那么a.ptr所指向的那块内推是分配在堆中的也就所如果我们没有主动释放它是不会自动释放的。然而a.ptr已经指向了memb，这样很明显对象a出现了内存泄露。当然问题还不止于此,现在a.ptr和b.ptr都同时指向了memb.那么如果当对象a或者b结束后必然会释放掉memb，比如说a先结束释放memb，那么b.ptr是不是就成了野指针了呢,如果b先结束,那么a.ptr便成为了野指针,同时对象a还出现了内存泄露.</td></tr></table></strong></p><p>那么你会问为什么之前直接赋值就可以而这里直接赋值就不行呢,这就涉及一个内存管理的问题,分配在堆的内存是需要我们用户自己释放的,而分配在栈的内存是由程序自己管理，程序结束后会自动释放。</p><p>现在明白重载赋值操作符的场景了吧，</p><p>那么还有几点需要说明:</p><ol><li>赋值操作符重载通常形参我们是引用,引用可以减少直接传值带来的构造开销.</li><li>赋值操作符重载通常形参是常量,这是为了防止在赋值过程中操作符右值被修改。</li><li>如果为了连续赋值应该把返回值类型声明为该类型的引用,否则函数的返回值为void,不能连续赋值。</li><li>当然为我们还应该考虑传入的对象是否和被赋值对象是否相等。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>综合以上因素，这道题结果如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::operator = (const CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(this==&amp;str)</span><br><span class="line">        <span class="built_in">return</span> *this;</span><br><span class="line"> </span><br><span class="line">    delete []m_pData;</span><br><span class="line">    m_pData=NULL;</span><br><span class="line"> </span><br><span class="line">    m_pData=new char[strlen(str.m_pData)+1];</span><br><span class="line"> </span><br><span class="line">    strcpy(m_pData,str.m_pData);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如下为类型CMyString的声明，请为该类型添加赋值运算符函数&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer-C-C/"/>
    
    
      <category term="剑指offer(C/C++)" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-C-C/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议详解卷1--第一章概述--读书笔记</title>
    <link href="http://yoursite.com/2015/06/25/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/</id>
    <published>2015-06-25T02:44:11.000Z</published>
    <updated>2018-09-18T16:56:29.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>百度百科这样说TCP/IP协议:<br>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</p><p>好了我再说说我的理解:<br>先说说OSI(open System Interconnection)互联开放模型,是某某某组织为网络互联提供的一种标准模型。记住只是一种模型而已,它大致是这样的，为了表示原创性,图片我尽量画。<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/1.jpg" alt="TCP/IP协议详解"></p><p>好了，在整个理论的模型基础上,美国某某某组织定义和实现了TCP/IP协议,这个协议就是现在我们网络连接时这样用的协议,记住TCP/IP是个协议族,意思是他有很多协议,好了既然TCP/IP协议是在OSI模型上定义和实现的,那么两者的关系大概是这样:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/2.jpg" alt="TCP/IP协议详解"></p><p>明白了,TCP/IP协议将OSI的前三层融合到一层，而传输层和网络层仍然没有改变,物理层为OSI模型中的数据链路层和物理层这两层的结合。</p><h2 id="TCP-IP各层的意义和各层的意义"><a href="#TCP-IP各层的意义和各层的意义" class="headerlink" title="TCP/IP各层的意义和各层的意义"></a>TCP/IP各层的意义和各层的意义</h2><blockquote><ul><li>首先:应用层是基于底层协议实现的各种协议，是我们用户之间可以接触到的,比如我们远程登录使用的Telnet协议,比如我们发送邮件的SMTP(简单邮件传输协议),比如我们接受邮件用的pop3协议等。</li><li>其次:传输层,书上说传输层是提供端到端的传输，好晦涩，端是啥我不懂，我的理解是传输层通过端口来进行两个主机之间的通信，因为网络层的IP封装已经提供了主机IP的信息，所以传输层只需要提供某IP的端口信息就可以建议与该主机相<br>应的端口进行通信。传输层的协议包括TCP和UDP两种协议,TCP是可靠的,什么是可靠的呢,意思就是使用TCP协议通信会对本次通信的过程进行保证,保证什么,保证信息从源机到目的机，其中用的机制包括建立连接，超时重传等。UDP提供一种不可靠,不可靠是啥意思呢，就是我只管给你传送,至于你收不到收不到也就跟我没毛关系了。</li><li>网络层，主要协议是IP协议，网络层就是网络互联，意思就是什么呢，提供连个主机之间的连接，而这种连接就是基于IP地址的，理论上说只要是连接到Internet网上的每台主机都有一个唯一的IP地址，这样我们就可以用这个唯一IP就可以连接到任何一台电脑，但是理想很丰满，现实很骨感，IPv4是不够用的，那意思就是说每台电脑就不可能划分唯一的IP，但是科学技术是第一生产力，你懂的总有方法解决，比如划分子网，DHCP等用来缓解IP紧张的压力，但是这不是根本的，根本的就是IPv6的推行和发展才能从根本上解决这个问题，提供足够的IP给世界上接入互联网的每个终端。</li><li>最后；物理层也叫网络接口层，这一层的主要目的是提供网络传输的物理细节，这一层包括了很多协议比如最流行的的以太网协议。</li></ul></blockquote><p><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/3.jpg" alt="TCP/IP协议详解"></p><h2 id="IP地址和端口"><a href="#IP地址和端口" class="headerlink" title="IP地址和端口"></a>IP地址和端口</h2><p>IP地址是很重要的，为啥重要，如何没有这玩意儿我们不可能连接到Internet整个庞大的网络，现在用的IPv4提供的IP数量理论上是不够用的，所以呢有某某某组织也在积极的推动IPv6标准IPv4包括32位，通常表示成点分10进制，例如192.168.1.1但是在内存中还是2进制表示,类似<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000011000000000000100000001</span><br></pre></td></tr></table></figure></p><p>其结构类似这样:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/4.jpg" alt="TCP/IP协议详解"></p><p>这就是5类IP地址的结构,<br>我们可以根据网络号转化成点分10进制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A类:0.0.0.0-127.255.255.255</span><br><span class="line">B类:128.0.0.0-191.255.255.255</span><br><span class="line">C类:192.0.0.0-223.255.255.255</span><br><span class="line">D类:234.0.0.0-239.255.255.255</span><br><span class="line">E类:240.0.0.0-247.255.255.255</span><br></pre></td></tr></table></figure></p><p>从A-E网络号站的位数依次增多，主机号占的位数依次减少意思就是啥呢:分配一个A类地址,可以包含2^24个主机 而分配一个C类地址只有2^8(256)个主机,我们还可以直接根据点分10进制的的一个数判断此类IP到底是那类IP地址。当然如果有子网划分就不能只靠判断哪类地址来决定其主机个数，还要结合子网掩码一起来判断。</p><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS Domain Name System 域名解析系统,这是Internet提供的一项服务。当我们上网的时候需要在浏览器键入我们想要浏览的网站，通常我们是键入网站的域名，为什么用域名呢，因为域名好用啊，好记啊，不敢想象如果我们浏览网站总是要通过IP来访问服务器那是多么痛苦。那这个DNS是如何实现的呢，其实DNS解析是通过<br>分布在世界各地的DNS服务器来实现的，每个DNS服务器都会维护一个默认的域名和IP映射表，当我们通过域名访问网站的时候，该域名首先进入DNS服务器，然后在域名IP映射表中进行查询，如果查询到对应的IP，然后通过IP对服务器进行寻址访问，如果没有找到该映射项，那么就会在上一级的DNS服务器中继续查找。</p><p>我们可以通过dos下运行命令来查询本机的DNS服务器IP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure></p><h2 id="关于Tcp-ip通信过程"><a href="#关于Tcp-ip通信过程" class="headerlink" title="关于Tcp/ip通信过程"></a>关于Tcp/ip通信过程</h2><p>那么说到这里，大家就想问TCP/IP协议族如何实现主机之间的通信连接呢这里我只有继续发挥的我绘画功底和想象能力了:<br><img src="/2015/06/25/TCP-IP协议详解卷1-第一章概述-读书笔记/5.jpg" alt="TCP/IP协议详解"><br>这就是TCP/IP通信过程,其实就是解包和封包的过程，而后面我们具体就要学的就是各个层中有哪些解包封包的方式，这些解包封包方式的差异就形成了各个层中不同的协议。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;百度百科这样说TCP/IP协议:&lt;br&gt;Transmission Control Protocol/Internet Protocol的简写
      
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>wireshark----教你如何抓包</title>
    <link href="http://yoursite.com/2015/06/24/wireshark-%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85/"/>
    <id>http://yoursite.com/2015/06/24/wireshark-教你如何抓包/</id>
    <published>2015-06-24T05:54:02.000Z</published>
    <updated>2018-09-18T17:32:12.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>wireshark是一款强大的抓包工具,走过路过一定不要错过就是了,当你学习TCP/IP协议的时候,学习使用wireshark抓包正是理论联系实际最好的方法,先大概看看协议,然后抓取各种协议包分析每个字节就可以和每层协议的封装<br>相对应。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>抓包之前首先你得安装wireshark是吧.wireshark图标大概是这样。<br><img src="/2015/06/24/wireshark-教你如何抓包/1.jpg" alt="抓包"><br>打开之后大概是这样:<br><img src="/2015/06/24/wireshark-教你如何抓包/2.jpg" alt="抓包"><br>有两张网卡：我用的无线网卡上网的所以我选择下面的:<br><img src="/2015/06/24/wireshark-教你如何抓包/3.jpg" alt="抓包"><br>开始抓包:<br><img src="/2015/06/24/wireshark-教你如何抓包/4.jpg" alt="抓包"><br>抓了好多是吧。但是这些包的意义是什么呢 我们以DNS协议为例,我们开启抓包,访问<a href="http://blog.csdn.net/" target="_blank" rel="noopener">http://blog.csdn.net/</a> 我们知道访问某个网站的时候先会在域名服务器上查询域名的IP</p><p>那么我们会看到有这样一个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/5.jpg" alt="抓包"></p><p>我们在包上点击右键:<br><img src="/2015/06/24/wireshark-教你如何抓包/6.jpg" alt="抓包"><br>Follow UDP Stream会跟踪整个DNS查询过程。</p><p>这时会只会剩下两个包,一个请求查询包,一个response包，这里有两个IP地址:192.168.1.109为我本机的IP地址,202.112.14.151为DNS服务器地址这些信息我们可以通过DOS的ipconfig /all查询<br><img src="/2015/06/24/wireshark-教你如何抓包/7.jpg" alt="抓包"></p><p>我们点开第一个包：<br><img src="/2015/06/24/wireshark-教你如何抓包/8.jpg" alt="抓包"><br>从上到下分别为:可以看出各层对应的协议,User Datagram Protocol表示该DNS查询包使用的是UDP传输协议,所以follow udp stream 懂了吧Domain Name System(query)DNS查询懂了吧我们点击Domain Name System(query)看看16进制大概是这样：<br><img src="/2015/06/24/wireshark-教你如何抓包/9.jpg" alt="抓包"></p><p>我们再看看第一个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/10.jpg" alt="抓包"><br>看到了吧 我们查询的是blog.csdn.net域名<br>再看看第二个包:<br><img src="/2015/06/24/wireshark-教你如何抓包/11.jpg" alt="抓包"><br>看到了吧这是第二个包返回我们的查询IP </p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;wireshark是一款强大的抓包工具,走过路过一定不要错过就是了,当你学习TCP/IP协议的时候,学习使用wireshark抓包正是理论联
      
    
    </summary>
    
      <category term="抓包" scheme="http://yoursite.com/categories/%E6%8A%93%E5%8C%85/"/>
    
    
      <category term="抓包" scheme="http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>TCP快速重传和快速恢复</title>
    <link href="http://yoursite.com/2015/04/21/TCP%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2015/04/21/TCP快速重传和快速恢复/</id>
    <published>2015-04-21T05:24:55.000Z</published>
    <updated>2018-09-18T17:01:36.980Z</updated>
    
    <content type="html"><![CDATA[<p>当tcp传送一个分组时会设置一个定时器，如果在规定的实际间隔内没有收到ACK分组，那么则重新传输该分组，但是如果tcp收到三个连续的ACK分组，此时不管是否过超时间隔则重传该分组，具体步骤如下:</p><table><tr><td bgcolor="green">1. 将慢启动阈值ssthresh设为拥塞窗口(cwnd–可理解为发送数据包大小)的一半<br>2. 对于连续三个重复的ACK报文，cwnd依次加1，重发分组<br>3. 当新的ACK分组再次到来的时候，把拥塞窗口的大小设为慢启动阈值的大小<br>4. 进入拥塞避免算法。<br><em> 1,2,3个步骤为快速重传机制，为什么快，因为不需要等定时器时间到再重传</em> 1,2,3,4则是快速恢复机制</td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当tcp传送一个分组时会设置一个定时器，如果在规定的实际间隔内没有收到ACK分组，那么则重新传输该分组，但是如果tcp收到三个连续的ACK分组，此时不管是否过超时间隔则重传该分组，具体步骤如下:&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;green&quot;&gt;1. 将
      
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>linux下mysql数据库的操作</title>
    <link href="http://yoursite.com/2015/03/12/linux%E4%B8%8Bmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2015/03/12/linux下mysql数据库的操作/</id>
    <published>2015-03-12T02:17:03.000Z</published>
    <updated>2018-09-18T16:08:00.002Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。"><a href="#本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。" class="headerlink" title="本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。"></a>本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。</h5><h2 id="Mysql数据库的安装"><a href="#Mysql数据库的安装" class="headerlink" title="Mysql数据库的安装"></a>Mysql数据库的安装</h2><p>数据库的安装分为源码安装和rpm安装。</p><p>当然对于老手来说需要进行一些自定义的配置，那么当然源码安装的灵活性要高一些。但是这种安装方式需要管理员自己处理好于系统的依赖关系。而rpm安装是已经经过编译的二进制文件，然而这种方式仍然对于处理依赖关系很麻烦，于是产生了一种基于rpm包的前端管理软件yum,yum可以从特点的镜像源下载rpm包并进行自动安装，配置和移除以及在线更新。<br>而作为linux新手，又是centos用户。我当然选择yum安装。<br>一般情况下centos都会自带mysql数据库。</p><table><tr><td bgcolor="green">1. yum list installed mysql* 查看是否安装了Mysql。若有安装则无需再安装。如果需要重新安装需进行如下步骤。<br>2. /etc/init.d/mysqld stop     停止服务<br>3. rpm -qa|grep -i mysql     查看安装的rpm包<br>4. 如果有mysql的rpm包，则命令 rpm -e 包名  删除包<br>4. yum list|grep mysql         从yum源列出mysql的rpm包、<br>5. 选择相应的包进行安装<br>- 客户端 ： yum install mysql<br>- 服务器端：yum install -y mysql-server mysql-devel<br></td></tr></table><h2 id="几种主要目录的说明"><a href="#几种主要目录的说明" class="headerlink" title="几种主要目录的说明"></a>几种主要目录的说明</h2><p>通过命令 find / -name mysql* 可以查看相关的mysql目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- /var/lib/mysql         数据库文件目录      </span><br><span class="line">- /usr/bin               用户可执行的mysql命令目录</span><br><span class="line">- /etc/my.cnf            mysql配置文件  </span><br><span class="line"></span><br><span class="line">- /usr/share/doc          mysql文档目录  </span><br><span class="line">- /usr/share/man          mysql联机帮助文档目录       </span><br><span class="line">- /usr/share/mysql        mysql配置文件目录    </span><br><span class="line">- /var/run/mysqld         mysql运行状态目录 </span><br><span class="line">- /var/<span class="built_in">log</span>/mysql.log      mysql日志目录      </span><br><span class="line">- /etc/rc.d/init.d/mysqld mysql启动脚本</span><br><span class="line">- /usr/lib/mysql          mysql库文件目录</span><br></pre></td></tr></table></figure></p><ul><li>注：mysql程序查找配置文件的顺序为 /etc  mysql安装目录  mysql数据目录而配置文件位于/usr/share/mysql下的四个文件my-small.cnf my-medium.cnf my-large.cnf my-huge.cnf。可将要使用的配置模板复制到/etc/my.cnf这样在程序一开始查找配置文件便可以查找。</li><li><h2 id="mysql数据库的简单操作"><a href="#mysql数据库的简单操作" class="headerlink" title="mysql数据库的简单操作"></a>mysql数据库的简单操作</h2></li></ul><p>启动服务：service mysql start 或者 /etc/init.d/mysql start<br>停止服务：service mysql stop  或者 /etc/init.d/mysql stop<br>重启服务：service mysql restart 或者 /etc/init.d/mysql restart</p><table><tr><td bgcolor="green">安装后默认只有root用户且无密码 也可用匿名用户登录 直接输入mysql即可进入mysql命令界面</td></tr></table><h2 id="mysql命令界面的基本操作"><a href="#mysql命令界面的基本操作" class="headerlink" title="mysql命令界面的基本操作"></a>mysql命令界面的基本操作</h2><p>使用命令 mysql -u root -p 进入mysql命令界面</p><pre><code class="bash">create database mysqltest;   创建数据库show databases;      显示/var/lib/mysql目录下当前存在的数据库  其中mysql和<span class="built_in">test</span>数据库是系统自带的两个数据库 mysql中有系统信息，十分重要。       use  mysqltest;    切换数据库show tables;    显示数据库中的表其余select,insert,update等语句详情参阅相关的sql语法书籍</code></pre><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。&quot;&gt;&lt;a href=&quot;#本文主要针对linux【Centos】下mysql数据库的安装，以及数据库的创建和简单的数据库操作进行说明。&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>VC++6.0下通过opencv读入图像并反色</title>
    <link href="http://yoursite.com/2015/01/06/VC-6-0%E4%B8%8B%E9%80%9A%E8%BF%87opencv%E8%AF%BB%E5%85%A5%E5%9B%BE%E5%83%8F%E5%B9%B6%E5%8F%8D%E8%89%B2/"/>
    <id>http://yoursite.com/2015/01/06/VC-6-0下通过opencv读入图像并反色/</id>
    <published>2015-01-06T12:19:43.000Z</published>
    <updated>2018-09-17T18:22:16.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>第一个opencv测试程序:不多说,直接上代码,代码注释很详尽:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">////////////////////////////////////////////////////////////////////////</span><br><span class="line">//</span><br><span class="line">// 该程序从文件中读入一幅图像，将之反色，然后显示出来. </span><br><span class="line">//</span><br><span class="line">////////////////////////////////////////////////////////////////////////</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;math.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cv.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;highgui.h&gt; </span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    IplImage* img = 0;    //定义图像文件指针,指向载入的原始图像</span><br><span class="line">    IplImage* pDstImg = 0; //定义图像文件指针,指向反色后的图像</span><br><span class="line">    //定位图像的长度(像素),宽带(像素),通道数(指每个像素用多少个字节表示)   </span><br><span class="line">    int height,width,channels;  </span><br><span class="line">    uchar *data;      //存储图像具体的像素数据</span><br><span class="line"></span><br><span class="line">    char Image_Filename[20];  //输入图像文件的文件名</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the filename of image:\n"</span>);</span><br><span class="line">    scanf(<span class="string">"%s"</span>,Image_Filename);</span><br><span class="line"> </span><br><span class="line">   //载入图像函数,第一个参数为图像名称.第二个参数为辅助参数，</span><br><span class="line">   //有正,零,负三种值.正数表示以三通道图像载入(三通道即一个像素用3个字节表示),0表示</span><br><span class="line">   //以单通道载入图像，负数代表载入图像的通道数由图像本身决定.</span><br><span class="line">    img=cvLoadImage(Image_Filename,0);  </span><br><span class="line">                         </span><br><span class="line">                        </span><br><span class="line">    <span class="keyword">if</span>(!img)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not load image file: %s\n"</span>,argv[1]);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    height    = img-&gt;height;  //获取图像高度(像素)</span><br><span class="line">    width     = img-&gt;width;        //获取图像宽度(像素)</span><br><span class="line">    channels  = img-&gt;nChannels; //获取图像通道数</span><br><span class="line">    data      = (uchar *)img-&gt;imageData;  //获取图像像素数据</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Processing a %dx%d image with %d channels\n"</span>,height,width,channels); </span><br><span class="line">    </span><br><span class="line">    //创建一个名称为mainWin的窗口,用于显示图像.CV_WINDOW_AUTOSIZE值为1</span><br><span class="line">    //表示固定窗口大小,若第二个参数为0表示窗口大小可变,图像也会随着窗口的大小而改变</span><br><span class="line">    cvNamedWindow(<span class="string">"mainWin"</span>, 0);   </span><br><span class="line">                </span><br><span class="line">    //设置窗口的位置,第一个参数为窗口的名字,后面两个参数为窗口显示的位置,(0,0)表示显示在桌面的左上角.    </span><br><span class="line">    cvMoveWindow(<span class="string">"mainWin"</span>, 0, 0); </span><br><span class="line">    </span><br><span class="line">    //cvCreateImage函数返回指向一个图像文件指针,第一个参数指定图像</span><br><span class="line">    //的大小,第二个参数制定 像素的位深度，主要有以下支持格式：</span><br><span class="line">    //IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,IPL_DEPTH_16S, IPL_DEPTH_32S,</span><br><span class="line">    //最后一个参数制定图像的通道数</span><br><span class="line">    pDstImg = cvCreateImage(cvGetSize(img),img-&gt;depth,img-&gt;nChannels); </span><br><span class="line">                                     </span><br><span class="line">                                           </span><br><span class="line">                                    </span><br><span class="line">    //cvNot(IplImage* src,IplImage* dest)将src图像的每个像素数据的每一位取反赋值给dest图像对应像素点数据</span><br><span class="line">    cvNot(img, pDstImg);   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cvShowImage(<span class="string">"mainWin"</span>, img ); //在之前创建的mainWin窗口中显示图像</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    cvWaitKey(0);     //等待敲击键盘,结束程序    </span><br><span class="line">    </span><br><span class="line">    cvReleaseImage(&amp;img );  //释放图像文件指针</span><br><span class="line">    cvReleaseImage(&amp;pDstImg ); </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2015/01/06/VC-6-0下通过opencv读入图像并反色/1.png" alt="OpenCV"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;第一个opencv测试程序:不多说,直接上代码,代码注释很详尽:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>TCP 协议三次握手过程解析带实例</title>
    <link href="http://yoursite.com/2014/11/21/TCP-%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90%E5%B8%A6%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2014/11/21/TCP-协议三次握手过程解析带实例/</id>
    <published>2014-11-21T03:17:52.000Z</published>
    <updated>2018-09-18T17:05:23.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TCP(Transmission Control Protocol)　传输控制协议<br>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。<br>位码即tcp标志位,有6种标示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYN(synchronous建立联机)</span><br><span class="line">ACK(acknowledgement 确认)</span><br><span class="line">PSH(push传送)</span><br><span class="line">FIN(finish结束)</span><br><span class="line">RST(reset重置)</span><br><span class="line">URG(urgent紧急)</span><br></pre></td></tr></table></figure><ul><li>Sequence number(顺序号码) </li><li>Acknowledge number(确认号码) </li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。可用wireshark等抓包软件查看三次握手过程 </p><ul><li>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； </li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据. </li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836 </span><br><span class="line">IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837 </span><br><span class="line">IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1</span><br></pre></td></tr></table></figure><ul><li><p>第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机; </p></li><li><p>第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包; </p></li><li><p>第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。</p></li></ul><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;TCP(Transmission Control Protocol)　传输控制协议&lt;br&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接
      
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="TCP/IP协议详解" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>windows套接字相关函数</title>
    <link href="http://yoursite.com/2014/08/10/windows%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2014/08/10/windows套接字相关函数/</id>
    <published>2014-08-10T12:53:10.000Z</published>
    <updated>2018-09-18T15:56:18.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们学习TCP/IP协议无非是利用这些协议进行通信开发，然而如果让我们自己来直接根据协议规则和协议格式来进行网络开发无疑是一件十分痛苦的事情，显然为了减轻程序员的开发负担，windows提供给我们一套网络开发的API，这个API族就叫做套接字库。</p><p>但是套接字和TCP/IP协议到底是什么关系呢。<br>我们暂且可以这样理解,如图:<br><img src="/2014/08/10/windows套接字相关函数/1.jpg" alt="网络编程"></p><h2 id="win-socket-API"><a href="#win-socket-API" class="headerlink" title="win socket API"></a>win socket API</h2><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>MSDN这样描述:<br><img src="/2014/08/10/windows套接字相关函数/1.png" alt="网络编程"></p><p>该函数创建一个套接字,参数af为协议族类型AF_INET为TCP/IP协议族type为套接字类型，有两种类似SOCK_STREAM为使用TCP进行通信 SOCK_STREAM为使用UDP进行通信protocol可以为IPPROTO_TCP或IPPROTO_IP，此参数英语type保存一致</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>顾名思义即绑定,用过套接字编程的都知道,当我们编写服务端程序的时候需要使用该函数MSDN这样描述:<br><img src="/2014/08/10/windows套接字相关函数/2.png" alt="网络编程"></p><p>该函数将一个本地的地址绑定到一个套接字上，如果绑定不错位，将返回0，否则将返回SOCKET_ERROR,参数s为需要绑定的套接字,参数*name为一个常量sockaddr结构，但是一般情况下我们都使用sockaddr_in结构,其结构定义如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">　　short int sin_family; /* Address family */</span><br><span class="line">　　unsigned short int sin_port; /* Port number */</span><br><span class="line">　　struct sin_addr sin_addr; /* Internet address */</span><br><span class="line">　　unsigned char sin_zero[8]; /* Same size as struct sockaddr */</span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>sin_family：指代协议族，在socket编程中只能是AF_INET</li><li>sin_port：存储端口号（使用网络字节顺序）</li><li>sin_addr：存储IP地址，使用in_addr这个数据结构</li><li>sin_zero：是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节。</li></ul><p>其中sin_addr定义:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct in_addr &#123;</span><br><span class="line">　　union &#123;</span><br><span class="line">　　struct&#123; unsigned char s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　struct&#123; unsigned short s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　unsigned long S_addr;</span><br><span class="line">　　&#125; S_un;</span><br><span class="line">　　&#125; IN_ADDR;</span><br></pre></td></tr></table></figure></p><p>一般我们这样用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrs.sin_addr.S_addr=inet_addr(<span class="string">"192.168.1.110"</span>)</span><br></pre></td></tr></table></figure></p><p>函数inet_addr可以把字符串直接转换成in_addr类型也可以使用inet_ntoa()将in_addr类型转换为字符串类型参数namelen即为name的长度 即sizeof(name)<br>举个典型的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SOCKET s;</span><br><span class="line">s=socket(AF_INET,SOCK_STREAM,IPPOTO_TCP);</span><br><span class="line">sockaddr_in addrbindto;</span><br><span class="line">addrbindto.sin_family=AF_INET;</span><br><span class="line">addrbindto.port=htons(8001) //htons是将u_short类型转换为网络字节序,htonl是将u_long类型转换为网络字节序</span><br><span class="line">addrbindto.sin_addr_S_addr=inet_addr(<span class="string">"192.168.1.110"</span>)</span><br><span class="line"><span class="built_in">bind</span>(s,(</span><br><span class="line">const struct sockaddr</span><br><span class="line">)&amp;addrbindto,sizeof(addrbindto))</span><br></pre></td></tr></table></figure></p><h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p><img src="/2014/08/10/windows套接字相关函数/3.png" alt="网络编程"><br>该函数在指定的套接字上监听连接请求,参数s为监听的套接字,backlog表示表示允许的最大连接数<br>举例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(s,5);</span><br></pre></td></tr></table></figure></p><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p><img src="/2014/08/10/windows套接字相关函数/4.png" alt="网络编程"><br>该函数对一个指定的套接字建立连接参数s为想要建立连接的套接字name为sockaddr类型的指针namelen即为sizeof(name)</p><p>举例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOCKET s;</span><br><span class="line">sockaddr_in conaddr;</span><br><span class="line">s=socket(AF_INET,SOCK_STREAM,IPPOTO_TCP);</span><br><span class="line">conaddr.sin_family=AF_INET;</span><br><span class="line">conaddr.port=htons(8001) //htons是将u_short类型转换为网络字节序,htonl是将u_long类型转换为网络字节序</span><br><span class="line">conaddr.sin_addr_S_addr=inet_addr(<span class="string">"192.168.1.110"</span>)</span><br><span class="line">connect(s,(const struct sockaddr)&amp;conaddr,sizeof(conaddr))</span><br></pre></td></tr></table></figure></p><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p><img src="/2014/08/10/windows套接字相关函数/5.png" alt="网络编程"><br>该函数用于向已连接的套接字发送数据<br>参数s为一个连接到的套接字<br>参数buf为发送数据的缓存<br>参数len为发送缓存数据的长度</p><p>举例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[20]=<span class="string">"hello123"</span>;</span><br><span class="line">send(s,(const char *)buf,sizeof(buf))</span><br></pre></td></tr></table></figure></p><h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><p><img src="/2014/08/10/windows套接字相关函数/6.png" alt="网络编程"></p><p>该函数为接受函数:参数与send类型,不在赘述</p><h2 id="recvfrom-sendto"><a href="#recvfrom-sendto" class="headerlink" title="recvfrom,sendto"></a>recvfrom,sendto</h2><p>这两个函数功能与send与recv类似,只是它们用于UDP通信中</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们学习TCP/IP协议无非是利用这些协议进行通信开发，然而如果让我们自己来直接根据协议规则和协议格式来进行网络开发无疑是一件十分痛苦的事情
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>套接字基础</title>
    <link href="http://yoursite.com/2014/08/03/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2014/08/03/套接字基础/</id>
    <published>2014-08-03T06:28:11.000Z</published>
    <updated>2018-09-18T14:40:02.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字原理"><a href="#套接字原理" class="headerlink" title="套接字原理"></a>套接字原理</h2><p>本文是续上文关于基于TCP套接字实现的简单Demo后进行套接字基本知识的讲解.<br>可能文中有一些术语使用不太准确,但作为我自己的理解,尽量以通俗的语言为大家讲解.</p><p>套接字即Socket.用于在进程之间进行通信.当然进程通信的方式多种多样,但是Socket在进程通信的使用却十分广泛.</p><p>当然这里有几个概念需要区分.http,socket,tcp/ip之间的关系.大家都知道,现在互联网中广泛使用TCP/IP协议,如果你想要在当前的网络中传输数据,那么就必须遵守TCP/IP协议准则,而http是属于应用层面的协议,与FTP,Telnet等协议类似,当然还有用户自定义的一些协议.这些协议的目的是对TCP/IP传输的数据进行解析.而Socket作为进程通信的手段也是基于TCP/IP协议的,然而我们要实现应用层协议或者实现自己的协议,我们必须使用Socket提供的借口才能使这些协议数据是通过TCP/IP协议准则传输的.</p><p>总之,TCP/IP是根本的准则.通过Socket我们才能利用TCP/IP协议.而应用层协议则提供我们对Socket传输的数据进行封包和解析的标准.</p><p>对于一个套接字,我们可以看做是一条电话线路,而这条线路的建立则是基于TCP/IP标准的,而电话线两端就是我们通信的双方.</p><p>那么一个套接字如何标识一个链接或者说如何识别通信的双方呢.</p><p><strong> <table><tr><td bgcolor="green">那就是套接字三元组:    套接字=协议+端口+IP</td></tr></table></strong></p><h2 id="套接字分类"><a href="#套接字分类" class="headerlink" title="套接字分类"></a>套接字分类</h2><p>根据使用的协议类型不同,套接字分为三类.</p><ol><li>TCP套接字</li><li>UDP套接字</li><li>原始套接字.</li></ol><p>其中使用较为广泛的是TCP套接字和UDP套接字.而原始套接字是基于数据链路层协议.这里不作介绍.</p><p>了解TCP协议都知道,TCP是面向链接的协议,在通信之前在通信双方要先进行“三次握手”成功建立连接后才能进行通信,所以其传输数据时可靠的,然而正是因为此原因,使得TCP的套接字传输效率要低一些.</p><p>而UDP套接字是面向无连接，但是不提供可靠的数据传输.这点说明在传输的过程中有可能出现数据丢失,但是正是在传输之前不需要建议连接,这种数据传输的方式要高于TCP传输方式.</p><p>原始套接字在这里也不作介绍,因为我也很少接触.</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>关于Socket字的方式 有两类</p><ol><li>阻塞方式</li><li>非阻塞方式.</li></ol><p>我们可以简单的这样理解,阻塞方式是当建立多个套接字连接后,多个套接字同时传输和接受数据的方式可以成为非阻塞方式.而相反,当多个套接字进行连接后,只有只有当一个套接字完成接或者发数据的方式后才能进行下一个套接字的收或者发数据的动作成为阻塞方式.显然阻塞方式要比非阻塞方式复杂.但是在实际应用中大多使用阻塞方式进行数据传输.阻塞方式大多使用多线程的方式实现.</p><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">short sin_family;//AF_INET</span><br><span class="line">u_short sin_port;//16位端口号，网络字节顺序</span><br><span class="line">struct in_addr sin_addr;//32位IP地址，网络字节顺序</span><br><span class="line">char sin_zero[8];//保留</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个套接字地址结构就将套接字三元组完整的定义了.</p><h2 id="TCP套接字的流程"><a href="#TCP套接字的流程" class="headerlink" title="TCP套接字的流程"></a>TCP套接字的流程</h2><p><img src="/2014/08/03/套接字基础/1.png" alt="网络编程"></p><p>不难看出我们可以对TCP套接字的服务器端和客户端用到的API进行总结：</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server:"></a>Server:</h2><ul><li>加载套接字库,进行套接字库初始化.这样我们才能使用需要的套接字.</li><li><p>创建套接字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：SOCKET PASCAL FAR socket(int af,int <span class="built_in">type</span>,int procotol);</span><br><span class="line">参数：af: 通信发生的区域</span><br><span class="line"><span class="built_in">type</span>: 要建立的套接字类型</span><br><span class="line">procotol: 使用的特定协议</span><br></pre></td></tr></table></figure></li><li><p>初始化服务器端套接字地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line">addrSrv.sin_port = htons(6000)</span><br></pre></td></tr></table></figure></li><li><p>将套接字号和服务器端套接字进行绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能：将套接字地址与所创建的套接字号联系起来。格式：int PASCAL FAR <span class="built_in">bind</span>(SOCKET s,const struct sockaddr FAR * name,int namelen);</span><br><span class="line">参数：s: 是由socket()调用返回的并且未作连接的套接字描述符（套接字号）。</span><br><span class="line">其它：没有错误，<span class="built_in">bind</span>()返回0，否则SOCKET_ERROR</span><br></pre></td></tr></table></figure></li><li><p>接受来自客户端的连接请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOCKET PASCAL FAR accept(SOCKET s,struct sockaddr FAR * name,int FAR * addrlen);</span><br><span class="line">参数：同上</span><br></pre></td></tr></table></figure></li><li><p>数据发送和接受</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：数据的发送与接收</span><br><span class="line">格式：int PASCAL FAR send(SOCKET s,const char FAR * buf,int len,int flags);</span><br><span class="line">int PASCAL FAR recv(SOCKET s,const char FAR * buf,int len,int flags);</span><br><span class="line">参数：buf:指向存有传输数据的缓冲区的指针</span><br></pre></td></tr></table></figure></li><li><p>传输结束，关闭套接字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭套接字――closesocket()</span><br><span class="line">功能：关闭套接字s</span><br><span class="line">格式：BOOL PASCAL FAR closesocket(SOCKET s);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h2><ol><li>建立客户端套接字同上</li><li>将客户端套接字和服务器端地址接受绑定同上</li><li><p>连接服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int PASCAL FAR connect(SOCKET s,const struct sockaddr FAR * name,int namelen);</span><br></pre></td></tr></table></figure></li><li><p>进行数据发送和接受同上</p></li><li>关闭套接字同上</li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>至此,关于Window套接字就介绍完了,虽然不尽详尽,但是我尽可能给大家讲清楚一些基本概念,和一些基本流程.在完全理解后,读者可以参照基于TCP套接字实现的简单Demo一文写一些自己的套接字小Demo.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;套接字原理&quot;&gt;&lt;a href=&quot;#套接字原理&quot; class=&quot;headerlink&quot; title=&quot;套接字原理&quot;&gt;&lt;/a&gt;套接字原理&lt;/h2&gt;&lt;p&gt;本文是续上文关于基于TCP套接字实现的简单Demo后进行套接字基本知识的讲解.&lt;br&gt;可能文中有一些术语使用不太准确
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于最大最小距离的分类数目上限K确定的聚类方法</title>
    <link href="http://yoursite.com/2014/07/20/%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%88%86%E7%B1%BB%E6%95%B0%E7%9B%AE%E4%B8%8A%E9%99%90K%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/</id>
    <published>2014-07-20T14:17:33.000Z</published>
    <updated>2018-09-17T18:35:01.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>聚类是数据挖掘很重要的组成部分.而大多数聚类算法都需要事先确定分类数目K.而本文是在实际情况下确定分类数目K的上限.进而对数据样本进行自动分类.</p><h2 id="原始算法流程"><a href="#原始算法流程" class="headerlink" title="原始算法流程"></a>原始算法流程</h2><p>设样本集为X{x(1),x(2)…….}</p><ol><li>选取任意一个样本作为第一个聚类中心 如z(1)=x(1)</li><li>选取距离z(1)最远的样本点作为第二个聚类中心,设为z(2)</li><li>计算每个样本到z(1),z(2)的距离D(i,1),D(i,2);并选出其中最小的距离T(i)=min(D(i,1),D(i,2))</li><li>在所有样本最小值中选择最大值即max(T);</li><li>若max(T(i))&gt;=θ|z(1)-z(2)|,(θ为事先给定,|z(1)-z(2)|为两聚类中心的距离),则z(3)=x(i),否则无新的聚类中心.则找聚类中心结束,θ可用试探法,只要能将想要的类别识别即可.这里设z(3)=x(7)</li><li>若z(3)存在,则继续步骤3,计算每个样本到z(1),z(2),z(3)的距离D(i,1),D(i,2),D(i,3);并选出其中最小的距离T(i)=min(D(i,1),D(i,2),D(i,3))</li><li>重复步骤4,5直到不满足5的条件,聚类结束.</li><li>假设一共只要三个聚类中心.那么比较每个样本点到三个聚类中心的距离.距离最小者即符合该类,属于该类.</li></ol><h2 id="优化后算法流程"><a href="#优化后算法流程" class="headerlink" title="优化后算法流程"></a>优化后算法流程</h2><p>设样本集为X{x(1),x(2)……..},此样本集最多分为3类,即k=1或k=2或k=3</p><ol><li>首先将样本集合的数据进行升序排序Y(y(1),y(2)…….y(N))</li><li>如果样本集至少存在一个数据,则说明至少存在一类.取排序后的第一个数为第一个聚类中心z(1)=y(1);避免了随机选取带来的不稳定性</li><li>如果排序后的样本集合最后一个元素的值减去第一个元素值&gt;5 即认为存在两类,这里取最后一个元素为第二个聚类中心.z(2)=y(N)<strong><td bgcolor="BlueViolet">这也符合前两个聚类中心距离最远的条件.</td></strong></li><li>再根据最大最小距离判定法则对剩下的聚类中心进行判定.</li></ol><h2 id="matlab仿真："><a href="#matlab仿真：" class="headerlink" title="matlab仿真："></a>matlab仿真：</h2><h5 id="代码历史悠久-不保证能跑起来"><a href="#代码历史悠久-不保证能跑起来" class="headerlink" title="代码历史悠久 不保证能跑起来"></a>代码历史悠久 不保证能跑起来</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">%   load Data1.mat  %加载数据</span><br><span class="line"> ClomStatic=[7,1,3,5,1,56,57,53,24,16,20,21];</span><br><span class="line">len=length(ClomStatic);%求向量ClomStatic的长度</span><br><span class="line"></span><br><span class="line">%如果存在非零长度,则至少为一类.</span><br><span class="line"><span class="keyword">if</span>(len&gt;0)</span><br><span class="line">    k=1;</span><br><span class="line">    Z(k)=ClomStatic(1);         %取第一个位置为第一个聚类中心</span><br><span class="line">    TempZ=ClomStatic(len);</span><br><span class="line"></span><br><span class="line">    %如果最大最小数值差值大于20,则至少存在两类</span><br><span class="line">     <span class="keyword">if</span>(TempZ-Z(1)&gt;=5)</span><br><span class="line">            k=k+1;</span><br><span class="line">            Z(k)=ClomStatic(len);       %取第最后个位置为第二个聚类中心</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        %逐个求出各个样本和聚类中心Z(1),Z(2)之间的距离选出每个点到聚类中心中的较小值</span><br><span class="line">        D=zeros(len,2);</span><br><span class="line">        M=zeros(1,len);</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            D(i,1)=abs(ClomStatic(i)-Z(1));</span><br><span class="line">            D(i,2)=abs(ClomStatic(i)-Z(2));</span><br><span class="line">            M(i)=min(D(i,:));</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        %在M中找出最大值和20(20为聚类间隔,自定义设定),若大于,则产生新的聚类中心,否则无新的聚类中心,判断是否存在第三类</span><br><span class="line">        [m indexm]=max(M);</span><br><span class="line">            <span class="keyword">if</span>(m&gt;0.32*abs(Z(1)-Z(2)))</span><br><span class="line">                k=k+1;      %如果k&lt;3则聚类结束</span><br><span class="line">                Z(k)=ClomStatic(indexm);</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">        %若Z(3)存在</span><br><span class="line">        <span class="keyword">if</span>(k==3)</span><br><span class="line">            %将样本按最近距离分到最近的聚类中心 k=3</span><br><span class="line">            TempDistance=zeros(len,k);</span><br><span class="line">            p1=1;</span><br><span class="line">            p2=1;</span><br><span class="line">            p3=1;</span><br><span class="line">            <span class="keyword">for</span> i=1:len</span><br><span class="line">                <span class="keyword">for</span> j=1:k</span><br><span class="line">                    TempDistance(i,j)=abs(ClomStatic(i)-Z(j));</span><br><span class="line">                end</span><br><span class="line">                [Dis GroupIndex]=min(TempDistance(i,:));</span><br><span class="line">                <span class="keyword">if</span>(GroupIndex==1)%Group保存最终的分类结果</span><br><span class="line">                     Group1(p1)=ClomStatic(i);</span><br><span class="line">                     p1=p1+1;</span><br><span class="line">                 elseif(GroupIndex==2)</span><br><span class="line">                     Group2(p2)=ClomStatic(i);</span><br><span class="line">                      p2=p2+1;</span><br><span class="line">                 elseif(GroupIndex==3)</span><br><span class="line">                     Group3(p3)=ClomStatic(i);</span><br><span class="line">                     p3=p3+1;</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            %求类中心</span><br><span class="line">            ClassCenter=zeros(1,3);</span><br><span class="line">            ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">            ClassCenter(2)=floor(sum(Group2)/length(Group2));</span><br><span class="line">            ClassCenter(3)=floor(sum(Group3)/length(Group3));</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         %将样本按最近距离分到最近的聚类中心 k=2</span><br><span class="line">        TempDistance=zeros(len,k);</span><br><span class="line">        p1=1;</span><br><span class="line">        p2=1;</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            <span class="keyword">for</span> j=1:k</span><br><span class="line">                TempDistance(i,j)=abs(ClomStatic(i)-Z(j));</span><br><span class="line">            end</span><br><span class="line">            [Dis GroupIndex]=min(TempDistance(i,:));</span><br><span class="line">            <span class="keyword">if</span>(GroupIndex==1)                       %Group保存最终的分类结果</span><br><span class="line">                 Group1(p1)=ClomStatic(i);</span><br><span class="line">                p1=p1+1;</span><br><span class="line">             elseif(GroupIndex==2)</span><br><span class="line">                 Group2(p2)=ClomStatic(i);</span><br><span class="line">                p2=p2+1;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        %求类中心</span><br><span class="line">        ClassCenter=zeros(1,2);</span><br><span class="line">               </span><br><span class="line">        ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">        ClassCenter(2)=floor(sum(Group2)/length(Group2));</span><br><span class="line">     end</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">       %k=1;</span><br><span class="line">         j=1;</span><br><span class="line">        <span class="keyword">for</span> i=1:len</span><br><span class="line">            Group1(j)=ClomStatic(i);</span><br><span class="line">            j=j+1;</span><br><span class="line">        end</span><br><span class="line">       %求类中心</span><br><span class="line">        ClassCenter=zeros(1,1);</span><br><span class="line">               </span><br><span class="line">        ClassCenter(1)=floor(sum(Group1)/length(Group1));</span><br><span class="line">     end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="仿真结果三类划分："><a href="#仿真结果三类划分：" class="headerlink" title="仿真结果三类划分："></a>仿真结果三类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/1.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/2.png" alt="分类聚类"></p><h2 id="仿真结果二类划分："><a href="#仿真结果二类划分：" class="headerlink" title="仿真结果二类划分："></a>仿真结果二类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/3.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/4.png" alt="分类聚类"></p><h2 id="仿真结果一类划分："><a href="#仿真结果一类划分：" class="headerlink" title="仿真结果一类划分："></a>仿真结果一类划分：</h2><p>测试数据：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/5.png" alt="分类聚类"><br>结果：<br><img src="/2014/07/20/基于最大最小距离的分类数目上限K确定的聚类方法/6.png" alt="分类聚类"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;聚类是数据挖掘很重要的组成部分.而大多数聚类算法都需要事先确定分类数目K.而本文是在实际情况下确定分类数目K的上限.进而对数据样本进行自动分
      
    
    </summary>
    
      <category term="分类聚类" scheme="http://yoursite.com/categories/%E5%88%86%E7%B1%BB%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="分类聚类" scheme="http://yoursite.com/tags/%E5%88%86%E7%B1%BB%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>基于TCP套接字实现的简单Demo</title>
    <link href="http://yoursite.com/2014/07/18/%E5%9F%BA%E4%BA%8ETCP%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95Demo/"/>
    <id>http://yoursite.com/2014/07/18/基于TCP套接字实现的简单Demo/</id>
    <published>2014-07-18T14:34:29.000Z</published>
    <updated>2018-09-18T14:18:55.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>由于代码的注释已经很详尽了,所以这里不再作过多说明.仅仅贴出代码和结果图.<br>值得注意的是必须先启动server程序再启动client.</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;WINSOCK2.H&gt;    //套接字库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT       6000 //服务器端口</span></span><br><span class="line"><span class="comment">#define MSGSIZE    1024 //收发缓冲区的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pragma comment(lib, "ws2_32.lib") //链接静态库</span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI FunThread(LPVOID); //创建一个线程，专门用来接收数据</span><br><span class="line"></span><br><span class="line">SOCKET      sClient; //连接所用套节字</span><br><span class="line">SOCKET      sListen; //监听套接字</span><br><span class="line">SOCKADDR_IN client; //保存客户的地址信息</span><br><span class="line">int         iaddrSize = sizeof(SOCKADDR_IN);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    WSADATA     wsaData;        //WSADATA结构体中主要包含了系统所支持的Winsock版本信息</span><br><span class="line">    SOCKADDR_IN <span class="built_in">local</span>;        //定义本地套接字地址</span><br><span class="line">    char        s_Message[MSGSIZE]; //收发缓冲区</span><br><span class="line"></span><br><span class="line">    WSAStartup(0x0202, &amp;wsaData); //初始化套接字库</span><br><span class="line">    </span><br><span class="line">    sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//创建服务器监听套节字。TCP协议</span><br><span class="line">    </span><br><span class="line">    local.sin_family = AF_INET; //AF_INET指明使用TCP/IP协议族</span><br><span class="line">    local.sin_port = htons(PORT);//指明连接服务器的端口号</span><br><span class="line">    local.sin_addr.s_addr = htonl(INADDR_ANY);//自动获取本机地址</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sListen, (struct sockaddr *)&amp;<span class="built_in">local</span>, sizeof(SOCKADDR_IN));//地址绑定到套接字</span><br><span class="line">    </span><br><span class="line">    listen(sListen, 1);//开始监听</span><br><span class="line">    </span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);//建立连接,返回用于连接的套接字</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepte client:%s:%d\n"</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));//输出客户端的IP地址和端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HANDLE hThread=CreateThread(NULL,0,FunThread,0,0,0);//运行至此创建专门的接收线程用于接收客户端发送</span><br><span class="line">                                //的数据,在监听主线程上创建一个新的数据接收线程</span><br><span class="line">    CloseHandle(hThread);//关闭线程句柄</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用于从服务器端向客户端发送数据</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server Send:"</span>);</span><br><span class="line">        //从键盘输入</span><br><span class="line">        gets(s_Message);                        </span><br><span class="line">        //发送数据</span><br><span class="line">        send(sClient, s_Message, strlen(s_Message), 0); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当接收数据时调用此线程函数</span><br><span class="line">DWORD WINAPI FunThread(LPVOID)</span><br><span class="line">&#123;   </span><br><span class="line">    char c_Message[MSGSIZE]; //接收数据缓冲区</span><br><span class="line">    int ret; //接收字节的个数</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;  </span><br><span class="line">        ret = recv(sClient, c_Message, MSGSIZE, 0);//接收数据到缓冲区</span><br><span class="line">        </span><br><span class="line">        //判断是否成功接收,如果未成功接收则重启监听,将原缓冲区的数据归零</span><br><span class="line">        <span class="keyword">if</span>(ret==SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nclient is closed!"</span>);</span><br><span class="line">            </span><br><span class="line">            sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);//重新开始监听</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nAccepte new client:%s:%d"</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line">            memset(c_Message,0,1024);//将原来的client message归零</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c_Message[ret] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nReceived: %s\n"</span>, c_Message); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; </span><br><span class="line">&#125;&lt;strong&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;WINSOCK2.H&gt; //套接字库</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SERVER_ADDRESS "127.0.0.1" //服务器端IP地址,由于服务也在本地机器上所以用环回地址127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PORT           6000    //客户端绑定端口     </span></span><br><span class="line"><span class="comment">#define MSGSIZE        1024        //客户端接收数据缓冲区大小    </span></span><br><span class="line"><span class="comment">#pragma comment(lib, "ws2_32.lib") </span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI FunThread(LPVOID); //对于客户端接收数据的线程函数   </span><br><span class="line"></span><br><span class="line">SOCKET      sClient;         //客户端套接字      </span><br><span class="line">SOCKADDR_IN server;           //服务器端套接字</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    WSADATA     wsaData; </span><br><span class="line">    char        c_Message[MSGSIZE]; //数据缓冲区</span><br><span class="line">    </span><br><span class="line">    WSAStartup(0x0202, &amp;wsaData); //初始化套接字库</span><br><span class="line">    </span><br><span class="line">    sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    //创建客户端套接字</span><br><span class="line">    </span><br><span class="line">    memset(&amp;server, 0, sizeof(SOCKADDR_IN));               //先将保存地址的server置为全0</span><br><span class="line">    server.sin_family = PF_INET;                           //声明地址格式是TCP/IP地址格式</span><br><span class="line">    server.sin_port = htons(PORT);                         //指明连接服务器的端口号</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    //指明连接服务器的IP地址</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    connect(sClient, (struct sockaddr *)&amp;server, sizeof(SOCKADDR_IN)); //连到刚才指明的服务器上</span><br><span class="line"></span><br><span class="line">    HANDLE hThread=CreateThread(NULL,0,FunThread,0,0,0);;//客户端开辟接收数据线程</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">    //客户端向服务器发送数据</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client Send:"</span>);</span><br><span class="line">        gets(c_Message);   </span><br><span class="line">        </span><br><span class="line">        send(sClient, c_Message, strlen(c_Message), 0); </span><br><span class="line">        <span class="keyword">if</span>(!strcmp(c_Message,<span class="string">"exit"</span>))//client自身退出</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放连接和进行结束工作</span><br><span class="line">    closesocket(sClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收线程函数</span><br><span class="line">DWORD WINAPI FunThread(LPVOID)</span><br><span class="line">&#123;</span><br><span class="line">    char   s_Message[MSGSIZE];//定义接收缓冲区</span><br><span class="line">    int    ret; </span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = recv(sClient, s_Message, MSGSIZE, 0);//接收服务器端的数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        //判断是否接收</span><br><span class="line">        <span class="keyword">if</span>(ret==SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nServer is closed!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">        &#125;</span><br><span class="line">        s_Message[ret] = <span class="string">'\0'</span>;  </span><br><span class="line">        //显示接收数据</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nReceived: %s\n"</span>, s_Message);</span><br><span class="line">        </span><br><span class="line">        //如果服务器端发送<span class="built_in">exit</span>则client退出</span><br><span class="line">        <span class="keyword">if</span>(!strcmp(s_Message,<span class="string">"exit"</span>))//server让client退出</span><br><span class="line">            <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;&lt;strong&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2014/07/18/基于TCP套接字实现的简单Demo/1.png" alt="网络编程"><br><img src="/2014/07/18/基于TCP套接字实现的简单Demo/2.png" alt="网络编程"></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;由于代码的注释已经很详尽了,所以这里不再作过多说明.仅仅贴出代码和结果图.&lt;br&gt;值得注意的是必须先启动server程序再启动client.
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
